// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/pubsub/v1/pubsub.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A policy constraining the storage of messages published to the topic.
struct Google_Pubsub_V1_MessageStoragePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of IDs of GCP regions where messages that are published to the topic
  /// may be persisted in storage. Messages published by publishers running in
  /// non-allowed GCP regions (or running outside of GCP altogether) will be
  /// routed for storage in one of the allowed regions. An empty list means that
  /// no regions are allowed, and is not a valid configuration.
  var allowedPersistenceRegions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A topic resource.
struct Google_Pubsub_V1_Topic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic. It must have the format
  /// `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
  /// and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
  /// underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
  /// signs (`%`). It must be between 3 and 255 characters in length, and it
  /// must not start with `"goog"`.
  var name: String = String()

  /// See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
  /// managing labels</a>.
  var labels: Dictionary<String,String> = [:]

  /// Policy constraining the set of Google Cloud Platform regions where messages
  /// published to the topic may be stored. If not present, then no constraints
  /// are in effect.
  var messageStoragePolicy: Google_Pubsub_V1_MessageStoragePolicy {
    get {return _messageStoragePolicy ?? Google_Pubsub_V1_MessageStoragePolicy()}
    set {_messageStoragePolicy = newValue}
  }
  /// Returns true if `messageStoragePolicy` has been explicitly set.
  var hasMessageStoragePolicy: Bool {return self._messageStoragePolicy != nil}
  /// Clears the value of `messageStoragePolicy`. Subsequent reads from it will return its default value.
  mutating func clearMessageStoragePolicy() {self._messageStoragePolicy = nil}

  /// The resource name of the Cloud KMS CryptoKey to be used to protect access
  /// to messages published on this topic.
  ///
  /// The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
  var kmsKeyName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messageStoragePolicy: Google_Pubsub_V1_MessageStoragePolicy? = nil
}

/// A message that is published by publishers and consumed by subscribers. The
/// message must contain either a non-empty data field or at least one attribute.
/// Note that client libraries represent this object differently
/// depending on the language. See the corresponding
/// <a href="https://cloud.google.com/pubsub/docs/reference/libraries">client
/// library documentation</a> for more information. See
/// <a href="https://cloud.google.com/pubsub/quotas">Quotas and limits</a>
/// for more information about message limits.
struct Google_Pubsub_V1_PubsubMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message data field. If this field is empty, the message must contain
  /// at least one attribute.
  var data: Data = Data()

  /// Attributes for this message. If this field is empty, the message must
  /// contain non-empty data. This can be used to filter messages on the
  /// subscription.
  var attributes: Dictionary<String,String> = [:]

  /// ID of this message, assigned by the server when the message is published.
  /// Guaranteed to be unique within the topic. This value may be read by a
  /// subscriber that receives a `PubsubMessage` via a `Pull` call or a push
  /// delivery. It must not be populated by the publisher in a `Publish` call.
  var messageID: String = String()

  /// The time at which the message was published, populated by the server when
  /// it receives the `Publish` call. It must not be populated by the
  /// publisher in a `Publish` call.
  var publishTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _publishTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_publishTime = newValue}
  }
  /// Returns true if `publishTime` has been explicitly set.
  var hasPublishTime: Bool {return self._publishTime != nil}
  /// Clears the value of `publishTime`. Subsequent reads from it will return its default value.
  mutating func clearPublishTime() {self._publishTime = nil}

  /// If non-empty, identifies related messages for which publish order should be
  /// respected. If a `Subscription` has `enable_message_ordering` set to `true`,
  /// messages published with the same non-empty `ordering_key` value will be
  /// delivered to subscribers in the order in which they are received by the
  /// Pub/Sub system. All `PubsubMessage`s published in a given `PublishRequest`
  /// must specify the same `ordering_key` value.
  /// <b>EXPERIMENTAL:</b> This feature is part of a closed alpha release. This
  /// API might be changed in backward-incompatible ways and is not recommended
  /// for production use. It is not subject to any SLA or deprecation policy.
  var orderingKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publishTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request for the GetTopic method.
struct Google_Pubsub_V1_GetTopicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic to get.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the UpdateTopic method.
struct Google_Pubsub_V1_UpdateTopicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated topic object.
  var topic: Google_Pubsub_V1_Topic {
    get {return _topic ?? Google_Pubsub_V1_Topic()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {self._topic = nil}

  /// Required. Indicates which fields in the provided topic to update. Must be
  /// specified and non-empty. Note that if `update_mask` contains
  /// "message_storage_policy" but the `message_storage_policy` is not set in
  /// the `topic` provided above, then the updated value is determined by the
  /// policy configured at the project or organization level.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topic: Google_Pubsub_V1_Topic? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for the Publish method.
struct Google_Pubsub_V1_PublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The messages in the request will be published on this topic.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  /// Required. The messages to publish.
  var messages: [Google_Pubsub_V1_PubsubMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `Publish` method.
struct Google_Pubsub_V1_PublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-assigned ID of each published message, in the same order as
  /// the messages in the request. IDs are guaranteed to be unique within
  /// the topic.
  var messageIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListTopics` method.
struct Google_Pubsub_V1_ListTopicsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which to list topics.
  /// Format is `projects/{project-id}`.
  var project: String = String()

  /// Maximum number of topics to return.
  var pageSize: Int32 = 0

  /// The value returned by the last `ListTopicsResponse`; indicates that this is
  /// a continuation of a prior `ListTopics` call, and that the system should
  /// return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListTopics` method.
struct Google_Pubsub_V1_ListTopicsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resulting topics.
  var topics: [Google_Pubsub_V1_Topic] = []

  /// If not empty, indicates that there may be more topics that match the
  /// request; this value should be passed in a new `ListTopicsRequest`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListTopicSubscriptions` method.
struct Google_Pubsub_V1_ListTopicSubscriptionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic that subscriptions are attached to.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  /// Maximum number of subscription names to return.
  var pageSize: Int32 = 0

  /// The value returned by the last `ListTopicSubscriptionsResponse`; indicates
  /// that this is a continuation of a prior `ListTopicSubscriptions` call, and
  /// that the system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListTopicSubscriptions` method.
struct Google_Pubsub_V1_ListTopicSubscriptionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The names of subscriptions attached to the topic specified in the request.
  var subscriptions: [String] = []

  /// If not empty, indicates that there may be more subscriptions that match
  /// the request; this value should be passed in a new
  /// `ListTopicSubscriptionsRequest` to get more subscriptions.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListTopicSnapshots` method.
struct Google_Pubsub_V1_ListTopicSnapshotsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic that snapshots are attached to.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  /// Maximum number of snapshot names to return.
  var pageSize: Int32 = 0

  /// The value returned by the last `ListTopicSnapshotsResponse`; indicates
  /// that this is a continuation of a prior `ListTopicSnapshots` call, and
  /// that the system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListTopicSnapshots` method.
struct Google_Pubsub_V1_ListTopicSnapshotsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The names of the snapshots that match the request.
  var snapshots: [String] = []

  /// If not empty, indicates that there may be more snapshots that match
  /// the request; this value should be passed in a new
  /// `ListTopicSnapshotsRequest` to get more snapshots.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `DeleteTopic` method.
struct Google_Pubsub_V1_DeleteTopicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the topic to delete.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the DetachSubscription method.
struct Google_Pubsub_V1_DetachSubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription to detach.
  /// Format is `projects/{project}/subscriptions/{subscription}`.
  var subscription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the DetachSubscription method.
/// Reserved for future use.
struct Google_Pubsub_V1_DetachSubscriptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A subscription resource.
struct Google_Pubsub_V1_Subscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription. It must have the format
  /// `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
  /// start with a letter, and contain only letters (`[A-Za-z]`), numbers
  /// (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
  /// plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
  /// in length, and it must not start with `"goog"`.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. The name of the topic from which this subscription is receiving
  /// messages. Format is `projects/{project}/topics/{topic}`. The value of this
  /// field will be `_deleted-topic_` if the topic has been deleted.
  var topic: String {
    get {return _storage._topic}
    set {_uniqueStorage()._topic = newValue}
  }

  /// If push delivery is used with this subscription, this field is
  /// used to configure it. An empty `pushConfig` signifies that the subscriber
  /// will pull and ack messages using API methods.
  var pushConfig: Google_Pubsub_V1_PushConfig {
    get {return _storage._pushConfig ?? Google_Pubsub_V1_PushConfig()}
    set {_uniqueStorage()._pushConfig = newValue}
  }
  /// Returns true if `pushConfig` has been explicitly set.
  var hasPushConfig: Bool {return _storage._pushConfig != nil}
  /// Clears the value of `pushConfig`. Subsequent reads from it will return its default value.
  mutating func clearPushConfig() {_uniqueStorage()._pushConfig = nil}

  /// The approximate amount of time (on a best-effort basis) Pub/Sub waits for
  /// the subscriber to acknowledge receipt before resending the message. In the
  /// interval after the message is delivered and before it is acknowledged, it
  /// is considered to be <i>outstanding</i>. During that time period, the
  /// message will not be redelivered (on a best-effort basis).
  ///
  /// For pull subscriptions, this value is used as the initial value for the ack
  /// deadline. To override this value for a given message, call
  /// `ModifyAckDeadline` with the corresponding `ack_id` if using
  /// non-streaming pull or send the `ack_id` in a
  /// `StreamingModifyAckDeadlineRequest` if using streaming pull.
  /// The minimum custom deadline you can specify is 10 seconds.
  /// The maximum custom deadline you can specify is 600 seconds (10 minutes).
  /// If this parameter is 0, a default value of 10 seconds is used.
  ///
  /// For push delivery, this value is also used to set the request timeout for
  /// the call to the push endpoint.
  ///
  /// If the subscriber never acknowledges the message, the Pub/Sub
  /// system will eventually redeliver the message.
  var ackDeadlineSeconds: Int32 {
    get {return _storage._ackDeadlineSeconds}
    set {_uniqueStorage()._ackDeadlineSeconds = newValue}
  }

  /// Indicates whether to retain acknowledged messages. If true, then
  /// messages are not expunged from the subscription's backlog, even if they are
  /// acknowledged, until they fall out of the `message_retention_duration`
  /// window. This must be true if you would like to
  /// <a
  /// href="https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time">
  /// Seek to a timestamp</a>.
  var retainAckedMessages: Bool {
    get {return _storage._retainAckedMessages}
    set {_uniqueStorage()._retainAckedMessages = newValue}
  }

  /// How long to retain unacknowledged messages in the subscription's backlog,
  /// from the moment a message is published.
  /// If `retain_acked_messages` is true, then this also configures the retention
  /// of acknowledged messages, and thus configures how far back in time a `Seek`
  /// can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10
  /// minutes.
  var messageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._messageRetentionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._messageRetentionDuration = newValue}
  }
  /// Returns true if `messageRetentionDuration` has been explicitly set.
  var hasMessageRetentionDuration: Bool {return _storage._messageRetentionDuration != nil}
  /// Clears the value of `messageRetentionDuration`. Subsequent reads from it will return its default value.
  mutating func clearMessageRetentionDuration() {_uniqueStorage()._messageRetentionDuration = nil}

  /// See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
  /// managing labels</a>.
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// If true, messages published with the same `ordering_key` in `PubsubMessage`
  /// will be delivered to the subscribers in the order in which they
  /// are received by the Pub/Sub system. Otherwise, they may be delivered in
  /// any order.
  /// <b>EXPERIMENTAL:</b> This feature is part of a closed alpha release. This
  /// API might be changed in backward-incompatible ways and is not recommended
  /// for production use. It is not subject to any SLA or deprecation policy.
  var enableMessageOrdering: Bool {
    get {return _storage._enableMessageOrdering}
    set {_uniqueStorage()._enableMessageOrdering = newValue}
  }

  /// A policy that specifies the conditions for this subscription's expiration.
  /// A subscription is considered active as long as any connected subscriber is
  /// successfully consuming messages from the subscription or is issuing
  /// operations on the subscription. If `expiration_policy` is not set, a
  /// *default policy* with `ttl` of 31 days will be used. The minimum allowed
  /// value for `expiration_policy.ttl` is 1 day.
  var expirationPolicy: Google_Pubsub_V1_ExpirationPolicy {
    get {return _storage._expirationPolicy ?? Google_Pubsub_V1_ExpirationPolicy()}
    set {_uniqueStorage()._expirationPolicy = newValue}
  }
  /// Returns true if `expirationPolicy` has been explicitly set.
  var hasExpirationPolicy: Bool {return _storage._expirationPolicy != nil}
  /// Clears the value of `expirationPolicy`. Subsequent reads from it will return its default value.
  mutating func clearExpirationPolicy() {_uniqueStorage()._expirationPolicy = nil}

  /// An expression written in the Pub/Sub [filter
  /// language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
  /// then only `PubsubMessage`s whose `attributes` field matches the filter are
  /// delivered on this subscription. If empty, then no messages are filtered
  /// out.
  var filter: String {
    get {return _storage._filter}
    set {_uniqueStorage()._filter = newValue}
  }

  /// A policy that specifies the conditions for dead lettering messages in
  /// this subscription. If dead_letter_policy is not set, dead lettering
  /// is disabled.
  ///
  /// The Cloud Pub/Sub service account associated with this subscriptions's
  /// parent project (i.e.,
  /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
  /// permission to Acknowledge() messages on this subscription.
  var deadLetterPolicy: Google_Pubsub_V1_DeadLetterPolicy {
    get {return _storage._deadLetterPolicy ?? Google_Pubsub_V1_DeadLetterPolicy()}
    set {_uniqueStorage()._deadLetterPolicy = newValue}
  }
  /// Returns true if `deadLetterPolicy` has been explicitly set.
  var hasDeadLetterPolicy: Bool {return _storage._deadLetterPolicy != nil}
  /// Clears the value of `deadLetterPolicy`. Subsequent reads from it will return its default value.
  mutating func clearDeadLetterPolicy() {_uniqueStorage()._deadLetterPolicy = nil}

  /// A policy that specifies how Pub/Sub retries message delivery for this
  /// subscription.
  ///
  /// If not set, the default retry policy is applied. This generally implies
  /// that messages will be retried as soon as possible for healthy subscribers.
  /// RetryPolicy will be triggered on NACKs or acknowledgement deadline
  /// exceeded events for a given message.
  var retryPolicy: Google_Pubsub_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Google_Pubsub_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Indicates whether the subscription is detached from its topic. Detached
  /// subscriptions don't receive messages from their topic and don't retain any
  /// backlog. `Pull` and `StreamingPull` requests will return
  /// FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
  /// the endpoint will not be made.
  var detached: Bool {
    get {return _storage._detached}
    set {_uniqueStorage()._detached = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A policy that specifies how Cloud Pub/Sub retries message delivery.
///
/// Retry delay will be exponential based on provided minimum and maximum
/// backoffs. https://en.wikipedia.org/wiki/Exponential_backoff.
///
/// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded
/// events for a given message.
///
/// Retry Policy is implemented on a best effort basis. At times, the delay
/// between consecutive deliveries may not match the configuration. That is,
/// delay can be more or less than configured backoff.
struct Google_Pubsub_V1_RetryPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum delay between consecutive deliveries of a given message.
  /// Value should be between 0 and 600 seconds. Defaults to 10 seconds.
  var minimumBackoff: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minimumBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minimumBackoff = newValue}
  }
  /// Returns true if `minimumBackoff` has been explicitly set.
  var hasMinimumBackoff: Bool {return self._minimumBackoff != nil}
  /// Clears the value of `minimumBackoff`. Subsequent reads from it will return its default value.
  mutating func clearMinimumBackoff() {self._minimumBackoff = nil}

  /// The maximum delay between consecutive deliveries of a given message.
  /// Value should be between 0 and 600 seconds. Defaults to 600 seconds.
  var maximumBackoff: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maximumBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maximumBackoff = newValue}
  }
  /// Returns true if `maximumBackoff` has been explicitly set.
  var hasMaximumBackoff: Bool {return self._maximumBackoff != nil}
  /// Clears the value of `maximumBackoff`. Subsequent reads from it will return its default value.
  mutating func clearMaximumBackoff() {self._maximumBackoff = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minimumBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maximumBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Dead lettering is done on a best effort basis. The same message might be
/// dead lettered multiple times.
///
/// If validation on any of the fields fails at subscription creation/updation,
/// the create/update subscription request will fail.
struct Google_Pubsub_V1_DeadLetterPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the topic to which dead letter messages should be published.
  /// Format is `projects/{project}/topics/{topic}`.The Cloud Pub/Sub service
  /// account associated with the enclosing subscription's parent project (i.e.,
  /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
  /// permission to Publish() to this topic.
  ///
  /// The operation will fail if the topic does not exist.
  /// Users should ensure that there is a subscription attached to this topic
  /// since messages published to a topic with no subscriptions are lost.
  var deadLetterTopic: String = String()

  /// The maximum number of delivery attempts for any message. The value must be
  /// between 5 and 100.
  ///
  /// The number of delivery attempts is defined as 1 + (the sum of number of
  /// NACKs and number of times the acknowledgement deadline has been exceeded
  /// for the message).
  ///
  /// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
  /// client libraries may automatically extend ack_deadlines.
  ///
  /// This field will be honored on a best effort basis.
  ///
  /// If this parameter is 0, a default value of 5 is used.
  var maxDeliveryAttempts: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A policy that specifies the conditions for resource expiration (i.e.,
/// automatic resource deletion).
struct Google_Pubsub_V1_ExpirationPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the "time-to-live" duration for an associated resource. The
  /// resource expires if it is not active for a period of `ttl`. The definition
  /// of "activity" depends on the type of the associated resource. The minimum
  /// and maximum allowed values for `ttl` depend on the type of the associated
  /// resource, as well. If `ttl` is not set, the associated resource never
  /// expires.
  var ttl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_ttl = newValue}
  }
  /// Returns true if `ttl` has been explicitly set.
  var hasTtl: Bool {return self._ttl != nil}
  /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
  mutating func clearTtl() {self._ttl = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Configuration for a push delivery endpoint.
struct Google_Pubsub_V1_PushConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A URL locating the endpoint to which messages should be pushed.
  /// For example, a Webhook endpoint might use `https://example.com/push`.
  var pushEndpoint: String = String()

  /// Endpoint configuration attributes that can be used to control different
  /// aspects of the message delivery.
  ///
  /// The only currently supported attribute is `x-goog-version`, which you can
  /// use to change the format of the pushed message. This attribute
  /// indicates the version of the data expected by the endpoint. This
  /// controls the shape of the pushed message (i.e., its fields and metadata).
  ///
  /// If not present during the `CreateSubscription` call, it will default to
  /// the version of the Pub/Sub API used to make such call. If not present in a
  /// `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
  /// calls will always return a valid version, even if the subscription was
  /// created without this attribute.
  ///
  /// The only supported values for the `x-goog-version` attribute are:
  ///
  /// * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
  /// * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.
  ///
  /// For example:
  /// <pre><code>attributes { "x-goog-version": "v1" } </code></pre>
  var attributes: Dictionary<String,String> = [:]

  /// An authentication method used by push endpoints to verify the source of
  /// push requests. This can be used with push endpoints that are private by
  /// default to allow requests only from the Cloud Pub/Sub system, for example.
  /// This field is optional and should be set only by users interested in
  /// authenticated push.
  var authenticationMethod: Google_Pubsub_V1_PushConfig.OneOf_AuthenticationMethod? = nil

  /// If specified, Pub/Sub will generate and attach an OIDC JWT token as an
  /// `Authorization` header in the HTTP request for every pushed message.
  var oidcToken: Google_Pubsub_V1_PushConfig.OidcToken {
    get {
      if case .oidcToken(let v)? = authenticationMethod {return v}
      return Google_Pubsub_V1_PushConfig.OidcToken()
    }
    set {authenticationMethod = .oidcToken(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An authentication method used by push endpoints to verify the source of
  /// push requests. This can be used with push endpoints that are private by
  /// default to allow requests only from the Cloud Pub/Sub system, for example.
  /// This field is optional and should be set only by users interested in
  /// authenticated push.
  enum OneOf_AuthenticationMethod: Equatable {
    /// If specified, Pub/Sub will generate and attach an OIDC JWT token as an
    /// `Authorization` header in the HTTP request for every pushed message.
    case oidcToken(Google_Pubsub_V1_PushConfig.OidcToken)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Pubsub_V1_PushConfig.OneOf_AuthenticationMethod, rhs: Google_Pubsub_V1_PushConfig.OneOf_AuthenticationMethod) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.oidcToken, .oidcToken): return {
        guard case .oidcToken(let l) = lhs, case .oidcToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Contains information needed for generating an
  /// [OpenID Connect
  /// token](https://developers.google.com/identity/protocols/OpenIDConnect).
  struct OidcToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// [Service account
    /// email](https://cloud.google.com/iam/docs/service-accounts)
    /// to be used for generating the OIDC token. The caller (for
    /// CreateSubscription, UpdateSubscription, and ModifyPushConfig RPCs) must
    /// have the iam.serviceAccounts.actAs permission for the service account.
    var serviceAccountEmail: String = String()

    /// Audience to be used when generating OIDC token. The audience claim
    /// identifies the recipients that the JWT is intended for. The audience
    /// value is a single case-sensitive string. Having multiple values (array)
    /// for the audience field is not supported. More info about the OIDC JWT
    /// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
    /// Note: if not specified, the Push endpoint URL will be used.
    var audience: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// A message and its corresponding acknowledgment ID.
struct Google_Pubsub_V1_ReceivedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This ID can be used to acknowledge the received message.
  var ackID: String = String()

  /// The message.
  var message: Google_Pubsub_V1_PubsubMessage {
    get {return _message ?? Google_Pubsub_V1_PubsubMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// The approximate number of times that Cloud Pub/Sub has attempted to deliver
  /// the associated message to a subscriber.
  ///
  /// More precisely, this is 1 + (number of NACKs) +
  /// (number of ack_deadline exceeds) for this message.
  ///
  /// A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline
  /// exceeds event is whenever a message is not acknowledged within
  /// ack_deadline. Note that ack_deadline is initially
  /// Subscription.ackDeadlineSeconds, but may get extended automatically by
  /// the client library.
  ///
  /// Upon the first delivery of a given message, `delivery_attempt` will have a
  /// value of 1. The value is calculated at best effort and is approximate.
  ///
  /// If a DeadLetterPolicy is not set on the subscription, this will be 0.
  var deliveryAttempt: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Google_Pubsub_V1_PubsubMessage? = nil
}

/// Request for the GetSubscription method.
struct Google_Pubsub_V1_GetSubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription to get.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the UpdateSubscription method.
struct Google_Pubsub_V1_UpdateSubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated subscription object.
  var subscription: Google_Pubsub_V1_Subscription {
    get {return _subscription ?? Google_Pubsub_V1_Subscription()}
    set {_subscription = newValue}
  }
  /// Returns true if `subscription` has been explicitly set.
  var hasSubscription: Bool {return self._subscription != nil}
  /// Clears the value of `subscription`. Subsequent reads from it will return its default value.
  mutating func clearSubscription() {self._subscription = nil}

  /// Required. Indicates which fields in the provided subscription to update.
  /// Must be specified and non-empty.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subscription: Google_Pubsub_V1_Subscription? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for the `ListSubscriptions` method.
struct Google_Pubsub_V1_ListSubscriptionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which to list subscriptions.
  /// Format is `projects/{project-id}`.
  var project: String = String()

  /// Maximum number of subscriptions to return.
  var pageSize: Int32 = 0

  /// The value returned by the last `ListSubscriptionsResponse`; indicates that
  /// this is a continuation of a prior `ListSubscriptions` call, and that the
  /// system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListSubscriptions` method.
struct Google_Pubsub_V1_ListSubscriptionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The subscriptions that match the request.
  var subscriptions: [Google_Pubsub_V1_Subscription] = []

  /// If not empty, indicates that there may be more subscriptions that match
  /// the request; this value should be passed in a new
  /// `ListSubscriptionsRequest` to get more subscriptions.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the DeleteSubscription method.
struct Google_Pubsub_V1_DeleteSubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription to delete.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the ModifyPushConfig method.
struct Google_Pubsub_V1_ModifyPushConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Required. The push configuration for future deliveries.
  ///
  /// An empty `pushConfig` indicates that the Pub/Sub system should
  /// stop pushing messages from the given subscription and allow
  /// messages to be pulled and acknowledged - effectively pausing
  /// the subscription if `Pull` or `StreamingPull` is not called.
  var pushConfig: Google_Pubsub_V1_PushConfig {
    get {return _pushConfig ?? Google_Pubsub_V1_PushConfig()}
    set {_pushConfig = newValue}
  }
  /// Returns true if `pushConfig` has been explicitly set.
  var hasPushConfig: Bool {return self._pushConfig != nil}
  /// Clears the value of `pushConfig`. Subsequent reads from it will return its default value.
  mutating func clearPushConfig() {self._pushConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pushConfig: Google_Pubsub_V1_PushConfig? = nil
}

/// Request for the `Pull` method.
struct Google_Pubsub_V1_PullRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription from which messages should be pulled.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Optional. If this field set to true, the system will respond immediately
  /// even if it there are no messages available to return in the `Pull`
  /// response. Otherwise, the system may wait (for a bounded amount of time)
  /// until at least one message is available, rather than returning no messages.
  /// Warning: setting this field to `true` is discouraged because it adversely
  /// impacts the performance of `Pull` operations. We recommend that users do
  /// not set this field.
  var returnImmediately: Bool = false

  /// Required. The maximum number of messages to return for this request. Must
  /// be a positive integer. The Pub/Sub system may return fewer than the number
  /// specified.
  var maxMessages: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `Pull` method.
struct Google_Pubsub_V1_PullResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Received Pub/Sub messages. The list will be empty if there are no more
  /// messages available in the backlog. For JSON, the response can be entirely
  /// empty. The Pub/Sub system may return fewer than the `maxMessages` requested
  /// even if there are more messages available in the backlog.
  var receivedMessages: [Google_Pubsub_V1_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the ModifyAckDeadline method.
struct Google_Pubsub_V1_ModifyAckDeadlineRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Required. List of acknowledgment IDs.
  var ackIds: [String] = []

  /// Required. The new ack deadline with respect to the time this request was
  /// sent to the Pub/Sub system. For example, if the value is 10, the new ack
  /// deadline will expire 10 seconds after the `ModifyAckDeadline` call was
  /// made. Specifying zero might immediately make the message available for
  /// delivery to another subscriber client. This typically results in an
  /// increase in the rate of message redeliveries (that is, duplicates).
  /// The minimum deadline you can specify is 0 seconds.
  /// The maximum deadline you can specify is 600 seconds (10 minutes).
  var ackDeadlineSeconds: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the Acknowledge method.
struct Google_Pubsub_V1_AcknowledgeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription whose message is being acknowledged.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Required. The acknowledgment ID for the messages being acknowledged that
  /// was returned by the Pub/Sub system in the `Pull` response. Must not be
  /// empty.
  var ackIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `StreamingPull` streaming RPC method. This request is used to
/// establish the initial stream as well as to stream acknowledgements and ack
/// deadline modifications from the client to the server.
struct Google_Pubsub_V1_StreamingPullRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription for which to initialize the new stream. This
  /// must be provided in the first request on the stream, and must not be set in
  /// subsequent requests from client to server.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// List of acknowledgement IDs for acknowledging previously received messages
  /// (received on this stream or a different stream). If an ack ID has expired,
  /// the corresponding message may be redelivered later. Acknowledging a message
  /// more than once will not result in an error. If the acknowledgement ID is
  /// malformed, the stream will be aborted with status `INVALID_ARGUMENT`.
  var ackIds: [String] = []

  /// The list of new ack deadlines for the IDs listed in
  /// `modify_deadline_ack_ids`. The size of this list must be the same as the
  /// size of `modify_deadline_ack_ids`. If it differs the stream will be aborted
  /// with `INVALID_ARGUMENT`. Each element in this list is applied to the
  /// element in the same position in `modify_deadline_ack_ids`. The new ack
  /// deadline is with respect to the time this request was sent to the Pub/Sub
  /// system. Must be >= 0. For example, if the value is 10, the new ack deadline
  /// will expire 10 seconds after this request is received. If the value is 0,
  /// the message is immediately made available for another streaming or
  /// non-streaming pull request. If the value is < 0 (an error), the stream will
  /// be aborted with status `INVALID_ARGUMENT`.
  var modifyDeadlineSeconds: [Int32] = []

  /// List of acknowledgement IDs whose deadline will be modified based on the
  /// corresponding element in `modify_deadline_seconds`. This field can be used
  /// to indicate that more time is needed to process a message by the
  /// subscriber, or to make the message available for redelivery if the
  /// processing was interrupted.
  var modifyDeadlineAckIds: [String] = []

  /// Required. The ack deadline to use for the stream. This must be provided in
  /// the first request on the stream, but it can also be updated on subsequent
  /// requests from client to server. The minimum deadline you can specify is 10
  /// seconds. The maximum deadline you can specify is 600 seconds (10 minutes).
  var streamAckDeadlineSeconds: Int32 = 0

  /// A unique identifier that is used to distinguish client instances from each
  /// other. Only needs to be provided on the initial request. When a stream
  /// disconnects and reconnects for the same stream, the client_id should be set
  /// to the same value so that state associated with the old stream can be
  /// transferred to the new stream. The same client_id should not be used for
  /// different client instances.
  var clientID: String = String()

  /// Flow control settings for the maximum number of outstanding messages. When
  /// there are `max_outstanding_messages` or more currently sent to the
  /// streaming pull client that have not yet been acked or nacked, the server
  /// stops sending more messages. The sending of messages resumes once the
  /// number of outstanding messages is less than this value. If the value is
  /// <= 0, there is no limit to the number of outstanding messages. This
  /// property can only be set on the initial StreamingPullRequest. If it is set
  /// on a subsequent request, the stream will be aborted with status
  /// `INVALID_ARGUMENT`.
  var maxOutstandingMessages: Int64 = 0

  /// Flow control settings for the maximum number of outstanding bytes. When
  /// there are `max_outstanding_bytes` or more worth of messages currently sent
  /// to the streaming pull client that have not yet been acked or nacked, the
  /// server will stop sending more messages. The sending of messages resumes
  /// once the number of outstanding bytes is less than this value. If the value
  /// is <= 0, there is no limit to the number of outstanding bytes. This
  /// property can only be set on the initial StreamingPullRequest. If it is set
  /// on a subsequent request, the stream will be aborted with status
  /// `INVALID_ARGUMENT`.
  var maxOutstandingBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `StreamingPull` method. This response is used to stream
/// messages from the server to the client.
struct Google_Pubsub_V1_StreamingPullResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Received Pub/Sub messages. This will not be empty.
  var receivedMessages: [Google_Pubsub_V1_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `CreateSnapshot` method.
struct Google_Pubsub_V1_CreateSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. User-provided name for this snapshot. If the name is not provided
  /// in the request, the server will assign a random name for this snapshot on
  /// the same project as the subscription. Note that for REST API requests, you
  /// must specify a name.  See the <a
  /// href="https://cloud.google.com/pubsub/docs/admin#resource_names"> resource
  /// name rules</a>. Format is `projects/{project}/snapshots/{snap}`.
  var name: String = String()

  /// Required. The subscription whose backlog the snapshot retains.
  /// Specifically, the created snapshot is guaranteed to retain:
  ///  (a) The existing backlog on the subscription. More precisely, this is
  ///      defined as the messages in the subscription's backlog that are
  ///      unacknowledged upon the successful completion of the
  ///      `CreateSnapshot` request; as well as:
  ///  (b) Any messages published to the subscription's topic following the
  ///      successful completion of the CreateSnapshot request.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
  /// managing labels</a>.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the UpdateSnapshot method.
struct Google_Pubsub_V1_UpdateSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated snapshot object.
  var snapshot: Google_Pubsub_V1_Snapshot {
    get {return _snapshot ?? Google_Pubsub_V1_Snapshot()}
    set {_snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  var hasSnapshot: Bool {return self._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  mutating func clearSnapshot() {self._snapshot = nil}

  /// Required. Indicates which fields in the provided snapshot to update.
  /// Must be specified and non-empty.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _snapshot: Google_Pubsub_V1_Snapshot? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// A snapshot resource. Snapshots are used in
/// <a href="https://cloud.google.com/pubsub/docs/replay-overview">Seek</a>
/// operations, which allow
/// you to manage message acknowledgments in bulk. That is, you can set the
/// acknowledgment state of messages in an existing subscription to the state
/// captured by a snapshot.
struct Google_Pubsub_V1_Snapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the snapshot.
  var name: String = String()

  /// The name of the topic from which this snapshot is retaining messages.
  var topic: String = String()

  /// The snapshot is guaranteed to exist up until this time.
  /// A newly-created snapshot expires no later than 7 days from the time of its
  /// creation. Its exact lifetime is determined at creation by the existing
  /// backlog in the source subscription. Specifically, the lifetime of the
  /// snapshot is `7 days - (age of oldest unacked message in the subscription)`.
  /// For example, consider a subscription whose oldest unacked message is 3 days
  /// old. If a snapshot is created from this subscription, the snapshot -- which
  /// will always capture this 3-day-old backlog as long as the snapshot
  /// exists -- will expire in 4 days. The service will refuse to create a
  /// snapshot that would expire in less than 1 hour after creation.
  var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  mutating func clearExpireTime() {self._expireTime = nil}

  /// See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
  /// managing labels</a>.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request for the GetSnapshot method.
struct Google_Pubsub_V1_GetSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the snapshot to get.
  /// Format is `projects/{project}/snapshots/{snap}`.
  var snapshot: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListSnapshots` method.
struct Google_Pubsub_V1_ListSnapshotsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which to list snapshots.
  /// Format is `projects/{project-id}`.
  var project: String = String()

  /// Maximum number of snapshots to return.
  var pageSize: Int32 = 0

  /// The value returned by the last `ListSnapshotsResponse`; indicates that this
  /// is a continuation of a prior `ListSnapshots` call, and that the system
  /// should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListSnapshots` method.
struct Google_Pubsub_V1_ListSnapshotsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resulting snapshots.
  var snapshots: [Google_Pubsub_V1_Snapshot] = []

  /// If not empty, indicates that there may be more snapshot that match the
  /// request; this value should be passed in a new `ListSnapshotsRequest`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `DeleteSnapshot` method.
struct Google_Pubsub_V1_DeleteSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the snapshot to delete.
  /// Format is `projects/{project}/snapshots/{snap}`.
  var snapshot: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `Seek` method.
struct Google_Pubsub_V1_SeekRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription to affect.
  var subscription: String = String()

  var target: Google_Pubsub_V1_SeekRequest.OneOf_Target? = nil

  /// The time to seek to.
  /// Messages retained in the subscription that were published before this
  /// time are marked as acknowledged, and messages retained in the
  /// subscription that were published after this time are marked as
  /// unacknowledged. Note that this operation affects only those messages
  /// retained in the subscription (configured by the combination of
  /// `message_retention_duration` and `retain_acked_messages`). For example,
  /// if `time` corresponds to a point before the message retention
  /// window (or to a point before the system's notion of the subscription
  /// creation time), only retained messages will be marked as unacknowledged,
  /// and already-expunged messages will not be restored.
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .time(let v)? = target {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {target = .time(newValue)}
  }

  /// The snapshot to seek to. The snapshot's topic must be the same as that of
  /// the provided subscription.
  /// Format is `projects/{project}/snapshots/{snap}`.
  var snapshot: String {
    get {
      if case .snapshot(let v)? = target {return v}
      return String()
    }
    set {target = .snapshot(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    /// The time to seek to.
    /// Messages retained in the subscription that were published before this
    /// time are marked as acknowledged, and messages retained in the
    /// subscription that were published after this time are marked as
    /// unacknowledged. Note that this operation affects only those messages
    /// retained in the subscription (configured by the combination of
    /// `message_retention_duration` and `retain_acked_messages`). For example,
    /// if `time` corresponds to a point before the message retention
    /// window (or to a point before the system's notion of the subscription
    /// creation time), only retained messages will be marked as unacknowledged,
    /// and already-expunged messages will not be restored.
    case time(SwiftProtobuf.Google_Protobuf_Timestamp)
    /// The snapshot to seek to. The snapshot's topic must be the same as that of
    /// the provided subscription.
    /// Format is `projects/{project}/snapshots/{snap}`.
    case snapshot(String)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Pubsub_V1_SeekRequest.OneOf_Target, rhs: Google_Pubsub_V1_SeekRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.time, .time): return {
        guard case .time(let l) = lhs, case .time(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.snapshot, .snapshot): return {
        guard case .snapshot(let l) = lhs, case .snapshot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Response for the `Seek` method (this response is empty).
struct Google_Pubsub_V1_SeekResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.pubsub.v1"

extension Google_Pubsub_V1_MessageStoragePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageStoragePolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_persistence_regions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedPersistenceRegions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedPersistenceRegions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedPersistenceRegions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_MessageStoragePolicy, rhs: Google_Pubsub_V1_MessageStoragePolicy) -> Bool {
    if lhs.allowedPersistenceRegions != rhs.allowedPersistenceRegions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_Topic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Topic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "labels"),
    3: .standard(proto: "message_storage_policy"),
    5: .standard(proto: "kms_key_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._messageStoragePolicy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.kmsKeyName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 2)
    }
    try { if let v = self._messageStoragePolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.kmsKeyName.isEmpty {
      try visitor.visitSingularStringField(value: self.kmsKeyName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_Topic, rhs: Google_Pubsub_V1_Topic) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs._messageStoragePolicy != rhs._messageStoragePolicy {return false}
    if lhs.kmsKeyName != rhs.kmsKeyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PubsubMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PubsubMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "attributes"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "publish_time"),
    5: .standard(proto: "ordering_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._publishTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderingKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 2)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 3)
    }
    try { if let v = self._publishTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.orderingKey.isEmpty {
      try visitor.visitSingularStringField(value: self.orderingKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PubsubMessage, rhs: Google_Pubsub_V1_PubsubMessage) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._publishTime != rhs._publishTime {return false}
    if lhs.orderingKey != rhs.orderingKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_GetTopicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTopicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_GetTopicRequest, rhs: Google_Pubsub_V1_GetTopicRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_UpdateTopicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateTopicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_UpdateTopicRequest, rhs: Google_Pubsub_V1_UpdateTopicRequest) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PublishRequest, rhs: Google_Pubsub_V1_PublishRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.messageIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messageIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PublishResponse, rhs: Google_Pubsub_V1_PublishResponse) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "project"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicsRequest, rhs: Google_Pubsub_V1_ListTopicsRequest) -> Bool {
    if lhs.project != rhs.project {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicsResponse, rhs: Google_Pubsub_V1_ListTopicsResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSubscriptionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSubscriptionsRequest, rhs: Google_Pubsub_V1_ListTopicSubscriptionsRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSubscriptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.subscriptions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subscriptions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSubscriptionsResponse, rhs: Google_Pubsub_V1_ListTopicSubscriptionsResponse) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSnapshotsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSnapshotsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSnapshotsRequest, rhs: Google_Pubsub_V1_ListTopicSnapshotsRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSnapshotsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSnapshotsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshots"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.snapshots) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshots.isEmpty {
      try visitor.visitRepeatedStringField(value: self.snapshots, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSnapshotsResponse, rhs: Google_Pubsub_V1_ListTopicSnapshotsResponse) -> Bool {
    if lhs.snapshots != rhs.snapshots {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeleteTopicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteTopicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeleteTopicRequest, rhs: Google_Pubsub_V1_DeleteTopicRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DetachSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetachSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DetachSubscriptionRequest, rhs: Google_Pubsub_V1_DetachSubscriptionRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DetachSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetachSubscriptionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DetachSubscriptionResponse, rhs: Google_Pubsub_V1_DetachSubscriptionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_Subscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subscription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "topic"),
    4: .standard(proto: "push_config"),
    5: .standard(proto: "ack_deadline_seconds"),
    7: .standard(proto: "retain_acked_messages"),
    8: .standard(proto: "message_retention_duration"),
    9: .same(proto: "labels"),
    10: .standard(proto: "enable_message_ordering"),
    11: .standard(proto: "expiration_policy"),
    12: .same(proto: "filter"),
    13: .standard(proto: "dead_letter_policy"),
    14: .standard(proto: "retry_policy"),
    15: .same(proto: "detached"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _topic: String = String()
    var _pushConfig: Google_Pubsub_V1_PushConfig? = nil
    var _ackDeadlineSeconds: Int32 = 0
    var _retainAckedMessages: Bool = false
    var _messageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _labels: Dictionary<String,String> = [:]
    var _enableMessageOrdering: Bool = false
    var _expirationPolicy: Google_Pubsub_V1_ExpirationPolicy? = nil
    var _filter: String = String()
    var _deadLetterPolicy: Google_Pubsub_V1_DeadLetterPolicy? = nil
    var _retryPolicy: Google_Pubsub_V1_RetryPolicy? = nil
    var _detached: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _topic = source._topic
      _pushConfig = source._pushConfig
      _ackDeadlineSeconds = source._ackDeadlineSeconds
      _retainAckedMessages = source._retainAckedMessages
      _messageRetentionDuration = source._messageRetentionDuration
      _labels = source._labels
      _enableMessageOrdering = source._enableMessageOrdering
      _expirationPolicy = source._expirationPolicy
      _filter = source._filter
      _deadLetterPolicy = source._deadLetterPolicy
      _retryPolicy = source._retryPolicy
      _detached = source._detached
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._topic) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._pushConfig) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._ackDeadlineSeconds) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._retainAckedMessages) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._messageRetentionDuration) }()
        case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._enableMessageOrdering) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._expirationPolicy) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._filter) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._deadLetterPolicy) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._detached) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._topic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._topic, fieldNumber: 2)
      }
      try { if let v = _storage._pushConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._ackDeadlineSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ackDeadlineSeconds, fieldNumber: 5)
      }
      if _storage._retainAckedMessages != false {
        try visitor.visitSingularBoolField(value: _storage._retainAckedMessages, fieldNumber: 7)
      }
      try { if let v = _storage._messageRetentionDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 9)
      }
      if _storage._enableMessageOrdering != false {
        try visitor.visitSingularBoolField(value: _storage._enableMessageOrdering, fieldNumber: 10)
      }
      try { if let v = _storage._expirationPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._filter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._filter, fieldNumber: 12)
      }
      try { if let v = _storage._deadLetterPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._detached != false {
        try visitor.visitSingularBoolField(value: _storage._detached, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_Subscription, rhs: Google_Pubsub_V1_Subscription) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._pushConfig != rhs_storage._pushConfig {return false}
        if _storage._ackDeadlineSeconds != rhs_storage._ackDeadlineSeconds {return false}
        if _storage._retainAckedMessages != rhs_storage._retainAckedMessages {return false}
        if _storage._messageRetentionDuration != rhs_storage._messageRetentionDuration {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._enableMessageOrdering != rhs_storage._enableMessageOrdering {return false}
        if _storage._expirationPolicy != rhs_storage._expirationPolicy {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._deadLetterPolicy != rhs_storage._deadLetterPolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._detached != rhs_storage._detached {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_RetryPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RetryPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_backoff"),
    2: .standard(proto: "maximum_backoff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minimumBackoff) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maximumBackoff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minimumBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maximumBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_RetryPolicy, rhs: Google_Pubsub_V1_RetryPolicy) -> Bool {
    if lhs._minimumBackoff != rhs._minimumBackoff {return false}
    if lhs._maximumBackoff != rhs._maximumBackoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeadLetterPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeadLetterPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dead_letter_topic"),
    2: .standard(proto: "max_delivery_attempts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deadLetterTopic) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxDeliveryAttempts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deadLetterTopic.isEmpty {
      try visitor.visitSingularStringField(value: self.deadLetterTopic, fieldNumber: 1)
    }
    if self.maxDeliveryAttempts != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDeliveryAttempts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeadLetterPolicy, rhs: Google_Pubsub_V1_DeadLetterPolicy) -> Bool {
    if lhs.deadLetterTopic != rhs.deadLetterTopic {return false}
    if lhs.maxDeliveryAttempts != rhs.maxDeliveryAttempts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ExpirationPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpirationPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ExpirationPolicy, rhs: Google_Pubsub_V1_ExpirationPolicy) -> Bool {
    if lhs._ttl != rhs._ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PushConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_endpoint"),
    2: .same(proto: "attributes"),
    3: .standard(proto: "oidc_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pushEndpoint) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 3: try {
        var v: Google_Pubsub_V1_PushConfig.OidcToken?
        var hadOneofValue = false
        if let current = self.authenticationMethod {
          hadOneofValue = true
          if case .oidcToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.authenticationMethod = .oidcToken(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pushEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.pushEndpoint, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 2)
    }
    try { if case .oidcToken(let v)? = self.authenticationMethod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PushConfig, rhs: Google_Pubsub_V1_PushConfig) -> Bool {
    if lhs.pushEndpoint != rhs.pushEndpoint {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.authenticationMethod != rhs.authenticationMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PushConfig.OidcToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_PushConfig.protoMessageName + ".OidcToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_account_email"),
    2: .same(proto: "audience"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountEmail) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.audience) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountEmail, fieldNumber: 1)
    }
    if !self.audience.isEmpty {
      try visitor.visitSingularStringField(value: self.audience, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PushConfig.OidcToken, rhs: Google_Pubsub_V1_PushConfig.OidcToken) -> Bool {
    if lhs.serviceAccountEmail != rhs.serviceAccountEmail {return false}
    if lhs.audience != rhs.audience {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ReceivedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceivedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ack_id"),
    2: .same(proto: "message"),
    3: .standard(proto: "delivery_attempt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ackID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.deliveryAttempt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ackID.isEmpty {
      try visitor.visitSingularStringField(value: self.ackID, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.deliveryAttempt != 0 {
      try visitor.visitSingularInt32Field(value: self.deliveryAttempt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ReceivedMessage, rhs: Google_Pubsub_V1_ReceivedMessage) -> Bool {
    if lhs.ackID != rhs.ackID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.deliveryAttempt != rhs.deliveryAttempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_GetSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_GetSubscriptionRequest, rhs: Google_Pubsub_V1_GetSubscriptionRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_UpdateSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscription) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_UpdateSubscriptionRequest, rhs: Google_Pubsub_V1_UpdateSubscriptionRequest) -> Bool {
    if lhs._subscription != rhs._subscription {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSubscriptionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "project"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSubscriptionsRequest, rhs: Google_Pubsub_V1_ListSubscriptionsRequest) -> Bool {
    if lhs.project != rhs.project {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSubscriptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriptions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriptions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSubscriptionsResponse, rhs: Google_Pubsub_V1_ListSubscriptionsResponse) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeleteSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeleteSubscriptionRequest, rhs: Google_Pubsub_V1_DeleteSubscriptionRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ModifyPushConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyPushConfigRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "push_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pushConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try { if let v = self._pushConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ModifyPushConfigRequest, rhs: Google_Pubsub_V1_ModifyPushConfigRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs._pushConfig != rhs._pushConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PullRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "return_immediately"),
    3: .standard(proto: "max_messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.returnImmediately) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxMessages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if self.returnImmediately != false {
      try visitor.visitSingularBoolField(value: self.returnImmediately, fieldNumber: 2)
    }
    if self.maxMessages != 0 {
      try visitor.visitSingularInt32Field(value: self.maxMessages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PullRequest, rhs: Google_Pubsub_V1_PullRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.returnImmediately != rhs.returnImmediately {return false}
    if lhs.maxMessages != rhs.maxMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PullResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "received_messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.receivedMessages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receivedMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receivedMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PullResponse, rhs: Google_Pubsub_V1_PullResponse) -> Bool {
    if lhs.receivedMessages != rhs.receivedMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ModifyAckDeadlineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyAckDeadlineRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    4: .standard(proto: "ack_ids"),
    3: .standard(proto: "ack_deadline_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ackDeadlineSeconds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if self.ackDeadlineSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.ackDeadlineSeconds, fieldNumber: 3)
    }
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ModifyAckDeadlineRequest, rhs: Google_Pubsub_V1_ModifyAckDeadlineRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.ackDeadlineSeconds != rhs.ackDeadlineSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_AcknowledgeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "ack_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_AcknowledgeRequest, rhs: Google_Pubsub_V1_AcknowledgeRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_StreamingPullRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingPullRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "ack_ids"),
    3: .standard(proto: "modify_deadline_seconds"),
    4: .standard(proto: "modify_deadline_ack_ids"),
    5: .standard(proto: "stream_ack_deadline_seconds"),
    6: .standard(proto: "client_id"),
    7: .standard(proto: "max_outstanding_messages"),
    8: .standard(proto: "max_outstanding_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.modifyDeadlineSeconds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.modifyDeadlineAckIds) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.streamAckDeadlineSeconds) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.maxOutstandingMessages) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.maxOutstandingBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 2)
    }
    if !self.modifyDeadlineSeconds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.modifyDeadlineSeconds, fieldNumber: 3)
    }
    if !self.modifyDeadlineAckIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modifyDeadlineAckIds, fieldNumber: 4)
    }
    if self.streamAckDeadlineSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.streamAckDeadlineSeconds, fieldNumber: 5)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 6)
    }
    if self.maxOutstandingMessages != 0 {
      try visitor.visitSingularInt64Field(value: self.maxOutstandingMessages, fieldNumber: 7)
    }
    if self.maxOutstandingBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxOutstandingBytes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_StreamingPullRequest, rhs: Google_Pubsub_V1_StreamingPullRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.modifyDeadlineSeconds != rhs.modifyDeadlineSeconds {return false}
    if lhs.modifyDeadlineAckIds != rhs.modifyDeadlineAckIds {return false}
    if lhs.streamAckDeadlineSeconds != rhs.streamAckDeadlineSeconds {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.maxOutstandingMessages != rhs.maxOutstandingMessages {return false}
    if lhs.maxOutstandingBytes != rhs.maxOutstandingBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_StreamingPullResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingPullResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "received_messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.receivedMessages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receivedMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receivedMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_StreamingPullResponse, rhs: Google_Pubsub_V1_StreamingPullResponse) -> Bool {
    if lhs.receivedMessages != rhs.receivedMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_CreateSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "subscription"),
    3: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_CreateSnapshotRequest, rhs: Google_Pubsub_V1_CreateSnapshotRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.subscription != rhs.subscription {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_UpdateSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._snapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_UpdateSnapshotRequest, rhs: Google_Pubsub_V1_UpdateSnapshotRequest) -> Bool {
    if lhs._snapshot != rhs._snapshot {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_Snapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Snapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "topic"),
    3: .standard(proto: "expire_time"),
    4: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    try { if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_Snapshot, rhs: Google_Pubsub_V1_Snapshot) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_GetSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.snapshot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshot.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_GetSnapshotRequest, rhs: Google_Pubsub_V1_GetSnapshotRequest) -> Bool {
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSnapshotsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSnapshotsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "project"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSnapshotsRequest, rhs: Google_Pubsub_V1_ListSnapshotsRequest) -> Bool {
    if lhs.project != rhs.project {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSnapshotsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSnapshotsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshots"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.snapshots) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.snapshots, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSnapshotsResponse, rhs: Google_Pubsub_V1_ListSnapshotsResponse) -> Bool {
    if lhs.snapshots != rhs.snapshots {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeleteSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.snapshot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshot.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeleteSnapshotRequest, rhs: Google_Pubsub_V1_DeleteSnapshotRequest) -> Bool {
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_SeekRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SeekRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .same(proto: "time"),
    3: .same(proto: "snapshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .time(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .time(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .snapshot(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    switch self.target {
    case .time?: try {
      guard case .time(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .snapshot?: try {
      guard case .snapshot(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_SeekRequest, rhs: Google_Pubsub_V1_SeekRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_SeekResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SeekResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_SeekResponse, rhs: Google_Pubsub_V1_SeekResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
