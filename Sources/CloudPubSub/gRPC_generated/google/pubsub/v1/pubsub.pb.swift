// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/pubsub/v1/pubsub.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A policy constraining the storage of messages published to the topic.
struct Google_Pubsub_V1_MessageStoragePolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A list of IDs of Google Cloud regions where messages that are
  /// published to the topic may be persisted in storage. Messages published by
  /// publishers running in non-allowed Google Cloud regions (or running outside
  /// of Google Cloud altogether) are routed for storage in one of the allowed
  /// regions. An empty list means that no regions are allowed, and is not a
  /// valid configuration.
  var allowedPersistenceRegions: [String] = []

  /// Optional. If true, `allowed_persistence_regions` is also used to enforce
  /// in-transit guarantees for messages. That is, Pub/Sub will fail
  /// Publish operations on this topic and subscribe operations
  /// on any subscription attached to this topic in any region that is
  /// not in `allowed_persistence_regions`.
  var enforceInTransit: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Settings for validating messages published against a schema.
struct Google_Pubsub_V1_SchemaSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the schema that messages published should be
  /// validated against. Format is `projects/{project}/schemas/{schema}`. The
  /// value of this field will be `_deleted-schema_` if the schema has been
  /// deleted.
  var schema: String = String()

  /// Optional. The encoding of messages validated against `schema`.
  var encoding: Google_Pubsub_V1_Encoding = .unspecified

  /// Optional. The minimum (inclusive) revision allowed for validating messages.
  /// If empty or not present, allow any revision to be validated against
  /// last_revision or any revision created before.
  var firstRevisionID: String = String()

  /// Optional. The maximum (inclusive) revision allowed for validating messages.
  /// If empty or not present, allow any revision to be validated against
  /// first_revision or any revision created after.
  var lastRevisionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Settings for an ingestion data source on a topic.
struct Google_Pubsub_V1_IngestionDataSourceSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only one source type can have settings set.
  var source: Google_Pubsub_V1_IngestionDataSourceSettings.OneOf_Source? = nil

  /// Optional. Amazon Kinesis Data Streams.
  var awsKinesis: Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis {
    get {
      if case .awsKinesis(let v)? = source {return v}
      return Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis()
    }
    set {source = .awsKinesis(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Only one source type can have settings set.
  enum OneOf_Source: Equatable, Sendable {
    /// Optional. Amazon Kinesis Data Streams.
    case awsKinesis(Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis)

  }

  /// Ingestion settings for Amazon Kinesis Data Streams.
  struct AwsKinesis: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. An output-only field that indicates the state of the Kinesis
    /// ingestion source.
    var state: Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis.State = .unspecified

    /// Required. The Kinesis stream ARN to ingest data from.
    var streamArn: String = String()

    /// Required. The Kinesis consumer ARN to used for ingestion in Enhanced
    /// Fan-Out mode. The consumer must be already created and ready to be used.
    var consumerArn: String = String()

    /// Required. AWS role ARN to be used for Federated Identity authentication
    /// with Kinesis. Check the Pub/Sub docs for how to set up this role and the
    /// required permissions that need to be attached to it.
    var awsRoleArn: String = String()

    /// Required. The GCP service account to be used for Federated Identity
    /// authentication with Kinesis (via a `AssumeRoleWithWebIdentity` call for
    /// the provided role). The `aws_role_arn` must be set up with
    /// `accounts.google.com:sub` equals to this service account number.
    var gcpServiceAccount: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Possible states for ingestion from Amazon Kinesis Data Streams.
    enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int

      /// Default value. This value is unused.
      case unspecified // = 0

      /// Ingestion is active.
      case active // = 1

      /// Permission denied encountered while consuming data from Kinesis.
      /// This can happen if:
      ///   - The provided `aws_role_arn` does not exist or does not have the
      ///     appropriate permissions attached.
      ///   - The provided `aws_role_arn` is not set up properly for Identity
      ///     Federation using `gcp_service_account`.
      ///   - The Pub/Sub SA is not granted the
      ///     `iam.serviceAccounts.getOpenIdToken` permission on
      ///     `gcp_service_account`.
      case kinesisPermissionDenied // = 2

      /// Permission denied encountered while publishing to the topic. This can
      /// happen if the Pub/Sub SA has not been granted the [appropriate publish
      /// permissions](https://cloud.google.com/pubsub/docs/access-control#pubsub.publisher)
      case publishPermissionDenied // = 3

      /// The Kinesis stream does not exist.
      case streamNotFound // = 4

      /// The Kinesis consumer does not exist.
      case consumerNotFound // = 5
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .active
        case 2: self = .kinesisPermissionDenied
        case 3: self = .publishPermissionDenied
        case 4: self = .streamNotFound
        case 5: self = .consumerNotFound
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .active: return 1
        case .kinesisPermissionDenied: return 2
        case .publishPermissionDenied: return 3
        case .streamNotFound: return 4
        case .consumerNotFound: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis.State] = [
        .unspecified,
        .active,
        .kinesisPermissionDenied,
        .publishPermissionDenied,
        .streamNotFound,
        .consumerNotFound,
      ]

    }

    init() {}
  }

  init() {}
}

/// A topic resource.
struct Google_Pubsub_V1_Topic: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic. It must have the format
  /// `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
  /// and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
  /// underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
  /// signs (`%`). It must be between 3 and 255 characters in length, and it
  /// must not start with `"goog"`.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional. See [Creating and managing labels]
  /// (https://cloud.google.com/pubsub/docs/labels).
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Optional. Policy constraining the set of Google Cloud Platform regions
  /// where messages published to the topic may be stored. If not present, then
  /// no constraints are in effect.
  var messageStoragePolicy: Google_Pubsub_V1_MessageStoragePolicy {
    get {return _storage._messageStoragePolicy ?? Google_Pubsub_V1_MessageStoragePolicy()}
    set {_uniqueStorage()._messageStoragePolicy = newValue}
  }
  /// Returns true if `messageStoragePolicy` has been explicitly set.
  var hasMessageStoragePolicy: Bool {return _storage._messageStoragePolicy != nil}
  /// Clears the value of `messageStoragePolicy`. Subsequent reads from it will return its default value.
  mutating func clearMessageStoragePolicy() {_uniqueStorage()._messageStoragePolicy = nil}

  /// Optional. The resource name of the Cloud KMS CryptoKey to be used to
  /// protect access to messages published on this topic.
  ///
  /// The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
  var kmsKeyName: String {
    get {return _storage._kmsKeyName}
    set {_uniqueStorage()._kmsKeyName = newValue}
  }

  /// Optional. Settings for validating messages published against a schema.
  var schemaSettings: Google_Pubsub_V1_SchemaSettings {
    get {return _storage._schemaSettings ?? Google_Pubsub_V1_SchemaSettings()}
    set {_uniqueStorage()._schemaSettings = newValue}
  }
  /// Returns true if `schemaSettings` has been explicitly set.
  var hasSchemaSettings: Bool {return _storage._schemaSettings != nil}
  /// Clears the value of `schemaSettings`. Subsequent reads from it will return its default value.
  mutating func clearSchemaSettings() {_uniqueStorage()._schemaSettings = nil}

  /// Optional. Reserved for future use. This field is set only in responses from
  /// the server; it is ignored if it is set in any requests.
  var satisfiesPzs: Bool {
    get {return _storage._satisfiesPzs}
    set {_uniqueStorage()._satisfiesPzs = newValue}
  }

  /// Optional. Indicates the minimum duration to retain a message after it is
  /// published to the topic. If this field is set, messages published to the
  /// topic in the last `message_retention_duration` are always available to
  /// subscribers. For instance, it allows any attached subscription to [seek to
  /// a
  /// timestamp](https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)
  /// that is up to `message_retention_duration` in the past. If this field is
  /// not set, message retention is controlled by settings on individual
  /// subscriptions. Cannot be more than 31 days or less than 10 minutes.
  var messageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._messageRetentionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._messageRetentionDuration = newValue}
  }
  /// Returns true if `messageRetentionDuration` has been explicitly set.
  var hasMessageRetentionDuration: Bool {return _storage._messageRetentionDuration != nil}
  /// Clears the value of `messageRetentionDuration`. Subsequent reads from it will return its default value.
  mutating func clearMessageRetentionDuration() {_uniqueStorage()._messageRetentionDuration = nil}

  /// Output only. An output-only field indicating the state of the topic.
  var state: Google_Pubsub_V1_Topic.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Optional. Settings for ingestion from a data source into this topic.
  var ingestionDataSourceSettings: Google_Pubsub_V1_IngestionDataSourceSettings {
    get {return _storage._ingestionDataSourceSettings ?? Google_Pubsub_V1_IngestionDataSourceSettings()}
    set {_uniqueStorage()._ingestionDataSourceSettings = newValue}
  }
  /// Returns true if `ingestionDataSourceSettings` has been explicitly set.
  var hasIngestionDataSourceSettings: Bool {return _storage._ingestionDataSourceSettings != nil}
  /// Clears the value of `ingestionDataSourceSettings`. Subsequent reads from it will return its default value.
  mutating func clearIngestionDataSourceSettings() {_uniqueStorage()._ingestionDataSourceSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The state of the topic.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Default value. This value is unused.
    case unspecified // = 0

    /// The topic does not have any persistent errors.
    case active // = 1

    /// Ingestion from the data source has encountered a permanent error.
    /// See the more detailed error state in the corresponding ingestion
    /// source configuration.
    case ingestionResourceError // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .ingestionResourceError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .ingestionResourceError: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Pubsub_V1_Topic.State] = [
      .unspecified,
      .active,
      .ingestionResourceError,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A message that is published by publishers and consumed by subscribers. The
/// message must contain either a non-empty data field or at least one attribute.
/// Note that client libraries represent this object differently
/// depending on the language. See the corresponding [client library
/// documentation](https://cloud.google.com/pubsub/docs/reference/libraries) for
/// more information. See [quotas and limits]
/// (https://cloud.google.com/pubsub/quotas) for more information about message
/// limits.
struct Google_Pubsub_V1_PubsubMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The message data field. If this field is empty, the message must
  /// contain at least one attribute.
  var data: Data = Data()

  /// Optional. Attributes for this message. If this field is empty, the message
  /// must contain non-empty data. This can be used to filter messages on the
  /// subscription.
  var attributes: Dictionary<String,String> = [:]

  /// ID of this message, assigned by the server when the message is published.
  /// Guaranteed to be unique within the topic. This value may be read by a
  /// subscriber that receives a `PubsubMessage` via a `Pull` call or a push
  /// delivery. It must not be populated by the publisher in a `Publish` call.
  var messageID: String = String()

  /// The time at which the message was published, populated by the server when
  /// it receives the `Publish` call. It must not be populated by the
  /// publisher in a `Publish` call.
  var publishTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _publishTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_publishTime = newValue}
  }
  /// Returns true if `publishTime` has been explicitly set.
  var hasPublishTime: Bool {return self._publishTime != nil}
  /// Clears the value of `publishTime`. Subsequent reads from it will return its default value.
  mutating func clearPublishTime() {self._publishTime = nil}

  /// Optional. If non-empty, identifies related messages for which publish order
  /// should be respected. If a `Subscription` has `enable_message_ordering` set
  /// to `true`, messages published with the same non-empty `ordering_key` value
  /// will be delivered to subscribers in the order in which they are received by
  /// the Pub/Sub system. All `PubsubMessage`s published in a given
  /// `PublishRequest` must specify the same `ordering_key` value. For more
  /// information, see [ordering
  /// messages](https://cloud.google.com/pubsub/docs/ordering).
  var orderingKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publishTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request for the GetTopic method.
struct Google_Pubsub_V1_GetTopicRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic to get.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the UpdateTopic method.
struct Google_Pubsub_V1_UpdateTopicRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated topic object.
  var topic: Google_Pubsub_V1_Topic {
    get {return _topic ?? Google_Pubsub_V1_Topic()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {self._topic = nil}

  /// Required. Indicates which fields in the provided topic to update. Must be
  /// specified and non-empty. Note that if `update_mask` contains
  /// "message_storage_policy" but the `message_storage_policy` is not set in
  /// the `topic` provided above, then the updated value is determined by the
  /// policy configured at the project or organization level.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topic: Google_Pubsub_V1_Topic? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for the Publish method.
struct Google_Pubsub_V1_PublishRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The messages in the request will be published on this topic.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  /// Required. The messages to publish.
  var messages: [Google_Pubsub_V1_PubsubMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `Publish` method.
struct Google_Pubsub_V1_PublishResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The server-assigned ID of each published message, in the same
  /// order as the messages in the request. IDs are guaranteed to be unique
  /// within the topic.
  var messageIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListTopics` method.
struct Google_Pubsub_V1_ListTopicsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which to list topics.
  /// Format is `projects/{project-id}`.
  var project: String = String()

  /// Optional. Maximum number of topics to return.
  var pageSize: Int32 = 0

  /// Optional. The value returned by the last `ListTopicsResponse`; indicates
  /// that this is a continuation of a prior `ListTopics` call, and that the
  /// system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListTopics` method.
struct Google_Pubsub_V1_ListTopicsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The resulting topics.
  var topics: [Google_Pubsub_V1_Topic] = []

  /// Optional. If not empty, indicates that there may be more topics that match
  /// the request; this value should be passed in a new `ListTopicsRequest`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListTopicSubscriptions` method.
struct Google_Pubsub_V1_ListTopicSubscriptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic that subscriptions are attached to.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  /// Optional. Maximum number of subscription names to return.
  var pageSize: Int32 = 0

  /// Optional. The value returned by the last `ListTopicSubscriptionsResponse`;
  /// indicates that this is a continuation of a prior `ListTopicSubscriptions`
  /// call, and that the system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListTopicSubscriptions` method.
struct Google_Pubsub_V1_ListTopicSubscriptionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The names of subscriptions attached to the topic specified in the
  /// request.
  var subscriptions: [String] = []

  /// Optional. If not empty, indicates that there may be more subscriptions that
  /// match the request; this value should be passed in a new
  /// `ListTopicSubscriptionsRequest` to get more subscriptions.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListTopicSnapshots` method.
struct Google_Pubsub_V1_ListTopicSnapshotsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the topic that snapshots are attached to.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  /// Optional. Maximum number of snapshot names to return.
  var pageSize: Int32 = 0

  /// Optional. The value returned by the last `ListTopicSnapshotsResponse`;
  /// indicates that this is a continuation of a prior `ListTopicSnapshots` call,
  /// and that the system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListTopicSnapshots` method.
struct Google_Pubsub_V1_ListTopicSnapshotsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The names of the snapshots that match the request.
  var snapshots: [String] = []

  /// Optional. If not empty, indicates that there may be more snapshots that
  /// match the request; this value should be passed in a new
  /// `ListTopicSnapshotsRequest` to get more snapshots.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `DeleteTopic` method.
struct Google_Pubsub_V1_DeleteTopicRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the topic to delete.
  /// Format is `projects/{project}/topics/{topic}`.
  var topic: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the DetachSubscription method.
struct Google_Pubsub_V1_DetachSubscriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription to detach.
  /// Format is `projects/{project}/subscriptions/{subscription}`.
  var subscription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the DetachSubscription method.
/// Reserved for future use.
struct Google_Pubsub_V1_DetachSubscriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A subscription resource. If none of `push_config`, `bigquery_config`, or
/// `cloud_storage_config` is set, then the subscriber will pull and ack messages
/// using API methods. At most one of these fields may be set.
struct Google_Pubsub_V1_Subscription: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription. It must have the format
  /// `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
  /// start with a letter, and contain only letters (`[A-Za-z]`), numbers
  /// (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
  /// plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
  /// in length, and it must not start with `"goog"`.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. The name of the topic from which this subscription is receiving
  /// messages. Format is `projects/{project}/topics/{topic}`. The value of this
  /// field will be `_deleted-topic_` if the topic has been deleted.
  var topic: String {
    get {return _storage._topic}
    set {_uniqueStorage()._topic = newValue}
  }

  /// Optional. If push delivery is used with this subscription, this field is
  /// used to configure it.
  var pushConfig: Google_Pubsub_V1_PushConfig {
    get {return _storage._pushConfig ?? Google_Pubsub_V1_PushConfig()}
    set {_uniqueStorage()._pushConfig = newValue}
  }
  /// Returns true if `pushConfig` has been explicitly set.
  var hasPushConfig: Bool {return _storage._pushConfig != nil}
  /// Clears the value of `pushConfig`. Subsequent reads from it will return its default value.
  mutating func clearPushConfig() {_uniqueStorage()._pushConfig = nil}

  /// Optional. If delivery to BigQuery is used with this subscription, this
  /// field is used to configure it.
  var bigqueryConfig: Google_Pubsub_V1_BigQueryConfig {
    get {return _storage._bigqueryConfig ?? Google_Pubsub_V1_BigQueryConfig()}
    set {_uniqueStorage()._bigqueryConfig = newValue}
  }
  /// Returns true if `bigqueryConfig` has been explicitly set.
  var hasBigqueryConfig: Bool {return _storage._bigqueryConfig != nil}
  /// Clears the value of `bigqueryConfig`. Subsequent reads from it will return its default value.
  mutating func clearBigqueryConfig() {_uniqueStorage()._bigqueryConfig = nil}

  /// Optional. If delivery to Google Cloud Storage is used with this
  /// subscription, this field is used to configure it.
  var cloudStorageConfig: Google_Pubsub_V1_CloudStorageConfig {
    get {return _storage._cloudStorageConfig ?? Google_Pubsub_V1_CloudStorageConfig()}
    set {_uniqueStorage()._cloudStorageConfig = newValue}
  }
  /// Returns true if `cloudStorageConfig` has been explicitly set.
  var hasCloudStorageConfig: Bool {return _storage._cloudStorageConfig != nil}
  /// Clears the value of `cloudStorageConfig`. Subsequent reads from it will return its default value.
  mutating func clearCloudStorageConfig() {_uniqueStorage()._cloudStorageConfig = nil}

  /// Optional. The approximate amount of time (on a best-effort basis) Pub/Sub
  /// waits for the subscriber to acknowledge receipt before resending the
  /// message. In the interval after the message is delivered and before it is
  /// acknowledged, it is considered to be _outstanding_. During that time
  /// period, the message will not be redelivered (on a best-effort basis).
  ///
  /// For pull subscriptions, this value is used as the initial value for the ack
  /// deadline. To override this value for a given message, call
  /// `ModifyAckDeadline` with the corresponding `ack_id` if using
  /// non-streaming pull or send the `ack_id` in a
  /// `StreamingModifyAckDeadlineRequest` if using streaming pull.
  /// The minimum custom deadline you can specify is 10 seconds.
  /// The maximum custom deadline you can specify is 600 seconds (10 minutes).
  /// If this parameter is 0, a default value of 10 seconds is used.
  ///
  /// For push delivery, this value is also used to set the request timeout for
  /// the call to the push endpoint.
  ///
  /// If the subscriber never acknowledges the message, the Pub/Sub
  /// system will eventually redeliver the message.
  var ackDeadlineSeconds: Int32 {
    get {return _storage._ackDeadlineSeconds}
    set {_uniqueStorage()._ackDeadlineSeconds = newValue}
  }

  /// Optional. Indicates whether to retain acknowledged messages. If true, then
  /// messages are not expunged from the subscription's backlog, even if they are
  /// acknowledged, until they fall out of the `message_retention_duration`
  /// window. This must be true if you would like to [`Seek` to a timestamp]
  /// (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time) in
  /// the past to replay previously-acknowledged messages.
  var retainAckedMessages: Bool {
    get {return _storage._retainAckedMessages}
    set {_uniqueStorage()._retainAckedMessages = newValue}
  }

  /// Optional. How long to retain unacknowledged messages in the subscription's
  /// backlog, from the moment a message is published. If `retain_acked_messages`
  /// is true, then this also configures the retention of acknowledged messages,
  /// and thus configures how far back in time a `Seek` can be done. Defaults to
  /// 7 days. Cannot be more than 7 days or less than 10 minutes.
  var messageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._messageRetentionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._messageRetentionDuration = newValue}
  }
  /// Returns true if `messageRetentionDuration` has been explicitly set.
  var hasMessageRetentionDuration: Bool {return _storage._messageRetentionDuration != nil}
  /// Clears the value of `messageRetentionDuration`. Subsequent reads from it will return its default value.
  mutating func clearMessageRetentionDuration() {_uniqueStorage()._messageRetentionDuration = nil}

  /// Optional. See [Creating and managing
  /// labels](https://cloud.google.com/pubsub/docs/labels).
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Optional. If true, messages published with the same `ordering_key` in
  /// `PubsubMessage` will be delivered to the subscribers in the order in which
  /// they are received by the Pub/Sub system. Otherwise, they may be delivered
  /// in any order.
  var enableMessageOrdering: Bool {
    get {return _storage._enableMessageOrdering}
    set {_uniqueStorage()._enableMessageOrdering = newValue}
  }

  /// Optional. A policy that specifies the conditions for this subscription's
  /// expiration. A subscription is considered active as long as any connected
  /// subscriber is successfully consuming messages from the subscription or is
  /// issuing operations on the subscription. If `expiration_policy` is not set,
  /// a *default policy* with `ttl` of 31 days will be used. The minimum allowed
  /// value for `expiration_policy.ttl` is 1 day. If `expiration_policy` is set,
  /// but `expiration_policy.ttl` is not set, the subscription never expires.
  var expirationPolicy: Google_Pubsub_V1_ExpirationPolicy {
    get {return _storage._expirationPolicy ?? Google_Pubsub_V1_ExpirationPolicy()}
    set {_uniqueStorage()._expirationPolicy = newValue}
  }
  /// Returns true if `expirationPolicy` has been explicitly set.
  var hasExpirationPolicy: Bool {return _storage._expirationPolicy != nil}
  /// Clears the value of `expirationPolicy`. Subsequent reads from it will return its default value.
  mutating func clearExpirationPolicy() {_uniqueStorage()._expirationPolicy = nil}

  /// Optional. An expression written in the Pub/Sub [filter
  /// language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
  /// then only `PubsubMessage`s whose `attributes` field matches the filter are
  /// delivered on this subscription. If empty, then no messages are filtered
  /// out.
  var filter: String {
    get {return _storage._filter}
    set {_uniqueStorage()._filter = newValue}
  }

  /// Optional. A policy that specifies the conditions for dead lettering
  /// messages in this subscription. If dead_letter_policy is not set, dead
  /// lettering is disabled.
  ///
  /// The Pub/Sub service account associated with this subscriptions's
  /// parent project (i.e.,
  /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
  /// permission to Acknowledge() messages on this subscription.
  var deadLetterPolicy: Google_Pubsub_V1_DeadLetterPolicy {
    get {return _storage._deadLetterPolicy ?? Google_Pubsub_V1_DeadLetterPolicy()}
    set {_uniqueStorage()._deadLetterPolicy = newValue}
  }
  /// Returns true if `deadLetterPolicy` has been explicitly set.
  var hasDeadLetterPolicy: Bool {return _storage._deadLetterPolicy != nil}
  /// Clears the value of `deadLetterPolicy`. Subsequent reads from it will return its default value.
  mutating func clearDeadLetterPolicy() {_uniqueStorage()._deadLetterPolicy = nil}

  /// Optional. A policy that specifies how Pub/Sub retries message delivery for
  /// this subscription.
  ///
  /// If not set, the default retry policy is applied. This generally implies
  /// that messages will be retried as soon as possible for healthy subscribers.
  /// RetryPolicy will be triggered on NACKs or acknowledgement deadline
  /// exceeded events for a given message.
  var retryPolicy: Google_Pubsub_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Google_Pubsub_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Optional. Indicates whether the subscription is detached from its topic.
  /// Detached subscriptions don't receive messages from their topic and don't
  /// retain any backlog. `Pull` and `StreamingPull` requests will return
  /// FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
  /// the endpoint will not be made.
  var detached: Bool {
    get {return _storage._detached}
    set {_uniqueStorage()._detached = newValue}
  }

  /// Optional. If true, Pub/Sub provides the following guarantees for the
  /// delivery of a message with a given value of `message_id` on this
  /// subscription:
  ///
  /// * The message sent to a subscriber is guaranteed not to be resent
  /// before the message's acknowledgement deadline expires.
  /// * An acknowledged message will not be resent to a subscriber.
  ///
  /// Note that subscribers may still receive multiple copies of a message
  /// when `enable_exactly_once_delivery` is true if the message was published
  /// multiple times by a publisher client. These copies are  considered distinct
  /// by Pub/Sub and have distinct `message_id` values.
  var enableExactlyOnceDelivery: Bool {
    get {return _storage._enableExactlyOnceDelivery}
    set {_uniqueStorage()._enableExactlyOnceDelivery = newValue}
  }

  /// Output only. Indicates the minimum duration for which a message is retained
  /// after it is published to the subscription's topic. If this field is set,
  /// messages published to the subscription's topic in the last
  /// `topic_message_retention_duration` are always available to subscribers. See
  /// the `message_retention_duration` field in `Topic`. This field is set only
  /// in responses from the server; it is ignored if it is set in any requests.
  var topicMessageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._topicMessageRetentionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._topicMessageRetentionDuration = newValue}
  }
  /// Returns true if `topicMessageRetentionDuration` has been explicitly set.
  var hasTopicMessageRetentionDuration: Bool {return _storage._topicMessageRetentionDuration != nil}
  /// Clears the value of `topicMessageRetentionDuration`. Subsequent reads from it will return its default value.
  mutating func clearTopicMessageRetentionDuration() {_uniqueStorage()._topicMessageRetentionDuration = nil}

  /// Output only. An output-only field indicating whether or not the
  /// subscription can receive messages.
  var state: Google_Pubsub_V1_Subscription.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible states for a subscription.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Default value. This value is unused.
    case unspecified // = 0

    /// The subscription can actively receive messages
    case active // = 1

    /// The subscription cannot receive messages because of an error with the
    /// resource to which it pushes messages. See the more detailed error state
    /// in the corresponding configuration.
    case resourceError // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .resourceError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .resourceError: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Pubsub_V1_Subscription.State] = [
      .unspecified,
      .active,
      .resourceError,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A policy that specifies how Pub/Sub retries message delivery.
///
/// Retry delay will be exponential based on provided minimum and maximum
/// backoffs. https://en.wikipedia.org/wiki/Exponential_backoff.
///
/// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded
/// events for a given message.
///
/// Retry Policy is implemented on a best effort basis. At times, the delay
/// between consecutive deliveries may not match the configuration. That is,
/// delay can be more or less than configured backoff.
struct Google_Pubsub_V1_RetryPolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The minimum delay between consecutive deliveries of a given
  /// message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
  var minimumBackoff: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minimumBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minimumBackoff = newValue}
  }
  /// Returns true if `minimumBackoff` has been explicitly set.
  var hasMinimumBackoff: Bool {return self._minimumBackoff != nil}
  /// Clears the value of `minimumBackoff`. Subsequent reads from it will return its default value.
  mutating func clearMinimumBackoff() {self._minimumBackoff = nil}

  /// Optional. The maximum delay between consecutive deliveries of a given
  /// message. Value should be between 0 and 600 seconds. Defaults to 600
  /// seconds.
  var maximumBackoff: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maximumBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maximumBackoff = newValue}
  }
  /// Returns true if `maximumBackoff` has been explicitly set.
  var hasMaximumBackoff: Bool {return self._maximumBackoff != nil}
  /// Clears the value of `maximumBackoff`. Subsequent reads from it will return its default value.
  mutating func clearMaximumBackoff() {self._maximumBackoff = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minimumBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maximumBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Dead lettering is done on a best effort basis. The same message might be
/// dead lettered multiple times.
///
/// If validation on any of the fields fails at subscription creation/updation,
/// the create/update subscription request will fail.
struct Google_Pubsub_V1_DeadLetterPolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The name of the topic to which dead letter messages should be
  /// published. Format is `projects/{project}/topics/{topic}`.The Pub/Sub
  /// service account associated with the enclosing subscription's parent project
  /// (i.e., service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must
  /// have permission to Publish() to this topic.
  ///
  /// The operation will fail if the topic does not exist.
  /// Users should ensure that there is a subscription attached to this topic
  /// since messages published to a topic with no subscriptions are lost.
  var deadLetterTopic: String = String()

  /// Optional. The maximum number of delivery attempts for any message. The
  /// value must be between 5 and 100.
  ///
  /// The number of delivery attempts is defined as 1 + (the sum of number of
  /// NACKs and number of times the acknowledgement deadline has been exceeded
  /// for the message).
  ///
  /// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
  /// client libraries may automatically extend ack_deadlines.
  ///
  /// This field will be honored on a best effort basis.
  ///
  /// If this parameter is 0, a default value of 5 is used.
  var maxDeliveryAttempts: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A policy that specifies the conditions for resource expiration (i.e.,
/// automatic resource deletion).
struct Google_Pubsub_V1_ExpirationPolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Specifies the "time-to-live" duration for an associated resource.
  /// The resource expires if it is not active for a period of `ttl`. The
  /// definition of "activity" depends on the type of the associated resource.
  /// The minimum and maximum allowed values for `ttl` depend on the type of the
  /// associated resource, as well. If `ttl` is not set, the associated resource
  /// never expires.
  var ttl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_ttl = newValue}
  }
  /// Returns true if `ttl` has been explicitly set.
  var hasTtl: Bool {return self._ttl != nil}
  /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
  mutating func clearTtl() {self._ttl = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Configuration for a push delivery endpoint.
struct Google_Pubsub_V1_PushConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A URL locating the endpoint to which messages should be pushed.
  /// For example, a Webhook endpoint might use `https://example.com/push`.
  var pushEndpoint: String = String()

  /// Optional. Endpoint configuration attributes that can be used to control
  /// different aspects of the message delivery.
  ///
  /// The only currently supported attribute is `x-goog-version`, which you can
  /// use to change the format of the pushed message. This attribute
  /// indicates the version of the data expected by the endpoint. This
  /// controls the shape of the pushed message (i.e., its fields and metadata).
  ///
  /// If not present during the `CreateSubscription` call, it will default to
  /// the version of the Pub/Sub API used to make such call. If not present in a
  /// `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
  /// calls will always return a valid version, even if the subscription was
  /// created without this attribute.
  ///
  /// The only supported values for the `x-goog-version` attribute are:
  ///
  /// * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
  /// * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.
  ///
  /// For example:
  /// `attributes { "x-goog-version": "v1" }`
  var attributes: Dictionary<String,String> = [:]

  /// An authentication method used by push endpoints to verify the source of
  /// push requests. This can be used with push endpoints that are private by
  /// default to allow requests only from the Pub/Sub system, for example.
  /// This field is optional and should be set only by users interested in
  /// authenticated push.
  var authenticationMethod: Google_Pubsub_V1_PushConfig.OneOf_AuthenticationMethod? = nil

  /// Optional. If specified, Pub/Sub will generate and attach an OIDC JWT
  /// token as an `Authorization` header in the HTTP request for every pushed
  /// message.
  var oidcToken: Google_Pubsub_V1_PushConfig.OidcToken {
    get {
      if case .oidcToken(let v)? = authenticationMethod {return v}
      return Google_Pubsub_V1_PushConfig.OidcToken()
    }
    set {authenticationMethod = .oidcToken(newValue)}
  }

  /// The format of the delivered message to the push endpoint is defined by
  /// the chosen wrapper. When unset, `PubsubWrapper` is used.
  var wrapper: Google_Pubsub_V1_PushConfig.OneOf_Wrapper? = nil

  /// Optional. When set, the payload to the push endpoint is in the form of
  /// the JSON representation of a PubsubMessage
  /// (https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage).
  var pubsubWrapper: Google_Pubsub_V1_PushConfig.PubsubWrapper {
    get {
      if case .pubsubWrapper(let v)? = wrapper {return v}
      return Google_Pubsub_V1_PushConfig.PubsubWrapper()
    }
    set {wrapper = .pubsubWrapper(newValue)}
  }

  /// Optional. When set, the payload to the push endpoint is not wrapped.
  var noWrapper: Google_Pubsub_V1_PushConfig.NoWrapper {
    get {
      if case .noWrapper(let v)? = wrapper {return v}
      return Google_Pubsub_V1_PushConfig.NoWrapper()
    }
    set {wrapper = .noWrapper(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An authentication method used by push endpoints to verify the source of
  /// push requests. This can be used with push endpoints that are private by
  /// default to allow requests only from the Pub/Sub system, for example.
  /// This field is optional and should be set only by users interested in
  /// authenticated push.
  enum OneOf_AuthenticationMethod: Equatable, Sendable {
    /// Optional. If specified, Pub/Sub will generate and attach an OIDC JWT
    /// token as an `Authorization` header in the HTTP request for every pushed
    /// message.
    case oidcToken(Google_Pubsub_V1_PushConfig.OidcToken)

  }

  /// The format of the delivered message to the push endpoint is defined by
  /// the chosen wrapper. When unset, `PubsubWrapper` is used.
  enum OneOf_Wrapper: Equatable, Sendable {
    /// Optional. When set, the payload to the push endpoint is in the form of
    /// the JSON representation of a PubsubMessage
    /// (https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage).
    case pubsubWrapper(Google_Pubsub_V1_PushConfig.PubsubWrapper)
    /// Optional. When set, the payload to the push endpoint is not wrapped.
    case noWrapper(Google_Pubsub_V1_PushConfig.NoWrapper)

  }

  /// Contains information needed for generating an
  /// [OpenID Connect
  /// token](https://developers.google.com/identity/protocols/OpenIDConnect).
  struct OidcToken: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. [Service account
    /// email](https://cloud.google.com/iam/docs/service-accounts)
    /// used for generating the OIDC token. For more information
    /// on setting up authentication, see
    /// [Push subscriptions](https://cloud.google.com/pubsub/docs/push).
    var serviceAccountEmail: String = String()

    /// Optional. Audience to be used when generating OIDC token. The audience
    /// claim identifies the recipients that the JWT is intended for. The
    /// audience value is a single case-sensitive string. Having multiple values
    /// (array) for the audience field is not supported. More info about the OIDC
    /// JWT token audience here:
    /// https://tools.ietf.org/html/rfc7519#section-4.1.3 Note: if not specified,
    /// the Push endpoint URL will be used.
    var audience: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The payload to the push endpoint is in the form of the JSON representation
  /// of a PubsubMessage
  /// (https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage).
  struct PubsubWrapper: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Sets the `data` field as the HTTP body for delivery.
  struct NoWrapper: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. When true, writes the Pub/Sub message metadata to
    /// `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
    /// Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
    var writeMetadata: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Configuration for a BigQuery subscription.
struct Google_Pubsub_V1_BigQueryConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The name of the table to which to write data, of the form
  /// {projectId}.{datasetId}.{tableId}
  var table: String = String()

  /// Optional. When true, use the topic's schema as the columns to write to in
  /// BigQuery, if it exists. `use_topic_schema` and `use_table_schema` cannot be
  /// enabled at the same time.
  var useTopicSchema: Bool = false

  /// Optional. When true, write the subscription name, message_id, publish_time,
  /// attributes, and ordering_key to additional columns in the table. The
  /// subscription name, message_id, and publish_time fields are put in their own
  /// columns while all other message properties (other than data) are written to
  /// a JSON object in the attributes column.
  var writeMetadata: Bool = false

  /// Optional. When true and use_topic_schema is true, any fields that are a
  /// part of the topic schema that are not part of the BigQuery table schema are
  /// dropped when writing to BigQuery. Otherwise, the schemas must be kept in
  /// sync and any messages with extra fields are not written and remain in the
  /// subscription's backlog.
  var dropUnknownFields: Bool = false

  /// Output only. An output-only field that indicates whether or not the
  /// subscription can receive messages.
  var state: Google_Pubsub_V1_BigQueryConfig.State = .unspecified

  /// Optional. When true, use the BigQuery table's schema as the columns to
  /// write to in BigQuery. `use_table_schema` and `use_topic_schema` cannot be
  /// enabled at the same time.
  var useTableSchema: Bool = false

  /// Optional. The service account to use to write to BigQuery. The subscription
  /// creator or updater that specifies this field must have
  /// `iam.serviceAccounts.actAs` permission on the service account. If not
  /// specified, the Pub/Sub [service
  /// agent](https://cloud.google.com/iam/docs/service-agents),
  /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
  var serviceAccountEmail: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible states for a BigQuery subscription.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Default value. This value is unused.
    case unspecified // = 0

    /// The subscription can actively send messages to BigQuery
    case active // = 1

    /// Cannot write to the BigQuery table because of permission denied errors.
    /// This can happen if
    /// - Pub/Sub SA has not been granted the [appropriate BigQuery IAM
    /// permissions](https://cloud.google.com/pubsub/docs/create-subscription#assign_bigquery_service_account)
    /// - bigquery.googleapis.com API is not enabled for the project
    /// ([instructions](https://cloud.google.com/service-usage/docs/enable-disable))
    case permissionDenied // = 2

    /// Cannot write to the BigQuery table because it does not exist.
    case notFound // = 3

    /// Cannot write to the BigQuery table due to a schema mismatch.
    case schemaMismatch // = 4

    /// Cannot write to the destination because enforce_in_transit is set to true
    /// and the destination locations are not in the allowed regions.
    case inTransitLocationRestriction // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .permissionDenied
      case 3: self = .notFound
      case 4: self = .schemaMismatch
      case 5: self = .inTransitLocationRestriction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .permissionDenied: return 2
      case .notFound: return 3
      case .schemaMismatch: return 4
      case .inTransitLocationRestriction: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Pubsub_V1_BigQueryConfig.State] = [
      .unspecified,
      .active,
      .permissionDenied,
      .notFound,
      .schemaMismatch,
      .inTransitLocationRestriction,
    ]

  }

  init() {}
}

/// Configuration for a Cloud Storage subscription.
struct Google_Pubsub_V1_CloudStorageConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. User-provided name for the Cloud Storage bucket.
  /// The bucket must be created by the user. The bucket name must be without
  /// any prefix like "gs://". See the [bucket naming
  /// requirements] (https://cloud.google.com/storage/docs/buckets#naming).
  var bucket: String = String()

  /// Optional. User-provided prefix for Cloud Storage filename. See the [object
  /// naming requirements](https://cloud.google.com/storage/docs/objects#naming).
  var filenamePrefix: String = String()

  /// Optional. User-provided suffix for Cloud Storage filename. See the [object
  /// naming requirements](https://cloud.google.com/storage/docs/objects#naming).
  /// Must not end in "/".
  var filenameSuffix: String = String()

  /// Optional. User-provided format string specifying how to represent datetimes
  /// in Cloud Storage filenames. See the [datetime format
  /// guidance](https://cloud.google.com/pubsub/docs/create-cloudstorage-subscription#file_names).
  var filenameDatetimeFormat: String = String()

  /// Defaults to text format.
  var outputFormat: Google_Pubsub_V1_CloudStorageConfig.OneOf_OutputFormat? = nil

  /// Optional. If set, message data will be written to Cloud Storage in text
  /// format.
  var textConfig: Google_Pubsub_V1_CloudStorageConfig.TextConfig {
    get {
      if case .textConfig(let v)? = outputFormat {return v}
      return Google_Pubsub_V1_CloudStorageConfig.TextConfig()
    }
    set {outputFormat = .textConfig(newValue)}
  }

  /// Optional. If set, message data will be written to Cloud Storage in Avro
  /// format.
  var avroConfig: Google_Pubsub_V1_CloudStorageConfig.AvroConfig {
    get {
      if case .avroConfig(let v)? = outputFormat {return v}
      return Google_Pubsub_V1_CloudStorageConfig.AvroConfig()
    }
    set {outputFormat = .avroConfig(newValue)}
  }

  /// Optional. The maximum duration that can elapse before a new Cloud Storage
  /// file is created. Min 1 minute, max 10 minutes, default 5 minutes. May not
  /// exceed the subscription's acknowledgement deadline.
  var maxDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxDuration = newValue}
  }
  /// Returns true if `maxDuration` has been explicitly set.
  var hasMaxDuration: Bool {return self._maxDuration != nil}
  /// Clears the value of `maxDuration`. Subsequent reads from it will return its default value.
  mutating func clearMaxDuration() {self._maxDuration = nil}

  /// Optional. The maximum bytes that can be written to a Cloud Storage file
  /// before a new file is created. Min 1 KB, max 10 GiB. The max_bytes limit may
  /// be exceeded in cases where messages are larger than the limit.
  var maxBytes: Int64 = 0

  /// Optional. The maximum number of messages that can be written to a Cloud
  /// Storage file before a new file is created. Min 1000 messages.
  var maxMessages: Int64 = 0

  /// Output only. An output-only field that indicates whether or not the
  /// subscription can receive messages.
  var state: Google_Pubsub_V1_CloudStorageConfig.State = .unspecified

  /// Optional. The service account to use to write to Cloud Storage. The
  /// subscription creator or updater that specifies this field must have
  /// `iam.serviceAccounts.actAs` permission on the service account. If not
  /// specified, the Pub/Sub
  /// [service agent](https://cloud.google.com/iam/docs/service-agents),
  /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
  var serviceAccountEmail: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defaults to text format.
  enum OneOf_OutputFormat: Equatable, Sendable {
    /// Optional. If set, message data will be written to Cloud Storage in text
    /// format.
    case textConfig(Google_Pubsub_V1_CloudStorageConfig.TextConfig)
    /// Optional. If set, message data will be written to Cloud Storage in Avro
    /// format.
    case avroConfig(Google_Pubsub_V1_CloudStorageConfig.AvroConfig)

  }

  /// Possible states for a Cloud Storage subscription.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Default value. This value is unused.
    case unspecified // = 0

    /// The subscription can actively send messages to Cloud Storage.
    case active // = 1

    /// Cannot write to the Cloud Storage bucket because of permission denied
    /// errors.
    case permissionDenied // = 2

    /// Cannot write to the Cloud Storage bucket because it does not exist.
    case notFound // = 3

    /// Cannot write to the destination because enforce_in_transit is set to true
    /// and the destination locations are not in the allowed regions.
    case inTransitLocationRestriction // = 4

    /// Cannot write to the Cloud Storage bucket due to an incompatibility
    /// between the topic schema and subscription settings.
    case schemaMismatch // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .permissionDenied
      case 3: self = .notFound
      case 4: self = .inTransitLocationRestriction
      case 5: self = .schemaMismatch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .permissionDenied: return 2
      case .notFound: return 3
      case .inTransitLocationRestriction: return 4
      case .schemaMismatch: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Pubsub_V1_CloudStorageConfig.State] = [
      .unspecified,
      .active,
      .permissionDenied,
      .notFound,
      .inTransitLocationRestriction,
      .schemaMismatch,
    ]

  }

  /// Configuration for writing message data in text format.
  /// Message payloads will be written to files as raw text, separated by a
  /// newline.
  struct TextConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Configuration for writing message data in Avro format.
  /// Message payloads and metadata will be written to files as an Avro binary.
  struct AvroConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. When true, write the subscription name, message_id,
    /// publish_time, attributes, and ordering_key as additional fields in the
    /// output. The subscription name, message_id, and publish_time fields are
    /// put in their own fields while all other message properties other than
    /// data (for example, an ordering_key, if present) are added as entries in
    /// the attributes map.
    var writeMetadata: Bool = false

    /// Optional. When true, the output Cloud Storage file will be serialized
    /// using the topic schema, if it exists.
    var useTopicSchema: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _maxDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A message and its corresponding acknowledgment ID.
struct Google_Pubsub_V1_ReceivedMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. This ID can be used to acknowledge the received message.
  var ackID: String = String()

  /// Optional. The message.
  var message: Google_Pubsub_V1_PubsubMessage {
    get {return _message ?? Google_Pubsub_V1_PubsubMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// Optional. The approximate number of times that Pub/Sub has attempted to
  /// deliver the associated message to a subscriber.
  ///
  /// More precisely, this is 1 + (number of NACKs) +
  /// (number of ack_deadline exceeds) for this message.
  ///
  /// A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline
  /// exceeds event is whenever a message is not acknowledged within
  /// ack_deadline. Note that ack_deadline is initially
  /// Subscription.ackDeadlineSeconds, but may get extended automatically by
  /// the client library.
  ///
  /// Upon the first delivery of a given message, `delivery_attempt` will have a
  /// value of 1. The value is calculated at best effort and is approximate.
  ///
  /// If a DeadLetterPolicy is not set on the subscription, this will be 0.
  var deliveryAttempt: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Google_Pubsub_V1_PubsubMessage? = nil
}

/// Request for the GetSubscription method.
struct Google_Pubsub_V1_GetSubscriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription to get.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the UpdateSubscription method.
struct Google_Pubsub_V1_UpdateSubscriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated subscription object.
  var subscription: Google_Pubsub_V1_Subscription {
    get {return _subscription ?? Google_Pubsub_V1_Subscription()}
    set {_subscription = newValue}
  }
  /// Returns true if `subscription` has been explicitly set.
  var hasSubscription: Bool {return self._subscription != nil}
  /// Clears the value of `subscription`. Subsequent reads from it will return its default value.
  mutating func clearSubscription() {self._subscription = nil}

  /// Required. Indicates which fields in the provided subscription to update.
  /// Must be specified and non-empty.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subscription: Google_Pubsub_V1_Subscription? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for the `ListSubscriptions` method.
struct Google_Pubsub_V1_ListSubscriptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which to list subscriptions.
  /// Format is `projects/{project-id}`.
  var project: String = String()

  /// Optional. Maximum number of subscriptions to return.
  var pageSize: Int32 = 0

  /// Optional. The value returned by the last `ListSubscriptionsResponse`;
  /// indicates that this is a continuation of a prior `ListSubscriptions` call,
  /// and that the system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListSubscriptions` method.
struct Google_Pubsub_V1_ListSubscriptionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The subscriptions that match the request.
  var subscriptions: [Google_Pubsub_V1_Subscription] = []

  /// Optional. If not empty, indicates that there may be more subscriptions that
  /// match the request; this value should be passed in a new
  /// `ListSubscriptionsRequest` to get more subscriptions.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the DeleteSubscription method.
struct Google_Pubsub_V1_DeleteSubscriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription to delete.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the ModifyPushConfig method.
struct Google_Pubsub_V1_ModifyPushConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Required. The push configuration for future deliveries.
  ///
  /// An empty `pushConfig` indicates that the Pub/Sub system should
  /// stop pushing messages from the given subscription and allow
  /// messages to be pulled and acknowledged - effectively pausing
  /// the subscription if `Pull` or `StreamingPull` is not called.
  var pushConfig: Google_Pubsub_V1_PushConfig {
    get {return _pushConfig ?? Google_Pubsub_V1_PushConfig()}
    set {_pushConfig = newValue}
  }
  /// Returns true if `pushConfig` has been explicitly set.
  var hasPushConfig: Bool {return self._pushConfig != nil}
  /// Clears the value of `pushConfig`. Subsequent reads from it will return its default value.
  mutating func clearPushConfig() {self._pushConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pushConfig: Google_Pubsub_V1_PushConfig? = nil
}

/// Request for the `Pull` method.
struct Google_Pubsub_V1_PullRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription from which messages should be pulled.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Optional. If this field set to true, the system will respond immediately
  /// even if it there are no messages available to return in the `Pull`
  /// response. Otherwise, the system may wait (for a bounded amount of time)
  /// until at least one message is available, rather than returning no messages.
  /// Warning: setting this field to `true` is discouraged because it adversely
  /// impacts the performance of `Pull` operations. We recommend that users do
  /// not set this field.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var returnImmediately: Bool = false

  /// Required. The maximum number of messages to return for this request. Must
  /// be a positive integer. The Pub/Sub system may return fewer than the number
  /// specified.
  var maxMessages: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `Pull` method.
struct Google_Pubsub_V1_PullResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Received Pub/Sub messages. The list will be empty if there are no
  /// more messages available in the backlog, or if no messages could be returned
  /// before the request timeout. For JSON, the response can be entirely
  /// empty. The Pub/Sub system may return fewer than the `maxMessages` requested
  /// even if there are more messages available in the backlog.
  var receivedMessages: [Google_Pubsub_V1_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the ModifyAckDeadline method.
struct Google_Pubsub_V1_ModifyAckDeadlineRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the subscription.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Required. List of acknowledgment IDs.
  var ackIds: [String] = []

  /// Required. The new ack deadline with respect to the time this request was
  /// sent to the Pub/Sub system. For example, if the value is 10, the new ack
  /// deadline will expire 10 seconds after the `ModifyAckDeadline` call was
  /// made. Specifying zero might immediately make the message available for
  /// delivery to another subscriber client. This typically results in an
  /// increase in the rate of message redeliveries (that is, duplicates).
  /// The minimum deadline you can specify is 0 seconds.
  /// The maximum deadline you can specify in a single request is 600 seconds
  /// (10 minutes).
  var ackDeadlineSeconds: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the Acknowledge method.
struct Google_Pubsub_V1_AcknowledgeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription whose message is being acknowledged.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Required. The acknowledgment ID for the messages being acknowledged that
  /// was returned by the Pub/Sub system in the `Pull` response. Must not be
  /// empty.
  var ackIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `StreamingPull` streaming RPC method. This request is used to
/// establish the initial stream as well as to stream acknowledgements and ack
/// deadline modifications from the client to the server.
struct Google_Pubsub_V1_StreamingPullRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription for which to initialize the new stream. This
  /// must be provided in the first request on the stream, and must not be set in
  /// subsequent requests from client to server.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Optional. List of acknowledgement IDs for acknowledging previously received
  /// messages (received on this stream or a different stream). If an ack ID has
  /// expired, the corresponding message may be redelivered later. Acknowledging
  /// a message more than once will not result in an error. If the
  /// acknowledgement ID is malformed, the stream will be aborted with status
  /// `INVALID_ARGUMENT`.
  var ackIds: [String] = []

  /// Optional. The list of new ack deadlines for the IDs listed in
  /// `modify_deadline_ack_ids`. The size of this list must be the same as the
  /// size of `modify_deadline_ack_ids`. If it differs the stream will be aborted
  /// with `INVALID_ARGUMENT`. Each element in this list is applied to the
  /// element in the same position in `modify_deadline_ack_ids`. The new ack
  /// deadline is with respect to the time this request was sent to the Pub/Sub
  /// system. Must be >= 0. For example, if the value is 10, the new ack deadline
  /// will expire 10 seconds after this request is received. If the value is 0,
  /// the message is immediately made available for another streaming or
  /// non-streaming pull request. If the value is < 0 (an error), the stream will
  /// be aborted with status `INVALID_ARGUMENT`.
  var modifyDeadlineSeconds: [Int32] = []

  /// Optional. List of acknowledgement IDs whose deadline will be modified based
  /// on the corresponding element in `modify_deadline_seconds`. This field can
  /// be used to indicate that more time is needed to process a message by the
  /// subscriber, or to make the message available for redelivery if the
  /// processing was interrupted.
  var modifyDeadlineAckIds: [String] = []

  /// Required. The ack deadline to use for the stream. This must be provided in
  /// the first request on the stream, but it can also be updated on subsequent
  /// requests from client to server. The minimum deadline you can specify is 10
  /// seconds. The maximum deadline you can specify is 600 seconds (10 minutes).
  var streamAckDeadlineSeconds: Int32 = 0

  /// Optional. A unique identifier that is used to distinguish client instances
  /// from each other. Only needs to be provided on the initial request. When a
  /// stream disconnects and reconnects for the same stream, the client_id should
  /// be set to the same value so that state associated with the old stream can
  /// be transferred to the new stream. The same client_id should not be used for
  /// different client instances.
  var clientID: String = String()

  /// Optional. Flow control settings for the maximum number of outstanding
  /// messages. When there are `max_outstanding_messages` currently sent to the
  /// streaming pull client that have not yet been acked or nacked, the server
  /// stops sending more messages. The sending of messages resumes once the
  /// number of outstanding messages is less than this value. If the value is
  /// <= 0, there is no limit to the number of outstanding messages. This
  /// property can only be set on the initial StreamingPullRequest. If it is set
  /// on a subsequent request, the stream will be aborted with status
  /// `INVALID_ARGUMENT`.
  var maxOutstandingMessages: Int64 = 0

  /// Optional. Flow control settings for the maximum number of outstanding
  /// bytes. When there are `max_outstanding_bytes` or more worth of messages
  /// currently sent to the streaming pull client that have not yet been acked or
  /// nacked, the server will stop sending more messages. The sending of messages
  /// resumes once the number of outstanding bytes is less than this value. If
  /// the value is <= 0, there is no limit to the number of outstanding bytes.
  /// This property can only be set on the initial StreamingPullRequest. If it is
  /// set on a subsequent request, the stream will be aborted with status
  /// `INVALID_ARGUMENT`.
  var maxOutstandingBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `StreamingPull` method. This response is used to stream
/// messages from the server to the client.
struct Google_Pubsub_V1_StreamingPullResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Received Pub/Sub messages. This will not be empty.
  var receivedMessages: [Google_Pubsub_V1_ReceivedMessage] = []

  /// Optional. This field will only be set if `enable_exactly_once_delivery` is
  /// set to `true`.
  var acknowledgeConfirmation: Google_Pubsub_V1_StreamingPullResponse.AcknowledgeConfirmation {
    get {return _acknowledgeConfirmation ?? Google_Pubsub_V1_StreamingPullResponse.AcknowledgeConfirmation()}
    set {_acknowledgeConfirmation = newValue}
  }
  /// Returns true if `acknowledgeConfirmation` has been explicitly set.
  var hasAcknowledgeConfirmation: Bool {return self._acknowledgeConfirmation != nil}
  /// Clears the value of `acknowledgeConfirmation`. Subsequent reads from it will return its default value.
  mutating func clearAcknowledgeConfirmation() {self._acknowledgeConfirmation = nil}

  /// Optional. This field will only be set if `enable_exactly_once_delivery` is
  /// set to `true`.
  var modifyAckDeadlineConfirmation: Google_Pubsub_V1_StreamingPullResponse.ModifyAckDeadlineConfirmation {
    get {return _modifyAckDeadlineConfirmation ?? Google_Pubsub_V1_StreamingPullResponse.ModifyAckDeadlineConfirmation()}
    set {_modifyAckDeadlineConfirmation = newValue}
  }
  /// Returns true if `modifyAckDeadlineConfirmation` has been explicitly set.
  var hasModifyAckDeadlineConfirmation: Bool {return self._modifyAckDeadlineConfirmation != nil}
  /// Clears the value of `modifyAckDeadlineConfirmation`. Subsequent reads from it will return its default value.
  mutating func clearModifyAckDeadlineConfirmation() {self._modifyAckDeadlineConfirmation = nil}

  /// Optional. Properties associated with this subscription.
  var subscriptionProperties: Google_Pubsub_V1_StreamingPullResponse.SubscriptionProperties {
    get {return _subscriptionProperties ?? Google_Pubsub_V1_StreamingPullResponse.SubscriptionProperties()}
    set {_subscriptionProperties = newValue}
  }
  /// Returns true if `subscriptionProperties` has been explicitly set.
  var hasSubscriptionProperties: Bool {return self._subscriptionProperties != nil}
  /// Clears the value of `subscriptionProperties`. Subsequent reads from it will return its default value.
  mutating func clearSubscriptionProperties() {self._subscriptionProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Acknowledgement IDs sent in one or more previous requests to acknowledge a
  /// previously received message.
  struct AcknowledgeConfirmation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. Successfully processed acknowledgement IDs.
    var ackIds: [String] = []

    /// Optional. List of acknowledgement IDs that were malformed or whose
    /// acknowledgement deadline has expired.
    var invalidAckIds: [String] = []

    /// Optional. List of acknowledgement IDs that were out of order.
    var unorderedAckIds: [String] = []

    /// Optional. List of acknowledgement IDs that failed processing with
    /// temporary issues.
    var temporaryFailedAckIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Acknowledgement IDs sent in one or more previous requests to modify the
  /// deadline for a specific message.
  struct ModifyAckDeadlineConfirmation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. Successfully processed acknowledgement IDs.
    var ackIds: [String] = []

    /// Optional. List of acknowledgement IDs that were malformed or whose
    /// acknowledgement deadline has expired.
    var invalidAckIds: [String] = []

    /// Optional. List of acknowledgement IDs that failed processing with
    /// temporary issues.
    var temporaryFailedAckIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Subscription properties sent as part of the response.
  struct SubscriptionProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. True iff exactly once delivery is enabled for this
    /// subscription.
    var exactlyOnceDeliveryEnabled: Bool = false

    /// Optional. True iff message ordering is enabled for this subscription.
    var messageOrderingEnabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _acknowledgeConfirmation: Google_Pubsub_V1_StreamingPullResponse.AcknowledgeConfirmation? = nil
  fileprivate var _modifyAckDeadlineConfirmation: Google_Pubsub_V1_StreamingPullResponse.ModifyAckDeadlineConfirmation? = nil
  fileprivate var _subscriptionProperties: Google_Pubsub_V1_StreamingPullResponse.SubscriptionProperties? = nil
}

/// Request for the `CreateSnapshot` method.
struct Google_Pubsub_V1_CreateSnapshotRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. User-provided name for this snapshot. If the name is not provided
  /// in the request, the server will assign a random name for this snapshot on
  /// the same project as the subscription. Note that for REST API requests, you
  /// must specify a name.  See the [resource name
  /// rules](https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
  /// Format is `projects/{project}/snapshots/{snap}`.
  var name: String = String()

  /// Required. The subscription whose backlog the snapshot retains.
  /// Specifically, the created snapshot is guaranteed to retain:
  ///  (a) The existing backlog on the subscription. More precisely, this is
  ///      defined as the messages in the subscription's backlog that are
  ///      unacknowledged upon the successful completion of the
  ///      `CreateSnapshot` request; as well as:
  ///  (b) Any messages published to the subscription's topic following the
  ///      successful completion of the CreateSnapshot request.
  /// Format is `projects/{project}/subscriptions/{sub}`.
  var subscription: String = String()

  /// Optional. See [Creating and managing
  /// labels](https://cloud.google.com/pubsub/docs/labels).
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the UpdateSnapshot method.
struct Google_Pubsub_V1_UpdateSnapshotRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated snapshot object.
  var snapshot: Google_Pubsub_V1_Snapshot {
    get {return _snapshot ?? Google_Pubsub_V1_Snapshot()}
    set {_snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  var hasSnapshot: Bool {return self._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  mutating func clearSnapshot() {self._snapshot = nil}

  /// Required. Indicates which fields in the provided snapshot to update.
  /// Must be specified and non-empty.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _snapshot: Google_Pubsub_V1_Snapshot? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// A snapshot resource. Snapshots are used in
/// [Seek](https://cloud.google.com/pubsub/docs/replay-overview)
/// operations, which allow you to manage message acknowledgments in bulk. That
/// is, you can set the acknowledgment state of messages in an existing
/// subscription to the state captured by a snapshot.
struct Google_Pubsub_V1_Snapshot: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The name of the snapshot.
  var name: String = String()

  /// Optional. The name of the topic from which this snapshot is retaining
  /// messages.
  var topic: String = String()

  /// Optional. The snapshot is guaranteed to exist up until this time.
  /// A newly-created snapshot expires no later than 7 days from the time of its
  /// creation. Its exact lifetime is determined at creation by the existing
  /// backlog in the source subscription. Specifically, the lifetime of the
  /// snapshot is `7 days - (age of oldest unacked message in the subscription)`.
  /// For example, consider a subscription whose oldest unacked message is 3 days
  /// old. If a snapshot is created from this subscription, the snapshot -- which
  /// will always capture this 3-day-old backlog as long as the snapshot
  /// exists -- will expire in 4 days. The service will refuse to create a
  /// snapshot that would expire in less than 1 hour after creation.
  var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  mutating func clearExpireTime() {self._expireTime = nil}

  /// Optional. See [Creating and managing labels]
  /// (https://cloud.google.com/pubsub/docs/labels).
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request for the GetSnapshot method.
struct Google_Pubsub_V1_GetSnapshotRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the snapshot to get.
  /// Format is `projects/{project}/snapshots/{snap}`.
  var snapshot: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `ListSnapshots` method.
struct Google_Pubsub_V1_ListSnapshotsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which to list snapshots.
  /// Format is `projects/{project-id}`.
  var project: String = String()

  /// Optional. Maximum number of snapshots to return.
  var pageSize: Int32 = 0

  /// Optional. The value returned by the last `ListSnapshotsResponse`; indicates
  /// that this is a continuation of a prior `ListSnapshots` call, and that the
  /// system should return the next page of data.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response for the `ListSnapshots` method.
struct Google_Pubsub_V1_ListSnapshotsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The resulting snapshots.
  var snapshots: [Google_Pubsub_V1_Snapshot] = []

  /// Optional. If not empty, indicates that there may be more snapshot that
  /// match the request; this value should be passed in a new
  /// `ListSnapshotsRequest`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `DeleteSnapshot` method.
struct Google_Pubsub_V1_DeleteSnapshotRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the snapshot to delete.
  /// Format is `projects/{project}/snapshots/{snap}`.
  var snapshot: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the `Seek` method.
struct Google_Pubsub_V1_SeekRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The subscription to affect.
  var subscription: String = String()

  var target: Google_Pubsub_V1_SeekRequest.OneOf_Target? = nil

  /// Optional. The time to seek to.
  /// Messages retained in the subscription that were published before this
  /// time are marked as acknowledged, and messages retained in the
  /// subscription that were published after this time are marked as
  /// unacknowledged. Note that this operation affects only those messages
  /// retained in the subscription (configured by the combination of
  /// `message_retention_duration` and `retain_acked_messages`). For example,
  /// if `time` corresponds to a point before the message retention
  /// window (or to a point before the system's notion of the subscription
  /// creation time), only retained messages will be marked as unacknowledged,
  /// and already-expunged messages will not be restored.
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .time(let v)? = target {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {target = .time(newValue)}
  }

  /// Optional. The snapshot to seek to. The snapshot's topic must be the same
  /// as that of the provided subscription. Format is
  /// `projects/{project}/snapshots/{snap}`.
  var snapshot: String {
    get {
      if case .snapshot(let v)? = target {return v}
      return String()
    }
    set {target = .snapshot(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable, Sendable {
    /// Optional. The time to seek to.
    /// Messages retained in the subscription that were published before this
    /// time are marked as acknowledged, and messages retained in the
    /// subscription that were published after this time are marked as
    /// unacknowledged. Note that this operation affects only those messages
    /// retained in the subscription (configured by the combination of
    /// `message_retention_duration` and `retain_acked_messages`). For example,
    /// if `time` corresponds to a point before the message retention
    /// window (or to a point before the system's notion of the subscription
    /// creation time), only retained messages will be marked as unacknowledged,
    /// and already-expunged messages will not be restored.
    case time(SwiftProtobuf.Google_Protobuf_Timestamp)
    /// Optional. The snapshot to seek to. The snapshot's topic must be the same
    /// as that of the provided subscription. Format is
    /// `projects/{project}/snapshots/{snap}`.
    case snapshot(String)

  }

  init() {}
}

/// Response for the `Seek` method (this response is empty).
struct Google_Pubsub_V1_SeekResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.pubsub.v1"

extension Google_Pubsub_V1_MessageStoragePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageStoragePolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_persistence_regions"),
    2: .standard(proto: "enforce_in_transit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedPersistenceRegions) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enforceInTransit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedPersistenceRegions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedPersistenceRegions, fieldNumber: 1)
    }
    if self.enforceInTransit != false {
      try visitor.visitSingularBoolField(value: self.enforceInTransit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_MessageStoragePolicy, rhs: Google_Pubsub_V1_MessageStoragePolicy) -> Bool {
    if lhs.allowedPersistenceRegions != rhs.allowedPersistenceRegions {return false}
    if lhs.enforceInTransit != rhs.enforceInTransit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_SchemaSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SchemaSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schema"),
    2: .same(proto: "encoding"),
    3: .standard(proto: "first_revision_id"),
    4: .standard(proto: "last_revision_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schema) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.encoding) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firstRevisionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lastRevisionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schema.isEmpty {
      try visitor.visitSingularStringField(value: self.schema, fieldNumber: 1)
    }
    if self.encoding != .unspecified {
      try visitor.visitSingularEnumField(value: self.encoding, fieldNumber: 2)
    }
    if !self.firstRevisionID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstRevisionID, fieldNumber: 3)
    }
    if !self.lastRevisionID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastRevisionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_SchemaSettings, rhs: Google_Pubsub_V1_SchemaSettings) -> Bool {
    if lhs.schema != rhs.schema {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.firstRevisionID != rhs.firstRevisionID {return false}
    if lhs.lastRevisionID != rhs.lastRevisionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_IngestionDataSourceSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngestionDataSourceSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aws_kinesis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .awsKinesis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .awsKinesis(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .awsKinesis(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_IngestionDataSourceSettings, rhs: Google_Pubsub_V1_IngestionDataSourceSettings) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_IngestionDataSourceSettings.protoMessageName + ".AwsKinesis"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "stream_arn"),
    3: .standard(proto: "consumer_arn"),
    4: .standard(proto: "aws_role_arn"),
    5: .standard(proto: "gcp_service_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.streamArn) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.consumerArn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.awsRoleArn) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.gcpServiceAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if !self.streamArn.isEmpty {
      try visitor.visitSingularStringField(value: self.streamArn, fieldNumber: 2)
    }
    if !self.consumerArn.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerArn, fieldNumber: 3)
    }
    if !self.awsRoleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.awsRoleArn, fieldNumber: 4)
    }
    if !self.gcpServiceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.gcpServiceAccount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis, rhs: Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.streamArn != rhs.streamArn {return false}
    if lhs.consumerArn != rhs.consumerArn {return false}
    if lhs.awsRoleArn != rhs.awsRoleArn {return false}
    if lhs.gcpServiceAccount != rhs.gcpServiceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_IngestionDataSourceSettings.AwsKinesis.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "KINESIS_PERMISSION_DENIED"),
    3: .same(proto: "PUBLISH_PERMISSION_DENIED"),
    4: .same(proto: "STREAM_NOT_FOUND"),
    5: .same(proto: "CONSUMER_NOT_FOUND"),
  ]
}

extension Google_Pubsub_V1_Topic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Topic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "labels"),
    3: .standard(proto: "message_storage_policy"),
    5: .standard(proto: "kms_key_name"),
    6: .standard(proto: "schema_settings"),
    7: .standard(proto: "satisfies_pzs"),
    8: .standard(proto: "message_retention_duration"),
    9: .same(proto: "state"),
    10: .standard(proto: "ingestion_data_source_settings"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _messageStoragePolicy: Google_Pubsub_V1_MessageStoragePolicy? = nil
    var _kmsKeyName: String = String()
    var _schemaSettings: Google_Pubsub_V1_SchemaSettings? = nil
    var _satisfiesPzs: Bool = false
    var _messageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _state: Google_Pubsub_V1_Topic.State = .unspecified
    var _ingestionDataSourceSettings: Google_Pubsub_V1_IngestionDataSourceSettings? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _labels = source._labels
      _messageStoragePolicy = source._messageStoragePolicy
      _kmsKeyName = source._kmsKeyName
      _schemaSettings = source._schemaSettings
      _satisfiesPzs = source._satisfiesPzs
      _messageRetentionDuration = source._messageRetentionDuration
      _state = source._state
      _ingestionDataSourceSettings = source._ingestionDataSourceSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._messageStoragePolicy) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._kmsKeyName) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._schemaSettings) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzs) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._messageRetentionDuration) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._ingestionDataSourceSettings) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 2)
      }
      try { if let v = _storage._messageStoragePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._kmsKeyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kmsKeyName, fieldNumber: 5)
      }
      try { if let v = _storage._schemaSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._satisfiesPzs != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzs, fieldNumber: 7)
      }
      try { if let v = _storage._messageRetentionDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 9)
      }
      try { if let v = _storage._ingestionDataSourceSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_Topic, rhs: Google_Pubsub_V1_Topic) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._messageStoragePolicy != rhs_storage._messageStoragePolicy {return false}
        if _storage._kmsKeyName != rhs_storage._kmsKeyName {return false}
        if _storage._schemaSettings != rhs_storage._schemaSettings {return false}
        if _storage._satisfiesPzs != rhs_storage._satisfiesPzs {return false}
        if _storage._messageRetentionDuration != rhs_storage._messageRetentionDuration {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._ingestionDataSourceSettings != rhs_storage._ingestionDataSourceSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_Topic.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "INGESTION_RESOURCE_ERROR"),
  ]
}

extension Google_Pubsub_V1_PubsubMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PubsubMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "attributes"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "publish_time"),
    5: .standard(proto: "ordering_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._publishTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderingKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 2)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 3)
    }
    try { if let v = self._publishTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.orderingKey.isEmpty {
      try visitor.visitSingularStringField(value: self.orderingKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PubsubMessage, rhs: Google_Pubsub_V1_PubsubMessage) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._publishTime != rhs._publishTime {return false}
    if lhs.orderingKey != rhs.orderingKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_GetTopicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTopicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_GetTopicRequest, rhs: Google_Pubsub_V1_GetTopicRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_UpdateTopicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateTopicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_UpdateTopicRequest, rhs: Google_Pubsub_V1_UpdateTopicRequest) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PublishRequest, rhs: Google_Pubsub_V1_PublishRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.messageIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messageIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PublishResponse, rhs: Google_Pubsub_V1_PublishResponse) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "project"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicsRequest, rhs: Google_Pubsub_V1_ListTopicsRequest) -> Bool {
    if lhs.project != rhs.project {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicsResponse, rhs: Google_Pubsub_V1_ListTopicsResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSubscriptionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSubscriptionsRequest, rhs: Google_Pubsub_V1_ListTopicSubscriptionsRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSubscriptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.subscriptions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subscriptions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSubscriptionsResponse, rhs: Google_Pubsub_V1_ListTopicSubscriptionsResponse) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSnapshotsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSnapshotsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSnapshotsRequest, rhs: Google_Pubsub_V1_ListTopicSnapshotsRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListTopicSnapshotsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTopicSnapshotsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshots"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.snapshots) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshots.isEmpty {
      try visitor.visitRepeatedStringField(value: self.snapshots, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListTopicSnapshotsResponse, rhs: Google_Pubsub_V1_ListTopicSnapshotsResponse) -> Bool {
    if lhs.snapshots != rhs.snapshots {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeleteTopicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteTopicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeleteTopicRequest, rhs: Google_Pubsub_V1_DeleteTopicRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DetachSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetachSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DetachSubscriptionRequest, rhs: Google_Pubsub_V1_DetachSubscriptionRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DetachSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetachSubscriptionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DetachSubscriptionResponse, rhs: Google_Pubsub_V1_DetachSubscriptionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_Subscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subscription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "topic"),
    4: .standard(proto: "push_config"),
    18: .standard(proto: "bigquery_config"),
    22: .standard(proto: "cloud_storage_config"),
    5: .standard(proto: "ack_deadline_seconds"),
    7: .standard(proto: "retain_acked_messages"),
    8: .standard(proto: "message_retention_duration"),
    9: .same(proto: "labels"),
    10: .standard(proto: "enable_message_ordering"),
    11: .standard(proto: "expiration_policy"),
    12: .same(proto: "filter"),
    13: .standard(proto: "dead_letter_policy"),
    14: .standard(proto: "retry_policy"),
    15: .same(proto: "detached"),
    16: .standard(proto: "enable_exactly_once_delivery"),
    17: .standard(proto: "topic_message_retention_duration"),
    19: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _topic: String = String()
    var _pushConfig: Google_Pubsub_V1_PushConfig? = nil
    var _bigqueryConfig: Google_Pubsub_V1_BigQueryConfig? = nil
    var _cloudStorageConfig: Google_Pubsub_V1_CloudStorageConfig? = nil
    var _ackDeadlineSeconds: Int32 = 0
    var _retainAckedMessages: Bool = false
    var _messageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _labels: Dictionary<String,String> = [:]
    var _enableMessageOrdering: Bool = false
    var _expirationPolicy: Google_Pubsub_V1_ExpirationPolicy? = nil
    var _filter: String = String()
    var _deadLetterPolicy: Google_Pubsub_V1_DeadLetterPolicy? = nil
    var _retryPolicy: Google_Pubsub_V1_RetryPolicy? = nil
    var _detached: Bool = false
    var _enableExactlyOnceDelivery: Bool = false
    var _topicMessageRetentionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _state: Google_Pubsub_V1_Subscription.State = .unspecified

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _topic = source._topic
      _pushConfig = source._pushConfig
      _bigqueryConfig = source._bigqueryConfig
      _cloudStorageConfig = source._cloudStorageConfig
      _ackDeadlineSeconds = source._ackDeadlineSeconds
      _retainAckedMessages = source._retainAckedMessages
      _messageRetentionDuration = source._messageRetentionDuration
      _labels = source._labels
      _enableMessageOrdering = source._enableMessageOrdering
      _expirationPolicy = source._expirationPolicy
      _filter = source._filter
      _deadLetterPolicy = source._deadLetterPolicy
      _retryPolicy = source._retryPolicy
      _detached = source._detached
      _enableExactlyOnceDelivery = source._enableExactlyOnceDelivery
      _topicMessageRetentionDuration = source._topicMessageRetentionDuration
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._topic) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._pushConfig) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._ackDeadlineSeconds) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._retainAckedMessages) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._messageRetentionDuration) }()
        case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._enableMessageOrdering) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._expirationPolicy) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._filter) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._deadLetterPolicy) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._detached) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._enableExactlyOnceDelivery) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._topicMessageRetentionDuration) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._bigqueryConfig) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._cloudStorageConfig) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._topic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._topic, fieldNumber: 2)
      }
      try { if let v = _storage._pushConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._ackDeadlineSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ackDeadlineSeconds, fieldNumber: 5)
      }
      if _storage._retainAckedMessages != false {
        try visitor.visitSingularBoolField(value: _storage._retainAckedMessages, fieldNumber: 7)
      }
      try { if let v = _storage._messageRetentionDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 9)
      }
      if _storage._enableMessageOrdering != false {
        try visitor.visitSingularBoolField(value: _storage._enableMessageOrdering, fieldNumber: 10)
      }
      try { if let v = _storage._expirationPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._filter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._filter, fieldNumber: 12)
      }
      try { if let v = _storage._deadLetterPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._detached != false {
        try visitor.visitSingularBoolField(value: _storage._detached, fieldNumber: 15)
      }
      if _storage._enableExactlyOnceDelivery != false {
        try visitor.visitSingularBoolField(value: _storage._enableExactlyOnceDelivery, fieldNumber: 16)
      }
      try { if let v = _storage._topicMessageRetentionDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._bigqueryConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 19)
      }
      try { if let v = _storage._cloudStorageConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_Subscription, rhs: Google_Pubsub_V1_Subscription) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._pushConfig != rhs_storage._pushConfig {return false}
        if _storage._bigqueryConfig != rhs_storage._bigqueryConfig {return false}
        if _storage._cloudStorageConfig != rhs_storage._cloudStorageConfig {return false}
        if _storage._ackDeadlineSeconds != rhs_storage._ackDeadlineSeconds {return false}
        if _storage._retainAckedMessages != rhs_storage._retainAckedMessages {return false}
        if _storage._messageRetentionDuration != rhs_storage._messageRetentionDuration {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._enableMessageOrdering != rhs_storage._enableMessageOrdering {return false}
        if _storage._expirationPolicy != rhs_storage._expirationPolicy {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._deadLetterPolicy != rhs_storage._deadLetterPolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._detached != rhs_storage._detached {return false}
        if _storage._enableExactlyOnceDelivery != rhs_storage._enableExactlyOnceDelivery {return false}
        if _storage._topicMessageRetentionDuration != rhs_storage._topicMessageRetentionDuration {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_Subscription.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "RESOURCE_ERROR"),
  ]
}

extension Google_Pubsub_V1_RetryPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RetryPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_backoff"),
    2: .standard(proto: "maximum_backoff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minimumBackoff) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maximumBackoff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minimumBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maximumBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_RetryPolicy, rhs: Google_Pubsub_V1_RetryPolicy) -> Bool {
    if lhs._minimumBackoff != rhs._minimumBackoff {return false}
    if lhs._maximumBackoff != rhs._maximumBackoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeadLetterPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeadLetterPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dead_letter_topic"),
    2: .standard(proto: "max_delivery_attempts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deadLetterTopic) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxDeliveryAttempts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deadLetterTopic.isEmpty {
      try visitor.visitSingularStringField(value: self.deadLetterTopic, fieldNumber: 1)
    }
    if self.maxDeliveryAttempts != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDeliveryAttempts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeadLetterPolicy, rhs: Google_Pubsub_V1_DeadLetterPolicy) -> Bool {
    if lhs.deadLetterTopic != rhs.deadLetterTopic {return false}
    if lhs.maxDeliveryAttempts != rhs.maxDeliveryAttempts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ExpirationPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpirationPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ExpirationPolicy, rhs: Google_Pubsub_V1_ExpirationPolicy) -> Bool {
    if lhs._ttl != rhs._ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PushConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_endpoint"),
    2: .same(proto: "attributes"),
    3: .standard(proto: "oidc_token"),
    4: .standard(proto: "pubsub_wrapper"),
    5: .standard(proto: "no_wrapper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pushEndpoint) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 3: try {
        var v: Google_Pubsub_V1_PushConfig.OidcToken?
        var hadOneofValue = false
        if let current = self.authenticationMethod {
          hadOneofValue = true
          if case .oidcToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.authenticationMethod = .oidcToken(v)
        }
      }()
      case 4: try {
        var v: Google_Pubsub_V1_PushConfig.PubsubWrapper?
        var hadOneofValue = false
        if let current = self.wrapper {
          hadOneofValue = true
          if case .pubsubWrapper(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wrapper = .pubsubWrapper(v)
        }
      }()
      case 5: try {
        var v: Google_Pubsub_V1_PushConfig.NoWrapper?
        var hadOneofValue = false
        if let current = self.wrapper {
          hadOneofValue = true
          if case .noWrapper(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wrapper = .noWrapper(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pushEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.pushEndpoint, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 2)
    }
    try { if case .oidcToken(let v)? = self.authenticationMethod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.wrapper {
    case .pubsubWrapper?: try {
      guard case .pubsubWrapper(let v)? = self.wrapper else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .noWrapper?: try {
      guard case .noWrapper(let v)? = self.wrapper else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PushConfig, rhs: Google_Pubsub_V1_PushConfig) -> Bool {
    if lhs.pushEndpoint != rhs.pushEndpoint {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.authenticationMethod != rhs.authenticationMethod {return false}
    if lhs.wrapper != rhs.wrapper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PushConfig.OidcToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_PushConfig.protoMessageName + ".OidcToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_account_email"),
    2: .same(proto: "audience"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountEmail) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.audience) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountEmail, fieldNumber: 1)
    }
    if !self.audience.isEmpty {
      try visitor.visitSingularStringField(value: self.audience, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PushConfig.OidcToken, rhs: Google_Pubsub_V1_PushConfig.OidcToken) -> Bool {
    if lhs.serviceAccountEmail != rhs.serviceAccountEmail {return false}
    if lhs.audience != rhs.audience {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PushConfig.PubsubWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_PushConfig.protoMessageName + ".PubsubWrapper"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PushConfig.PubsubWrapper, rhs: Google_Pubsub_V1_PushConfig.PubsubWrapper) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PushConfig.NoWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_PushConfig.protoMessageName + ".NoWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "write_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.writeMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.writeMetadata != false {
      try visitor.visitSingularBoolField(value: self.writeMetadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PushConfig.NoWrapper, rhs: Google_Pubsub_V1_PushConfig.NoWrapper) -> Bool {
    if lhs.writeMetadata != rhs.writeMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_BigQueryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BigQueryConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "table"),
    2: .standard(proto: "use_topic_schema"),
    3: .standard(proto: "write_metadata"),
    4: .standard(proto: "drop_unknown_fields"),
    5: .same(proto: "state"),
    6: .standard(proto: "use_table_schema"),
    7: .standard(proto: "service_account_email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.table) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.useTopicSchema) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.writeMetadata) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.dropUnknownFields) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.useTableSchema) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.serviceAccountEmail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.table.isEmpty {
      try visitor.visitSingularStringField(value: self.table, fieldNumber: 1)
    }
    if self.useTopicSchema != false {
      try visitor.visitSingularBoolField(value: self.useTopicSchema, fieldNumber: 2)
    }
    if self.writeMetadata != false {
      try visitor.visitSingularBoolField(value: self.writeMetadata, fieldNumber: 3)
    }
    if self.dropUnknownFields != false {
      try visitor.visitSingularBoolField(value: self.dropUnknownFields, fieldNumber: 4)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 5)
    }
    if self.useTableSchema != false {
      try visitor.visitSingularBoolField(value: self.useTableSchema, fieldNumber: 6)
    }
    if !self.serviceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountEmail, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_BigQueryConfig, rhs: Google_Pubsub_V1_BigQueryConfig) -> Bool {
    if lhs.table != rhs.table {return false}
    if lhs.useTopicSchema != rhs.useTopicSchema {return false}
    if lhs.writeMetadata != rhs.writeMetadata {return false}
    if lhs.dropUnknownFields != rhs.dropUnknownFields {return false}
    if lhs.state != rhs.state {return false}
    if lhs.useTableSchema != rhs.useTableSchema {return false}
    if lhs.serviceAccountEmail != rhs.serviceAccountEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_BigQueryConfig.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "PERMISSION_DENIED"),
    3: .same(proto: "NOT_FOUND"),
    4: .same(proto: "SCHEMA_MISMATCH"),
    5: .same(proto: "IN_TRANSIT_LOCATION_RESTRICTION"),
  ]
}

extension Google_Pubsub_V1_CloudStorageConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloudStorageConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .standard(proto: "filename_prefix"),
    3: .standard(proto: "filename_suffix"),
    10: .standard(proto: "filename_datetime_format"),
    4: .standard(proto: "text_config"),
    5: .standard(proto: "avro_config"),
    6: .standard(proto: "max_duration"),
    7: .standard(proto: "max_bytes"),
    8: .standard(proto: "max_messages"),
    9: .same(proto: "state"),
    11: .standard(proto: "service_account_email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filenamePrefix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filenameSuffix) }()
      case 4: try {
        var v: Google_Pubsub_V1_CloudStorageConfig.TextConfig?
        var hadOneofValue = false
        if let current = self.outputFormat {
          hadOneofValue = true
          if case .textConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outputFormat = .textConfig(v)
        }
      }()
      case 5: try {
        var v: Google_Pubsub_V1_CloudStorageConfig.AvroConfig?
        var hadOneofValue = false
        if let current = self.outputFormat {
          hadOneofValue = true
          if case .avroConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outputFormat = .avroConfig(v)
        }
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._maxDuration) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.maxBytes) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.maxMessages) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.filenameDatetimeFormat) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.serviceAccountEmail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
    }
    if !self.filenamePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.filenamePrefix, fieldNumber: 2)
    }
    if !self.filenameSuffix.isEmpty {
      try visitor.visitSingularStringField(value: self.filenameSuffix, fieldNumber: 3)
    }
    switch self.outputFormat {
    case .textConfig?: try {
      guard case .textConfig(let v)? = self.outputFormat else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .avroConfig?: try {
      guard case .avroConfig(let v)? = self.outputFormat else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try { if let v = self._maxDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.maxBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxBytes, fieldNumber: 7)
    }
    if self.maxMessages != 0 {
      try visitor.visitSingularInt64Field(value: self.maxMessages, fieldNumber: 8)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 9)
    }
    if !self.filenameDatetimeFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.filenameDatetimeFormat, fieldNumber: 10)
    }
    if !self.serviceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountEmail, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_CloudStorageConfig, rhs: Google_Pubsub_V1_CloudStorageConfig) -> Bool {
    if lhs.bucket != rhs.bucket {return false}
    if lhs.filenamePrefix != rhs.filenamePrefix {return false}
    if lhs.filenameSuffix != rhs.filenameSuffix {return false}
    if lhs.filenameDatetimeFormat != rhs.filenameDatetimeFormat {return false}
    if lhs.outputFormat != rhs.outputFormat {return false}
    if lhs._maxDuration != rhs._maxDuration {return false}
    if lhs.maxBytes != rhs.maxBytes {return false}
    if lhs.maxMessages != rhs.maxMessages {return false}
    if lhs.state != rhs.state {return false}
    if lhs.serviceAccountEmail != rhs.serviceAccountEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_CloudStorageConfig.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "PERMISSION_DENIED"),
    3: .same(proto: "NOT_FOUND"),
    4: .same(proto: "IN_TRANSIT_LOCATION_RESTRICTION"),
    5: .same(proto: "SCHEMA_MISMATCH"),
  ]
}

extension Google_Pubsub_V1_CloudStorageConfig.TextConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_CloudStorageConfig.protoMessageName + ".TextConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_CloudStorageConfig.TextConfig, rhs: Google_Pubsub_V1_CloudStorageConfig.TextConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_CloudStorageConfig.AvroConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_CloudStorageConfig.protoMessageName + ".AvroConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "write_metadata"),
    2: .standard(proto: "use_topic_schema"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.writeMetadata) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.useTopicSchema) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.writeMetadata != false {
      try visitor.visitSingularBoolField(value: self.writeMetadata, fieldNumber: 1)
    }
    if self.useTopicSchema != false {
      try visitor.visitSingularBoolField(value: self.useTopicSchema, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_CloudStorageConfig.AvroConfig, rhs: Google_Pubsub_V1_CloudStorageConfig.AvroConfig) -> Bool {
    if lhs.writeMetadata != rhs.writeMetadata {return false}
    if lhs.useTopicSchema != rhs.useTopicSchema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ReceivedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceivedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ack_id"),
    2: .same(proto: "message"),
    3: .standard(proto: "delivery_attempt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ackID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.deliveryAttempt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ackID.isEmpty {
      try visitor.visitSingularStringField(value: self.ackID, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.deliveryAttempt != 0 {
      try visitor.visitSingularInt32Field(value: self.deliveryAttempt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ReceivedMessage, rhs: Google_Pubsub_V1_ReceivedMessage) -> Bool {
    if lhs.ackID != rhs.ackID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.deliveryAttempt != rhs.deliveryAttempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_GetSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_GetSubscriptionRequest, rhs: Google_Pubsub_V1_GetSubscriptionRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_UpdateSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscription) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_UpdateSubscriptionRequest, rhs: Google_Pubsub_V1_UpdateSubscriptionRequest) -> Bool {
    if lhs._subscription != rhs._subscription {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSubscriptionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "project"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSubscriptionsRequest, rhs: Google_Pubsub_V1_ListSubscriptionsRequest) -> Bool {
    if lhs.project != rhs.project {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSubscriptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriptions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriptions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSubscriptionsResponse, rhs: Google_Pubsub_V1_ListSubscriptionsResponse) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeleteSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeleteSubscriptionRequest, rhs: Google_Pubsub_V1_DeleteSubscriptionRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ModifyPushConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyPushConfigRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "push_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pushConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    try { if let v = self._pushConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ModifyPushConfigRequest, rhs: Google_Pubsub_V1_ModifyPushConfigRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs._pushConfig != rhs._pushConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PullRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "return_immediately"),
    3: .standard(proto: "max_messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.returnImmediately) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxMessages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if self.returnImmediately != false {
      try visitor.visitSingularBoolField(value: self.returnImmediately, fieldNumber: 2)
    }
    if self.maxMessages != 0 {
      try visitor.visitSingularInt32Field(value: self.maxMessages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PullRequest, rhs: Google_Pubsub_V1_PullRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.returnImmediately != rhs.returnImmediately {return false}
    if lhs.maxMessages != rhs.maxMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_PullResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "received_messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.receivedMessages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receivedMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receivedMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_PullResponse, rhs: Google_Pubsub_V1_PullResponse) -> Bool {
    if lhs.receivedMessages != rhs.receivedMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ModifyAckDeadlineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyAckDeadlineRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    4: .standard(proto: "ack_ids"),
    3: .standard(proto: "ack_deadline_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ackDeadlineSeconds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if self.ackDeadlineSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.ackDeadlineSeconds, fieldNumber: 3)
    }
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ModifyAckDeadlineRequest, rhs: Google_Pubsub_V1_ModifyAckDeadlineRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.ackDeadlineSeconds != rhs.ackDeadlineSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_AcknowledgeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "ack_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_AcknowledgeRequest, rhs: Google_Pubsub_V1_AcknowledgeRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_StreamingPullRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingPullRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "ack_ids"),
    3: .standard(proto: "modify_deadline_seconds"),
    4: .standard(proto: "modify_deadline_ack_ids"),
    5: .standard(proto: "stream_ack_deadline_seconds"),
    6: .standard(proto: "client_id"),
    7: .standard(proto: "max_outstanding_messages"),
    8: .standard(proto: "max_outstanding_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.modifyDeadlineSeconds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.modifyDeadlineAckIds) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.streamAckDeadlineSeconds) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.maxOutstandingMessages) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.maxOutstandingBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 2)
    }
    if !self.modifyDeadlineSeconds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.modifyDeadlineSeconds, fieldNumber: 3)
    }
    if !self.modifyDeadlineAckIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modifyDeadlineAckIds, fieldNumber: 4)
    }
    if self.streamAckDeadlineSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.streamAckDeadlineSeconds, fieldNumber: 5)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 6)
    }
    if self.maxOutstandingMessages != 0 {
      try visitor.visitSingularInt64Field(value: self.maxOutstandingMessages, fieldNumber: 7)
    }
    if self.maxOutstandingBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxOutstandingBytes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_StreamingPullRequest, rhs: Google_Pubsub_V1_StreamingPullRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.modifyDeadlineSeconds != rhs.modifyDeadlineSeconds {return false}
    if lhs.modifyDeadlineAckIds != rhs.modifyDeadlineAckIds {return false}
    if lhs.streamAckDeadlineSeconds != rhs.streamAckDeadlineSeconds {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.maxOutstandingMessages != rhs.maxOutstandingMessages {return false}
    if lhs.maxOutstandingBytes != rhs.maxOutstandingBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_StreamingPullResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingPullResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "received_messages"),
    5: .standard(proto: "acknowledge_confirmation"),
    3: .standard(proto: "modify_ack_deadline_confirmation"),
    4: .standard(proto: "subscription_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.receivedMessages) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._modifyAckDeadlineConfirmation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._subscriptionProperties) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._acknowledgeConfirmation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.receivedMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receivedMessages, fieldNumber: 1)
    }
    try { if let v = self._modifyAckDeadlineConfirmation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._subscriptionProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._acknowledgeConfirmation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_StreamingPullResponse, rhs: Google_Pubsub_V1_StreamingPullResponse) -> Bool {
    if lhs.receivedMessages != rhs.receivedMessages {return false}
    if lhs._acknowledgeConfirmation != rhs._acknowledgeConfirmation {return false}
    if lhs._modifyAckDeadlineConfirmation != rhs._modifyAckDeadlineConfirmation {return false}
    if lhs._subscriptionProperties != rhs._subscriptionProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_StreamingPullResponse.AcknowledgeConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_StreamingPullResponse.protoMessageName + ".AcknowledgeConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ack_ids"),
    2: .standard(proto: "invalid_ack_ids"),
    3: .standard(proto: "unordered_ack_ids"),
    4: .standard(proto: "temporary_failed_ack_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.invalidAckIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.unorderedAckIds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.temporaryFailedAckIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 1)
    }
    if !self.invalidAckIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.invalidAckIds, fieldNumber: 2)
    }
    if !self.unorderedAckIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unorderedAckIds, fieldNumber: 3)
    }
    if !self.temporaryFailedAckIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.temporaryFailedAckIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_StreamingPullResponse.AcknowledgeConfirmation, rhs: Google_Pubsub_V1_StreamingPullResponse.AcknowledgeConfirmation) -> Bool {
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.invalidAckIds != rhs.invalidAckIds {return false}
    if lhs.unorderedAckIds != rhs.unorderedAckIds {return false}
    if lhs.temporaryFailedAckIds != rhs.temporaryFailedAckIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_StreamingPullResponse.ModifyAckDeadlineConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_StreamingPullResponse.protoMessageName + ".ModifyAckDeadlineConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ack_ids"),
    2: .standard(proto: "invalid_ack_ids"),
    3: .standard(proto: "temporary_failed_ack_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ackIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.invalidAckIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.temporaryFailedAckIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ackIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ackIds, fieldNumber: 1)
    }
    if !self.invalidAckIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.invalidAckIds, fieldNumber: 2)
    }
    if !self.temporaryFailedAckIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.temporaryFailedAckIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_StreamingPullResponse.ModifyAckDeadlineConfirmation, rhs: Google_Pubsub_V1_StreamingPullResponse.ModifyAckDeadlineConfirmation) -> Bool {
    if lhs.ackIds != rhs.ackIds {return false}
    if lhs.invalidAckIds != rhs.invalidAckIds {return false}
    if lhs.temporaryFailedAckIds != rhs.temporaryFailedAckIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_StreamingPullResponse.SubscriptionProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Pubsub_V1_StreamingPullResponse.protoMessageName + ".SubscriptionProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exactly_once_delivery_enabled"),
    2: .standard(proto: "message_ordering_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.exactlyOnceDeliveryEnabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.messageOrderingEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exactlyOnceDeliveryEnabled != false {
      try visitor.visitSingularBoolField(value: self.exactlyOnceDeliveryEnabled, fieldNumber: 1)
    }
    if self.messageOrderingEnabled != false {
      try visitor.visitSingularBoolField(value: self.messageOrderingEnabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_StreamingPullResponse.SubscriptionProperties, rhs: Google_Pubsub_V1_StreamingPullResponse.SubscriptionProperties) -> Bool {
    if lhs.exactlyOnceDeliveryEnabled != rhs.exactlyOnceDeliveryEnabled {return false}
    if lhs.messageOrderingEnabled != rhs.messageOrderingEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_CreateSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "subscription"),
    3: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_CreateSnapshotRequest, rhs: Google_Pubsub_V1_CreateSnapshotRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.subscription != rhs.subscription {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_UpdateSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._snapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_UpdateSnapshotRequest, rhs: Google_Pubsub_V1_UpdateSnapshotRequest) -> Bool {
    if lhs._snapshot != rhs._snapshot {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_Snapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Snapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "topic"),
    3: .standard(proto: "expire_time"),
    4: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    try { if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_Snapshot, rhs: Google_Pubsub_V1_Snapshot) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_GetSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.snapshot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshot.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_GetSnapshotRequest, rhs: Google_Pubsub_V1_GetSnapshotRequest) -> Bool {
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSnapshotsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSnapshotsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "project"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSnapshotsRequest, rhs: Google_Pubsub_V1_ListSnapshotsRequest) -> Bool {
    if lhs.project != rhs.project {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_ListSnapshotsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSnapshotsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshots"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.snapshots) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.snapshots, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_ListSnapshotsResponse, rhs: Google_Pubsub_V1_ListSnapshotsResponse) -> Bool {
    if lhs.snapshots != rhs.snapshots {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_DeleteSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSnapshotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.snapshot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshot.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_DeleteSnapshotRequest, rhs: Google_Pubsub_V1_DeleteSnapshotRequest) -> Bool {
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_SeekRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SeekRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .same(proto: "time"),
    3: .same(proto: "snapshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .time(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .time(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .snapshot(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    switch self.target {
    case .time?: try {
      guard case .time(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .snapshot?: try {
      guard case .snapshot(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_SeekRequest, rhs: Google_Pubsub_V1_SeekRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Pubsub_V1_SeekResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SeekResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Pubsub_V1_SeekResponse, rhs: Google_Pubsub_V1_SeekResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
