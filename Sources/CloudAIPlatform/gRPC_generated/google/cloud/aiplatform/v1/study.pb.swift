// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/study.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A message representing a Study.
public struct Google_Cloud_Aiplatform_V1_Study: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The name of a study. The study's globally unique identifier.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  public var name: String = String()

  /// Required. Describes the Study, default value is empty string.
  public var displayName: String = String()

  /// Required. Configuration of the Study.
  public var studySpec: Google_Cloud_Aiplatform_V1_StudySpec {
    get {return _studySpec ?? Google_Cloud_Aiplatform_V1_StudySpec()}
    set {_studySpec = newValue}
  }
  /// Returns true if `studySpec` has been explicitly set.
  public var hasStudySpec: Bool {return self._studySpec != nil}
  /// Clears the value of `studySpec`. Subsequent reads from it will return its default value.
  public mutating func clearStudySpec() {self._studySpec = nil}

  /// Output only. The detailed state of a Study.
  public var state: Google_Cloud_Aiplatform_V1_Study.State = .unspecified

  /// Output only. Time at which the study was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. A human readable reason why the Study is inactive.
  /// This should be empty if a study is ACTIVE or COMPLETED.
  public var inactiveReason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the Study state.
  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The study state is unspecified.
    case unspecified // = 0

    /// The study is active.
    case active // = 1

    /// The study is stopped due to an internal error.
    case inactive // = 2

    /// The study is done when the service exhausts the parameter search space
    /// or max_trial_count is reached.
    case completed // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .inactive
      case 3: self = .completed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .inactive: return 2
      case .completed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Study.State] = [
      .unspecified,
      .active,
      .inactive,
      .completed,
    ]

  }

  public init() {}

  fileprivate var _studySpec: Google_Cloud_Aiplatform_V1_StudySpec? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A message representing a Trial. A Trial contains a unique set of Parameters
/// that has been or will be evaluated, along with the objective metrics got by
/// running the Trial.
public struct Google_Cloud_Aiplatform_V1_Trial: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Resource name of the Trial assigned by the service.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Output only. The identifier of the Trial assigned by the service.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Output only. The detailed state of the Trial.
  public var state: Google_Cloud_Aiplatform_V1_Trial.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. The parameters of the Trial.
  public var parameters: [Google_Cloud_Aiplatform_V1_Trial.Parameter] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  /// Output only. The final measurement containing the objective value.
  public var finalMeasurement: Google_Cloud_Aiplatform_V1_Measurement {
    get {return _storage._finalMeasurement ?? Google_Cloud_Aiplatform_V1_Measurement()}
    set {_uniqueStorage()._finalMeasurement = newValue}
  }
  /// Returns true if `finalMeasurement` has been explicitly set.
  public var hasFinalMeasurement: Bool {return _storage._finalMeasurement != nil}
  /// Clears the value of `finalMeasurement`. Subsequent reads from it will return its default value.
  public mutating func clearFinalMeasurement() {_uniqueStorage()._finalMeasurement = nil}

  /// Output only. A list of measurements that are strictly lexicographically
  /// ordered by their induced tuples (steps, elapsed_duration).
  /// These are used for early stopping computations.
  public var measurements: [Google_Cloud_Aiplatform_V1_Measurement] {
    get {return _storage._measurements}
    set {_uniqueStorage()._measurements = newValue}
  }

  /// Output only. Time when the Trial was started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Output only. Time when the Trial's status changed to `SUCCEEDED` or
  /// `INFEASIBLE`.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Output only. The identifier of the client that originally requested this
  /// Trial. Each client is identified by a unique client_id. When a client asks
  /// for a suggestion, Vertex AI Vizier will assign it a Trial. The client
  /// should evaluate the Trial, complete it, and report back to Vertex AI
  /// Vizier. If suggestion is asked again by same client_id before the Trial is
  /// completed, the same Trial will be returned. Multiple clients with
  /// different client_ids can ask for suggestions simultaneously, each of them
  /// will get their own Trial.
  public var clientID: String {
    get {return _storage._clientID}
    set {_uniqueStorage()._clientID = newValue}
  }

  /// Output only. A human readable string describing why the Trial is
  /// infeasible. This is set only if Trial state is `INFEASIBLE`.
  public var infeasibleReason: String {
    get {return _storage._infeasibleReason}
    set {_uniqueStorage()._infeasibleReason = newValue}
  }

  /// Output only. The CustomJob name linked to the Trial.
  /// It's set for a HyperparameterTuningJob's Trial.
  public var customJob: String {
    get {return _storage._customJob}
    set {_uniqueStorage()._customJob = newValue}
  }

  /// Output only. URIs for accessing [interactive
  /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node). Only available if this trial is part of
  /// a
  /// [HyperparameterTuningJob][google.cloud.aiplatform.v1.HyperparameterTuningJob]
  /// and the job's
  /// [trial_job_spec.enable_web_access][google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]
  /// field is `true`.
  ///
  /// The keys are names of each node used for the trial; for example,
  /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
  /// the second worker pool, and `workerpool1-1` for the second node in the
  /// second worker pool.
  ///
  /// The values are the URIs for each node's interactive shell.
  public var webAccessUris: Dictionary<String,String> {
    get {return _storage._webAccessUris}
    set {_uniqueStorage()._webAccessUris = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes a Trial state.
  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The Trial state is unspecified.
    case unspecified // = 0

    /// Indicates that a specific Trial has been requested, but it has not yet
    /// been suggested by the service.
    case requested // = 1

    /// Indicates that the Trial has been suggested.
    case active // = 2

    /// Indicates that the Trial should stop according to the service.
    case stopping // = 3

    /// Indicates that the Trial is completed successfully.
    case succeeded // = 4

    /// Indicates that the Trial should not be attempted again.
    /// The service will set a Trial to INFEASIBLE when it's done but missing
    /// the final_measurement.
    case infeasible // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .requested
      case 2: self = .active
      case 3: self = .stopping
      case 4: self = .succeeded
      case 5: self = .infeasible
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .requested: return 1
      case .active: return 2
      case .stopping: return 3
      case .succeeded: return 4
      case .infeasible: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Trial.State] = [
      .unspecified,
      .requested,
      .active,
      .stopping,
      .succeeded,
      .infeasible,
    ]

  }

  /// A message representing a parameter to be tuned.
  public struct Parameter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. The ID of the parameter. The parameter should be defined in
    /// [StudySpec's
    /// Parameters][google.cloud.aiplatform.v1.StudySpec.parameters].
    public var parameterID: String = String()

    /// Output only. The value of the parameter.
    /// `number_value` will be set if a parameter defined in StudySpec is
    /// in type 'INTEGER', 'DOUBLE' or 'DISCRETE'.
    /// `string_value` will be set if a parameter defined in StudySpec is
    /// in type 'CATEGORICAL'.
    public var value: SwiftProtobuf.Google_Protobuf_Value {
      get {return _value ?? SwiftProtobuf.Google_Protobuf_Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Google_Cloud_Aiplatform_V1_TrialContext: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A human-readable field which can store a description of this context.
  /// This will become part of the resulting Trial's description field.
  public var description_p: String = String()

  /// If/when a Trial is generated or selected from this Context,
  /// its Parameters will match any parameters specified here.
  /// (I.e. if this context specifies parameter name:'a' int_value:3,
  /// then a resulting Trial will have int_value:3 for its parameter named
  /// 'a'.) Note that we first attempt to match existing REQUESTED Trials with
  /// contexts, and if there are no matches, we generate suggestions in the
  /// subspace defined by the parameters specified here.
  /// NOTE: a Context without any Parameters matches the entire feasible search
  ///   space.
  public var parameters: [Google_Cloud_Aiplatform_V1_Trial.Parameter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Time-based Constraint for Study
public struct Google_Cloud_Aiplatform_V1_StudyTimeConstraint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var constraint: Google_Cloud_Aiplatform_V1_StudyTimeConstraint.OneOf_Constraint? = nil

  /// Counts the wallclock time passed since the creation of this Study.
  public var maxDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .maxDuration(let v)? = constraint {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {constraint = .maxDuration(newValue)}
  }

  /// Compares the wallclock time to this time. Must use UTC timezone.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .endTime(let v)? = constraint {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {constraint = .endTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Constraint: Equatable, Sendable {
    /// Counts the wallclock time passed since the creation of this Study.
    case maxDuration(SwiftProtobuf.Google_Protobuf_Duration)
    /// Compares the wallclock time to this time. Must use UTC timezone.
    case endTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  }

  public init() {}
}

/// Represents specification of a Study.
public struct Google_Cloud_Aiplatform_V1_StudySpec: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var automatedStoppingSpec: OneOf_AutomatedStoppingSpec? {
    get {return _storage._automatedStoppingSpec}
    set {_uniqueStorage()._automatedStoppingSpec = newValue}
  }

  /// The automated early stopping spec using decay curve rule.
  public var decayCurveStoppingSpec: Google_Cloud_Aiplatform_V1_StudySpec.DecayCurveAutomatedStoppingSpec {
    get {
      if case .decayCurveStoppingSpec(let v)? = _storage._automatedStoppingSpec {return v}
      return Google_Cloud_Aiplatform_V1_StudySpec.DecayCurveAutomatedStoppingSpec()
    }
    set {_uniqueStorage()._automatedStoppingSpec = .decayCurveStoppingSpec(newValue)}
  }

  /// The automated early stopping spec using median rule.
  public var medianAutomatedStoppingSpec: Google_Cloud_Aiplatform_V1_StudySpec.MedianAutomatedStoppingSpec {
    get {
      if case .medianAutomatedStoppingSpec(let v)? = _storage._automatedStoppingSpec {return v}
      return Google_Cloud_Aiplatform_V1_StudySpec.MedianAutomatedStoppingSpec()
    }
    set {_uniqueStorage()._automatedStoppingSpec = .medianAutomatedStoppingSpec(newValue)}
  }

  /// The automated early stopping spec using convex stopping rule.
  public var convexAutomatedStoppingSpec: Google_Cloud_Aiplatform_V1_StudySpec.ConvexAutomatedStoppingSpec {
    get {
      if case .convexAutomatedStoppingSpec(let v)? = _storage._automatedStoppingSpec {return v}
      return Google_Cloud_Aiplatform_V1_StudySpec.ConvexAutomatedStoppingSpec()
    }
    set {_uniqueStorage()._automatedStoppingSpec = .convexAutomatedStoppingSpec(newValue)}
  }

  /// Required. Metric specs for the Study.
  public var metrics: [Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec] {
    get {return _storage._metrics}
    set {_uniqueStorage()._metrics = newValue}
  }

  /// Required. The set of parameters to tune.
  public var parameters: [Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  /// The search algorithm specified for the Study.
  public var algorithm: Google_Cloud_Aiplatform_V1_StudySpec.Algorithm {
    get {return _storage._algorithm}
    set {_uniqueStorage()._algorithm = newValue}
  }

  /// The observation noise level of the study.
  /// Currently only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  public var observationNoise: Google_Cloud_Aiplatform_V1_StudySpec.ObservationNoise {
    get {return _storage._observationNoise}
    set {_uniqueStorage()._observationNoise = newValue}
  }

  /// Describe which measurement selection type will be used
  public var measurementSelectionType: Google_Cloud_Aiplatform_V1_StudySpec.MeasurementSelectionType {
    get {return _storage._measurementSelectionType}
    set {_uniqueStorage()._measurementSelectionType = newValue}
  }

  /// Conditions for automated stopping of a Study. Enable automated stopping by
  /// configuring at least one condition.
  public var studyStoppingConfig: Google_Cloud_Aiplatform_V1_StudySpec.StudyStoppingConfig {
    get {return _storage._studyStoppingConfig ?? Google_Cloud_Aiplatform_V1_StudySpec.StudyStoppingConfig()}
    set {_uniqueStorage()._studyStoppingConfig = newValue}
  }
  /// Returns true if `studyStoppingConfig` has been explicitly set.
  public var hasStudyStoppingConfig: Bool {return _storage._studyStoppingConfig != nil}
  /// Clears the value of `studyStoppingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearStudyStoppingConfig() {_uniqueStorage()._studyStoppingConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AutomatedStoppingSpec: Equatable, Sendable {
    /// The automated early stopping spec using decay curve rule.
    case decayCurveStoppingSpec(Google_Cloud_Aiplatform_V1_StudySpec.DecayCurveAutomatedStoppingSpec)
    /// The automated early stopping spec using median rule.
    case medianAutomatedStoppingSpec(Google_Cloud_Aiplatform_V1_StudySpec.MedianAutomatedStoppingSpec)
    /// The automated early stopping spec using convex stopping rule.
    case convexAutomatedStoppingSpec(Google_Cloud_Aiplatform_V1_StudySpec.ConvexAutomatedStoppingSpec)

  }

  /// The available search algorithms for the Study.
  public enum Algorithm: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The default algorithm used by Vertex AI for [hyperparameter
    /// tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
    /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
    case unspecified // = 0

    /// Simple grid search within the feasible space. To use grid search,
    /// all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
    case gridSearch // = 2

    /// Simple random search within the feasible space.
    case randomSearch // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 2: self = .gridSearch
      case 3: self = .randomSearch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .gridSearch: return 2
      case .randomSearch: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_StudySpec.Algorithm] = [
      .unspecified,
      .gridSearch,
      .randomSearch,
    ]

  }

  /// Describes the noise level of the repeated observations.
  ///
  /// "Noisy" means that the repeated observations with the same Trial parameters
  /// may lead to different metric evaluations.
  public enum ObservationNoise: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The default noise level chosen by Vertex AI.
    case unspecified // = 0

    /// Vertex AI assumes that the objective function is (nearly)
    /// perfectly reproducible, and will never repeat the same Trial
    /// parameters.
    case low // = 1

    /// Vertex AI will estimate the amount of noise in metric
    /// evaluations, it may repeat the same Trial parameters more than once.
    case high // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .low
      case 2: self = .high
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .low: return 1
      case .high: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_StudySpec.ObservationNoise] = [
      .unspecified,
      .low,
      .high,
    ]

  }

  /// This indicates which measurement to use if/when the service automatically
  /// selects the final measurement from previously reported intermediate
  /// measurements. Choose this based on two considerations:
  ///  A) Do you expect your measurements to monotonically improve?
  ///     If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
  ///     situation where your system can "over-train" and you expect the
  ///     performance to get better for a while but then start declining,
  ///     choose BEST_MEASUREMENT.
  ///  B) Are your measurements significantly noisy and/or irreproducible?
  ///     If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
  ///     may be better to choose LAST_MEASUREMENT.
  ///  If both or neither of (A) and (B) apply, it doesn't matter which
  ///  selection type is chosen.
  public enum MeasurementSelectionType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Will be treated as LAST_MEASUREMENT.
    case unspecified // = 0

    /// Use the last measurement reported.
    case lastMeasurement // = 1

    /// Use the best measurement reported.
    case bestMeasurement // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .lastMeasurement
      case 2: self = .bestMeasurement
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .lastMeasurement: return 1
      case .bestMeasurement: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_StudySpec.MeasurementSelectionType] = [
      .unspecified,
      .lastMeasurement,
      .bestMeasurement,
    ]

  }

  /// Represents a metric to optimize.
  public struct MetricSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The ID of the metric. Must not contain whitespaces and must be
    /// unique amongst all MetricSpecs.
    public var metricID: String = String()

    /// Required. The optimization goal of the metric.
    public var goal: Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.GoalType = .unspecified

    /// Used for safe search. In the case, the metric will be a safety
    /// metric. You must provide a separate metric for objective metric.
    public var safetyConfig: Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.SafetyMetricConfig {
      get {return _safetyConfig ?? Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.SafetyMetricConfig()}
      set {_safetyConfig = newValue}
    }
    /// Returns true if `safetyConfig` has been explicitly set.
    public var hasSafetyConfig: Bool {return self._safetyConfig != nil}
    /// Clears the value of `safetyConfig`. Subsequent reads from it will return its default value.
    public mutating func clearSafetyConfig() {self._safetyConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The available types of optimization goals.
    public enum GoalType: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Goal Type will default to maximize.
      case unspecified // = 0

      /// Maximize the goal metric.
      case maximize // = 1

      /// Minimize the goal metric.
      case minimize // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .maximize
        case 2: self = .minimize
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .maximize: return 1
        case .minimize: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.GoalType] = [
        .unspecified,
        .maximize,
        .minimize,
      ]

    }

    /// Used in safe optimization to specify threshold levels and risk tolerance.
    public struct SafetyMetricConfig: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Safety threshold (boundary value between safe and unsafe). NOTE that if
      /// you leave SafetyMetricConfig unset, a default value of 0 will be used.
      public var safetyThreshold: Double = 0

      /// Desired minimum fraction of safe trials (over total number of trials)
      /// that should be targeted by the algorithm at any time during the
      /// study (best effort). This should be between 0.0 and 1.0 and a value of
      /// 0.0 means that there is no minimum and an algorithm proceeds without
      /// targeting any specific fraction. A value of 1.0 means that the
      /// algorithm attempts to only Suggest safe Trials.
      public var desiredMinSafeTrialsFraction: Double {
        get {return _desiredMinSafeTrialsFraction ?? 0}
        set {_desiredMinSafeTrialsFraction = newValue}
      }
      /// Returns true if `desiredMinSafeTrialsFraction` has been explicitly set.
      public var hasDesiredMinSafeTrialsFraction: Bool {return self._desiredMinSafeTrialsFraction != nil}
      /// Clears the value of `desiredMinSafeTrialsFraction`. Subsequent reads from it will return its default value.
      public mutating func clearDesiredMinSafeTrialsFraction() {self._desiredMinSafeTrialsFraction = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _desiredMinSafeTrialsFraction: Double? = nil
    }

    public init() {}

    fileprivate var _safetyConfig: Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.SafetyMetricConfig? = nil
  }

  /// Represents a single parameter to optimize.
  public struct ParameterSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var parameterValueSpec: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.OneOf_ParameterValueSpec? = nil

    /// The value spec for a 'DOUBLE' parameter.
    public var doubleValueSpec: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DoubleValueSpec {
      get {
        if case .doubleValueSpec(let v)? = parameterValueSpec {return v}
        return Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DoubleValueSpec()
      }
      set {parameterValueSpec = .doubleValueSpec(newValue)}
    }

    /// The value spec for an 'INTEGER' parameter.
    public var integerValueSpec: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.IntegerValueSpec {
      get {
        if case .integerValueSpec(let v)? = parameterValueSpec {return v}
        return Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.IntegerValueSpec()
      }
      set {parameterValueSpec = .integerValueSpec(newValue)}
    }

    /// The value spec for a 'CATEGORICAL' parameter.
    public var categoricalValueSpec: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.CategoricalValueSpec {
      get {
        if case .categoricalValueSpec(let v)? = parameterValueSpec {return v}
        return Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.CategoricalValueSpec()
      }
      set {parameterValueSpec = .categoricalValueSpec(newValue)}
    }

    /// The value spec for a 'DISCRETE' parameter.
    public var discreteValueSpec: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DiscreteValueSpec {
      get {
        if case .discreteValueSpec(let v)? = parameterValueSpec {return v}
        return Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DiscreteValueSpec()
      }
      set {parameterValueSpec = .discreteValueSpec(newValue)}
    }

    /// Required. The ID of the parameter. Must not contain whitespaces and must
    /// be unique amongst all ParameterSpecs.
    public var parameterID: String = String()

    /// How the parameter should be scaled.
    /// Leave unset for `CATEGORICAL` parameters.
    public var scaleType: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ScaleType = .unspecified

    /// A conditional parameter node is active if the parameter's value matches
    /// the conditional node's parent_value_condition.
    ///
    /// If two items in conditional_parameter_specs have the same name, they
    /// must have disjoint parent_value_condition.
    public var conditionalParameterSpecs: [Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ParameterValueSpec: Equatable, Sendable {
      /// The value spec for a 'DOUBLE' parameter.
      case doubleValueSpec(Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DoubleValueSpec)
      /// The value spec for an 'INTEGER' parameter.
      case integerValueSpec(Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.IntegerValueSpec)
      /// The value spec for a 'CATEGORICAL' parameter.
      case categoricalValueSpec(Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.CategoricalValueSpec)
      /// The value spec for a 'DISCRETE' parameter.
      case discreteValueSpec(Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DiscreteValueSpec)

    }

    /// The type of scaling that should be applied to this parameter.
    public enum ScaleType: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// By default, no scaling is applied.
      case unspecified // = 0

      /// Scales the feasible space to (0, 1) linearly.
      case unitLinearScale // = 1

      /// Scales the feasible space logarithmically to (0, 1). The entire
      /// feasible space must be strictly positive.
      case unitLogScale // = 2

      /// Scales the feasible space "reverse" logarithmically to (0, 1). The
      /// result is that values close to the top of the feasible space are spread
      /// out more than points near the bottom. The entire feasible space must be
      /// strictly positive.
      case unitReverseLogScale // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .unitLinearScale
        case 2: self = .unitLogScale
        case 3: self = .unitReverseLogScale
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .unitLinearScale: return 1
        case .unitLogScale: return 2
        case .unitReverseLogScale: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ScaleType] = [
        .unspecified,
        .unitLinearScale,
        .unitLogScale,
        .unitReverseLogScale,
      ]

    }

    /// Value specification for a parameter in `DOUBLE` type.
    public struct DoubleValueSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Inclusive minimum value of the parameter.
      public var minValue: Double = 0

      /// Required. Inclusive maximum value of the parameter.
      public var maxValue: Double = 0

      /// A default value for a `DOUBLE` parameter that is assumed to be a
      /// relatively good starting point.  Unset value signals that there is no
      /// offered starting point.
      ///
      /// Currently only supported by the Vertex AI Vizier service. Not supported
      /// by HyperparameterTuningJob or TrainingPipeline.
      public var defaultValue: Double {
        get {return _defaultValue ?? 0}
        set {_defaultValue = newValue}
      }
      /// Returns true if `defaultValue` has been explicitly set.
      public var hasDefaultValue: Bool {return self._defaultValue != nil}
      /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
      public mutating func clearDefaultValue() {self._defaultValue = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _defaultValue: Double? = nil
    }

    /// Value specification for a parameter in `INTEGER` type.
    public struct IntegerValueSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Inclusive minimum value of the parameter.
      public var minValue: Int64 = 0

      /// Required. Inclusive maximum value of the parameter.
      public var maxValue: Int64 = 0

      /// A default value for an `INTEGER` parameter that is assumed to be a
      /// relatively good starting point.  Unset value signals that there is no
      /// offered starting point.
      ///
      /// Currently only supported by the Vertex AI Vizier service. Not supported
      /// by HyperparameterTuningJob or TrainingPipeline.
      public var defaultValue: Int64 {
        get {return _defaultValue ?? 0}
        set {_defaultValue = newValue}
      }
      /// Returns true if `defaultValue` has been explicitly set.
      public var hasDefaultValue: Bool {return self._defaultValue != nil}
      /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
      public mutating func clearDefaultValue() {self._defaultValue = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _defaultValue: Int64? = nil
    }

    /// Value specification for a parameter in `CATEGORICAL` type.
    public struct CategoricalValueSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The list of possible categories.
      public var values: [String] = []

      /// A default value for a `CATEGORICAL` parameter that is assumed to be a
      /// relatively good starting point.  Unset value signals that there is no
      /// offered starting point.
      ///
      /// Currently only supported by the Vertex AI Vizier service. Not supported
      /// by HyperparameterTuningJob or TrainingPipeline.
      public var defaultValue: String {
        get {return _defaultValue ?? String()}
        set {_defaultValue = newValue}
      }
      /// Returns true if `defaultValue` has been explicitly set.
      public var hasDefaultValue: Bool {return self._defaultValue != nil}
      /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
      public mutating func clearDefaultValue() {self._defaultValue = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _defaultValue: String? = nil
    }

    /// Value specification for a parameter in `DISCRETE` type.
    public struct DiscreteValueSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. A list of possible values.
      /// The list should be in increasing order and at least 1e-10 apart.
      /// For instance, this parameter might have possible settings of 1.5, 2.5,
      /// and 4.0. This list should not contain more than 1,000 values.
      public var values: [Double] = []

      /// A default value for a `DISCRETE` parameter that is assumed to be a
      /// relatively good starting point.  Unset value signals that there is no
      /// offered starting point.  It automatically rounds to the
      /// nearest feasible discrete point.
      ///
      /// Currently only supported by the Vertex AI Vizier service. Not supported
      /// by HyperparameterTuningJob or TrainingPipeline.
      public var defaultValue: Double {
        get {return _defaultValue ?? 0}
        set {_defaultValue = newValue}
      }
      /// Returns true if `defaultValue` has been explicitly set.
      public var hasDefaultValue: Bool {return self._defaultValue != nil}
      /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
      public mutating func clearDefaultValue() {self._defaultValue = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _defaultValue: Double? = nil
    }

    /// Represents a parameter spec with condition from its parent parameter.
    public struct ConditionalParameterSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A set of parameter values from the parent ParameterSpec's feasible
      /// space.
      public var parentValueCondition: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.OneOf_ParentValueCondition? = nil

      /// The spec for matching values from a parent parameter of
      /// `DISCRETE` type.
      public var parentDiscreteValues: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition {
        get {
          if case .parentDiscreteValues(let v)? = parentValueCondition {return v}
          return Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition()
        }
        set {parentValueCondition = .parentDiscreteValues(newValue)}
      }

      /// The spec for matching values from a parent parameter of `INTEGER`
      /// type.
      public var parentIntValues: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition {
        get {
          if case .parentIntValues(let v)? = parentValueCondition {return v}
          return Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition()
        }
        set {parentValueCondition = .parentIntValues(newValue)}
      }

      /// The spec for matching values from a parent parameter of
      /// `CATEGORICAL` type.
      public var parentCategoricalValues: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition {
        get {
          if case .parentCategoricalValues(let v)? = parentValueCondition {return v}
          return Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition()
        }
        set {parentValueCondition = .parentCategoricalValues(newValue)}
      }

      /// Required. The spec for a conditional parameter.
      public var parameterSpec: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec {
        get {return _parameterSpec ?? Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec()}
        set {_parameterSpec = newValue}
      }
      /// Returns true if `parameterSpec` has been explicitly set.
      public var hasParameterSpec: Bool {return self._parameterSpec != nil}
      /// Clears the value of `parameterSpec`. Subsequent reads from it will return its default value.
      public mutating func clearParameterSpec() {self._parameterSpec = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// A set of parameter values from the parent ParameterSpec's feasible
      /// space.
      public enum OneOf_ParentValueCondition: Equatable, Sendable {
        /// The spec for matching values from a parent parameter of
        /// `DISCRETE` type.
        case parentDiscreteValues(Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition)
        /// The spec for matching values from a parent parameter of `INTEGER`
        /// type.
        case parentIntValues(Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition)
        /// The spec for matching values from a parent parameter of
        /// `CATEGORICAL` type.
        case parentCategoricalValues(Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition)

      }

      /// Represents the spec to match discrete values from parent parameter.
      public struct DiscreteValueCondition: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Required. Matches values of the parent parameter of 'DISCRETE' type.
        /// All values must exist in `discrete_value_spec` of parent parameter.
        ///
        /// The Epsilon of the value matching is 1e-10.
        public var values: [Double] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      /// Represents the spec to match integer values from parent parameter.
      public struct IntValueCondition: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Required. Matches values of the parent parameter of 'INTEGER' type.
        /// All values must lie in `integer_value_spec` of parent parameter.
        public var values: [Int64] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      /// Represents the spec to match categorical values from parent parameter.
      public struct CategoricalValueCondition: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Required. Matches values of the parent parameter of 'CATEGORICAL'
        /// type. All values must exist in `categorical_value_spec` of parent
        /// parameter.
        public var values: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _parameterSpec: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec? = nil
    }

    public init() {}
  }

  /// The decay curve automated stopping rule builds a Gaussian Process
  /// Regressor to predict the final objective value of a Trial based on the
  /// already completed Trials and the intermediate measurements of the current
  /// Trial. Early stopping is requested for the current Trial if there is very
  /// low probability to exceed the optimal value found so far.
  public struct DecayCurveAutomatedStoppingSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// True if
    /// [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration]
    /// is used as the x-axis of each Trials Decay Curve. Otherwise,
    /// [Measurement.step_count][google.cloud.aiplatform.v1.Measurement.step_count]
    /// will be used as the x-axis.
    public var useElapsedDuration: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The median automated stopping rule stops a pending Trial if the Trial's
  /// best objective_value is strictly below the median 'performance' of all
  /// completed Trials reported up to the Trial's last measurement.
  /// Currently, 'performance' refers to the running average of the objective
  /// values reported by the Trial in each measurement.
  public struct MedianAutomatedStoppingSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// True if median automated stopping rule applies on
    /// [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration].
    /// It means that elapsed_duration field of latest measurement of current
    /// Trial is used to compute median objective value for each completed
    /// Trials.
    public var useElapsedDuration: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Configuration for ConvexAutomatedStoppingSpec.
  /// When there are enough completed trials (configured by
  /// min_measurement_count), for pending trials with enough measurements and
  /// steps, the policy first computes an overestimate of the objective value at
  /// max_num_steps according to the slope of the incomplete objective value
  /// curve. No prediction can be made if the curve is completely flat. If the
  /// overestimation is worse than the best objective value of the completed
  /// trials, this pending trial will be early-stopped, but a last measurement
  /// will be added to the pending trial with max_num_steps and predicted
  /// objective value from the autoregression model.
  public struct ConvexAutomatedStoppingSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Steps used in predicting the final objective for early stopped trials. In
    /// general, it's set to be the same as the defined steps in training /
    /// tuning. If not defined, it will learn it from the completed trials. When
    /// use_steps is false, this field is set to the maximum elapsed seconds.
    public var maxStepCount: Int64 = 0

    /// Minimum number of steps for a trial to complete. Trials which do not have
    /// a measurement with step_count > min_step_count won't be considered for
    /// early stopping. It's ok to set it to 0, and a trial can be early stopped
    /// at any stage. By default, min_step_count is set to be one-tenth of the
    /// max_step_count.
    /// When use_elapsed_duration is true, this field is set to the minimum
    /// elapsed seconds.
    public var minStepCount: Int64 = 0

    /// The minimal number of measurements in a Trial.  Early-stopping checks
    /// will not trigger if less than min_measurement_count+1 completed trials or
    /// pending trials with less than min_measurement_count measurements. If not
    /// defined, the default value is 5.
    public var minMeasurementCount: Int64 = 0

    /// The hyper-parameter name used in the tuning job that stands for learning
    /// rate. Leave it blank if learning rate is not in a parameter in tuning.
    /// The learning_rate is used to estimate the objective value of the ongoing
    /// trial.
    public var learningRateParameterName: String = String()

    /// This bool determines whether or not the rule is applied based on
    /// elapsed_secs or steps. If use_elapsed_duration==false, the early stopping
    /// decision is made according to the predicted objective values according to
    /// the target steps. If use_elapsed_duration==true, elapsed_secs is used
    /// instead of steps. Also, in this case, the parameters max_num_steps and
    /// min_num_steps are overloaded to contain max_elapsed_seconds and
    /// min_elapsed_seconds.
    public var useElapsedDuration: Bool = false

    /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
    /// to be early stopped using a newly trained auto-regressive model. When
    /// this flag is set to True, all stopped trials from the beginning are
    /// potentially updated in terms of their `final_measurement`. Also, note
    /// that the training logic of autoregressive models is different in this
    /// case. Enabling this option has shown better results and this may be the
    /// default option in the future.
    public var updateAllStoppedTrials: Bool {
      get {return _updateAllStoppedTrials ?? false}
      set {_updateAllStoppedTrials = newValue}
    }
    /// Returns true if `updateAllStoppedTrials` has been explicitly set.
    public var hasUpdateAllStoppedTrials: Bool {return self._updateAllStoppedTrials != nil}
    /// Clears the value of `updateAllStoppedTrials`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateAllStoppedTrials() {self._updateAllStoppedTrials = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _updateAllStoppedTrials: Bool? = nil
  }

  /// The configuration (stopping conditions) for automated stopping of a Study.
  /// Conditions include trial budgets, time budgets, and convergence detection.
  public struct StudyStoppingConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
    /// STOPPING state.
    ///
    /// The bottom line is: set to true if you want to interrupt on-going
    /// evaluations of Trials as soon as the study stopping condition is met.
    /// (Please see Study.State documentation for the source of truth).
    public var shouldStopAsap: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _shouldStopAsap ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_shouldStopAsap = newValue}
    }
    /// Returns true if `shouldStopAsap` has been explicitly set.
    public var hasShouldStopAsap: Bool {return self._shouldStopAsap != nil}
    /// Clears the value of `shouldStopAsap`. Subsequent reads from it will return its default value.
    public mutating func clearShouldStopAsap() {self._shouldStopAsap = nil}

    /// Each "stopping rule" in this proto specifies an "if" condition. Before
    /// Vizier would generate a new suggestion, it first checks each specified
    /// stopping rule, from top to bottom in this list.
    /// Note that the first few rules (e.g. minimum_runtime_constraint,
    /// min_num_trials) will prevent other stopping rules from being evaluated
    /// until they are met. For example, setting `min_num_trials=5` and
    /// `always_stop_after= 1 hour` means that the Study will ONLY stop after it
    /// has 5 COMPLETED trials, even if more than an hour has passed since its
    /// creation. It follows the first applicable rule (whose "if" condition is
    /// satisfied) to make a stopping decision. If none of the specified rules
    /// are applicable, then Vizier decides that the study should not stop.
    /// If Vizier decides that the study should stop, the study enters
    /// STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
    /// IMPORTANT: The automatic study state transition happens precisely as
    /// described above; that is, deleting trials or updating StudyConfig NEVER
    /// automatically moves the study state back to ACTIVE. If you want to
    /// _resume_ a Study that was stopped, 1) change the stopping conditions if
    /// necessary, 2) activate the study, and then 3) ask for suggestions.
    /// If the specified time or duration has not passed, do not stop the
    /// study.
    public var minimumRuntimeConstraint: Google_Cloud_Aiplatform_V1_StudyTimeConstraint {
      get {return _minimumRuntimeConstraint ?? Google_Cloud_Aiplatform_V1_StudyTimeConstraint()}
      set {_minimumRuntimeConstraint = newValue}
    }
    /// Returns true if `minimumRuntimeConstraint` has been explicitly set.
    public var hasMinimumRuntimeConstraint: Bool {return self._minimumRuntimeConstraint != nil}
    /// Clears the value of `minimumRuntimeConstraint`. Subsequent reads from it will return its default value.
    public mutating func clearMinimumRuntimeConstraint() {self._minimumRuntimeConstraint = nil}

    /// If the specified time or duration has passed, stop the study.
    public var maximumRuntimeConstraint: Google_Cloud_Aiplatform_V1_StudyTimeConstraint {
      get {return _maximumRuntimeConstraint ?? Google_Cloud_Aiplatform_V1_StudyTimeConstraint()}
      set {_maximumRuntimeConstraint = newValue}
    }
    /// Returns true if `maximumRuntimeConstraint` has been explicitly set.
    public var hasMaximumRuntimeConstraint: Bool {return self._maximumRuntimeConstraint != nil}
    /// Clears the value of `maximumRuntimeConstraint`. Subsequent reads from it will return its default value.
    public mutating func clearMaximumRuntimeConstraint() {self._maximumRuntimeConstraint = nil}

    /// If there are fewer than this many COMPLETED trials, do not stop the
    /// study.
    public var minNumTrials: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _minNumTrials ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_minNumTrials = newValue}
    }
    /// Returns true if `minNumTrials` has been explicitly set.
    public var hasMinNumTrials: Bool {return self._minNumTrials != nil}
    /// Clears the value of `minNumTrials`. Subsequent reads from it will return its default value.
    public mutating func clearMinNumTrials() {self._minNumTrials = nil}

    /// If there are more than this many trials, stop the study.
    public var maxNumTrials: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _maxNumTrials ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_maxNumTrials = newValue}
    }
    /// Returns true if `maxNumTrials` has been explicitly set.
    public var hasMaxNumTrials: Bool {return self._maxNumTrials != nil}
    /// Clears the value of `maxNumTrials`. Subsequent reads from it will return its default value.
    public mutating func clearMaxNumTrials() {self._maxNumTrials = nil}

    /// If the objective value has not improved for this many consecutive
    /// trials, stop the study.
    ///
    /// WARNING: Effective only for single-objective studies.
    public var maxNumTrialsNoProgress: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _maxNumTrialsNoProgress ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_maxNumTrialsNoProgress = newValue}
    }
    /// Returns true if `maxNumTrialsNoProgress` has been explicitly set.
    public var hasMaxNumTrialsNoProgress: Bool {return self._maxNumTrialsNoProgress != nil}
    /// Clears the value of `maxNumTrialsNoProgress`. Subsequent reads from it will return its default value.
    public mutating func clearMaxNumTrialsNoProgress() {self._maxNumTrialsNoProgress = nil}

    /// If the objective value has not improved for this much time, stop the
    /// study.
    ///
    /// WARNING: Effective only for single-objective studies.
    public var maxDurationNoProgress: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maxDurationNoProgress ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maxDurationNoProgress = newValue}
    }
    /// Returns true if `maxDurationNoProgress` has been explicitly set.
    public var hasMaxDurationNoProgress: Bool {return self._maxDurationNoProgress != nil}
    /// Clears the value of `maxDurationNoProgress`. Subsequent reads from it will return its default value.
    public mutating func clearMaxDurationNoProgress() {self._maxDurationNoProgress = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _shouldStopAsap: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _minimumRuntimeConstraint: Google_Cloud_Aiplatform_V1_StudyTimeConstraint? = nil
    fileprivate var _maximumRuntimeConstraint: Google_Cloud_Aiplatform_V1_StudyTimeConstraint? = nil
    fileprivate var _minNumTrials: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    fileprivate var _maxNumTrials: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    fileprivate var _maxNumTrialsNoProgress: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    fileprivate var _maxDurationNoProgress: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A message representing a Measurement of a Trial. A Measurement contains
/// the Metrics got by executing a Trial using suggested hyperparameter
/// values.
public struct Google_Cloud_Aiplatform_V1_Measurement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Time that the Trial has been running at the point of this
  /// Measurement.
  public var elapsedDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _elapsedDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_elapsedDuration = newValue}
  }
  /// Returns true if `elapsedDuration` has been explicitly set.
  public var hasElapsedDuration: Bool {return self._elapsedDuration != nil}
  /// Clears the value of `elapsedDuration`. Subsequent reads from it will return its default value.
  public mutating func clearElapsedDuration() {self._elapsedDuration = nil}

  /// Output only. The number of steps the machine learning model has been
  /// trained for. Must be non-negative.
  public var stepCount: Int64 = 0

  /// Output only. A list of metrics got by evaluating the objective functions
  /// using suggested Parameter values.
  public var metrics: [Google_Cloud_Aiplatform_V1_Measurement.Metric] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A message representing a metric in the measurement.
  public struct Metric: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. The ID of the Metric. The Metric should be defined in
    /// [StudySpec's Metrics][google.cloud.aiplatform.v1.StudySpec.metrics].
    public var metricID: String = String()

    /// Output only. The value for this metric.
    public var value: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _elapsedDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_Study: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Study"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "study_spec"),
    4: .same(proto: "state"),
    5: .standard(proto: "create_time"),
    6: .standard(proto: "inactive_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._studySpec) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.inactiveReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    try { if let v = self._studySpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.inactiveReason.isEmpty {
      try visitor.visitSingularStringField(value: self.inactiveReason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Study, rhs: Google_Cloud_Aiplatform_V1_Study) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._studySpec != rhs._studySpec {return false}
    if lhs.state != rhs.state {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.inactiveReason != rhs.inactiveReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Study.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "INACTIVE"),
    3: .same(proto: "COMPLETED"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Trial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trial"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
    3: .same(proto: "state"),
    4: .same(proto: "parameters"),
    5: .standard(proto: "final_measurement"),
    6: .same(proto: "measurements"),
    7: .standard(proto: "start_time"),
    8: .standard(proto: "end_time"),
    9: .standard(proto: "client_id"),
    10: .standard(proto: "infeasible_reason"),
    11: .standard(proto: "custom_job"),
    12: .standard(proto: "web_access_uris"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _id: String = String()
    var _state: Google_Cloud_Aiplatform_V1_Trial.State = .unspecified
    var _parameters: [Google_Cloud_Aiplatform_V1_Trial.Parameter] = []
    var _finalMeasurement: Google_Cloud_Aiplatform_V1_Measurement? = nil
    var _measurements: [Google_Cloud_Aiplatform_V1_Measurement] = []
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _clientID: String = String()
    var _infeasibleReason: String = String()
    var _customJob: String = String()
    var _webAccessUris: Dictionary<String,String> = [:]

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _id = source._id
      _state = source._state
      _parameters = source._parameters
      _finalMeasurement = source._finalMeasurement
      _measurements = source._measurements
      _startTime = source._startTime
      _endTime = source._endTime
      _clientID = source._clientID
      _infeasibleReason = source._infeasibleReason
      _customJob = source._customJob
      _webAccessUris = source._webAccessUris
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._parameters) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._finalMeasurement) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._measurements) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._clientID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._infeasibleReason) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._customJob) }()
        case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._webAccessUris) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parameters, fieldNumber: 4)
      }
      try { if let v = _storage._finalMeasurement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._measurements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._measurements, fieldNumber: 6)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 9)
      }
      if !_storage._infeasibleReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._infeasibleReason, fieldNumber: 10)
      }
      if !_storage._customJob.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customJob, fieldNumber: 11)
      }
      if !_storage._webAccessUris.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._webAccessUris, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Trial, rhs: Google_Cloud_Aiplatform_V1_Trial) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._finalMeasurement != rhs_storage._finalMeasurement {return false}
        if _storage._measurements != rhs_storage._measurements {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._infeasibleReason != rhs_storage._infeasibleReason {return false}
        if _storage._customJob != rhs_storage._customJob {return false}
        if _storage._webAccessUris != rhs_storage._webAccessUris {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Trial.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "REQUESTED"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "STOPPING"),
    4: .same(proto: "SUCCEEDED"),
    5: .same(proto: "INFEASIBLE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Trial.Parameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Trial.protoMessageName + ".Parameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parameter_id"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parameterID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parameterID.isEmpty {
      try visitor.visitSingularStringField(value: self.parameterID, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Trial.Parameter, rhs: Google_Cloud_Aiplatform_V1_Trial.Parameter) -> Bool {
    if lhs.parameterID != rhs.parameterID {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_TrialContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrialContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_TrialContext, rhs: Google_Cloud_Aiplatform_V1_TrialContext) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudyTimeConstraint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StudyTimeConstraint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_duration"),
    2: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .maxDuration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .maxDuration(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.constraint {
          hadOneofValue = true
          if case .endTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.constraint = .endTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.constraint {
    case .maxDuration?: try {
      guard case .maxDuration(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .endTime?: try {
      guard case .endTime(let v)? = self.constraint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudyTimeConstraint, rhs: Google_Cloud_Aiplatform_V1_StudyTimeConstraint) -> Bool {
    if lhs.constraint != rhs.constraint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StudySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "decay_curve_stopping_spec"),
    5: .standard(proto: "median_automated_stopping_spec"),
    9: .standard(proto: "convex_automated_stopping_spec"),
    1: .same(proto: "metrics"),
    2: .same(proto: "parameters"),
    3: .same(proto: "algorithm"),
    6: .standard(proto: "observation_noise"),
    7: .standard(proto: "measurement_selection_type"),
    11: .standard(proto: "study_stopping_config"),
  ]

  fileprivate class _StorageClass {
    var _automatedStoppingSpec: Google_Cloud_Aiplatform_V1_StudySpec.OneOf_AutomatedStoppingSpec?
    var _metrics: [Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec] = []
    var _parameters: [Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec] = []
    var _algorithm: Google_Cloud_Aiplatform_V1_StudySpec.Algorithm = .unspecified
    var _observationNoise: Google_Cloud_Aiplatform_V1_StudySpec.ObservationNoise = .unspecified
    var _measurementSelectionType: Google_Cloud_Aiplatform_V1_StudySpec.MeasurementSelectionType = .unspecified
    var _studyStoppingConfig: Google_Cloud_Aiplatform_V1_StudySpec.StudyStoppingConfig? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _automatedStoppingSpec = source._automatedStoppingSpec
      _metrics = source._metrics
      _parameters = source._parameters
      _algorithm = source._algorithm
      _observationNoise = source._observationNoise
      _measurementSelectionType = source._measurementSelectionType
      _studyStoppingConfig = source._studyStoppingConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._metrics) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._parameters) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._algorithm) }()
        case 4: try {
          var v: Google_Cloud_Aiplatform_V1_StudySpec.DecayCurveAutomatedStoppingSpec?
          var hadOneofValue = false
          if let current = _storage._automatedStoppingSpec {
            hadOneofValue = true
            if case .decayCurveStoppingSpec(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._automatedStoppingSpec = .decayCurveStoppingSpec(v)
          }
        }()
        case 5: try {
          var v: Google_Cloud_Aiplatform_V1_StudySpec.MedianAutomatedStoppingSpec?
          var hadOneofValue = false
          if let current = _storage._automatedStoppingSpec {
            hadOneofValue = true
            if case .medianAutomatedStoppingSpec(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._automatedStoppingSpec = .medianAutomatedStoppingSpec(v)
          }
        }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._observationNoise) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._measurementSelectionType) }()
        case 9: try {
          var v: Google_Cloud_Aiplatform_V1_StudySpec.ConvexAutomatedStoppingSpec?
          var hadOneofValue = false
          if let current = _storage._automatedStoppingSpec {
            hadOneofValue = true
            if case .convexAutomatedStoppingSpec(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._automatedStoppingSpec = .convexAutomatedStoppingSpec(v)
          }
        }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._studyStoppingConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._metrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metrics, fieldNumber: 1)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parameters, fieldNumber: 2)
      }
      if _storage._algorithm != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._algorithm, fieldNumber: 3)
      }
      switch _storage._automatedStoppingSpec {
      case .decayCurveStoppingSpec?: try {
        guard case .decayCurveStoppingSpec(let v)? = _storage._automatedStoppingSpec else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .medianAutomatedStoppingSpec?: try {
        guard case .medianAutomatedStoppingSpec(let v)? = _storage._automatedStoppingSpec else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      default: break
      }
      if _storage._observationNoise != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._observationNoise, fieldNumber: 6)
      }
      if _storage._measurementSelectionType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._measurementSelectionType, fieldNumber: 7)
      }
      try { if case .convexAutomatedStoppingSpec(let v)? = _storage._automatedStoppingSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._studyStoppingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._automatedStoppingSpec != rhs_storage._automatedStoppingSpec {return false}
        if _storage._metrics != rhs_storage._metrics {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._algorithm != rhs_storage._algorithm {return false}
        if _storage._observationNoise != rhs_storage._observationNoise {return false}
        if _storage._measurementSelectionType != rhs_storage._measurementSelectionType {return false}
        if _storage._studyStoppingConfig != rhs_storage._studyStoppingConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.Algorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALGORITHM_UNSPECIFIED"),
    2: .same(proto: "GRID_SEARCH"),
    3: .same(proto: "RANDOM_SEARCH"),
  ]
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ObservationNoise: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OBSERVATION_NOISE_UNSPECIFIED"),
    1: .same(proto: "LOW"),
    2: .same(proto: "HIGH"),
  ]
}

extension Google_Cloud_Aiplatform_V1_StudySpec.MeasurementSelectionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED"),
    1: .same(proto: "LAST_MEASUREMENT"),
    2: .same(proto: "BEST_MEASUREMENT"),
  ]
}

extension Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.protoMessageName + ".MetricSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_id"),
    2: .same(proto: "goal"),
    3: .standard(proto: "safety_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metricID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.goal) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._safetyConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.metricID.isEmpty {
      try visitor.visitSingularStringField(value: self.metricID, fieldNumber: 1)
    }
    if self.goal != .unspecified {
      try visitor.visitSingularEnumField(value: self.goal, fieldNumber: 2)
    }
    try { if let v = self._safetyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec) -> Bool {
    if lhs.metricID != rhs.metricID {return false}
    if lhs.goal != rhs.goal {return false}
    if lhs._safetyConfig != rhs._safetyConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.GoalType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GOAL_TYPE_UNSPECIFIED"),
    1: .same(proto: "MAXIMIZE"),
    2: .same(proto: "MINIMIZE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.SafetyMetricConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.protoMessageName + ".SafetyMetricConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "safety_threshold"),
    2: .standard(proto: "desired_min_safe_trials_fraction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.safetyThreshold) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._desiredMinSafeTrialsFraction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.safetyThreshold.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.safetyThreshold, fieldNumber: 1)
    }
    try { if let v = self._desiredMinSafeTrialsFraction {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.SafetyMetricConfig, rhs: Google_Cloud_Aiplatform_V1_StudySpec.MetricSpec.SafetyMetricConfig) -> Bool {
    if lhs.safetyThreshold != rhs.safetyThreshold {return false}
    if lhs._desiredMinSafeTrialsFraction != rhs._desiredMinSafeTrialsFraction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.protoMessageName + ".ParameterSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "double_value_spec"),
    3: .standard(proto: "integer_value_spec"),
    4: .standard(proto: "categorical_value_spec"),
    5: .standard(proto: "discrete_value_spec"),
    1: .standard(proto: "parameter_id"),
    6: .standard(proto: "scale_type"),
    10: .standard(proto: "conditional_parameter_specs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parameterID) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DoubleValueSpec?
        var hadOneofValue = false
        if let current = self.parameterValueSpec {
          hadOneofValue = true
          if case .doubleValueSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameterValueSpec = .doubleValueSpec(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.IntegerValueSpec?
        var hadOneofValue = false
        if let current = self.parameterValueSpec {
          hadOneofValue = true
          if case .integerValueSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameterValueSpec = .integerValueSpec(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.CategoricalValueSpec?
        var hadOneofValue = false
        if let current = self.parameterValueSpec {
          hadOneofValue = true
          if case .categoricalValueSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameterValueSpec = .categoricalValueSpec(v)
        }
      }()
      case 5: try {
        var v: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DiscreteValueSpec?
        var hadOneofValue = false
        if let current = self.parameterValueSpec {
          hadOneofValue = true
          if case .discreteValueSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameterValueSpec = .discreteValueSpec(v)
        }
      }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.scaleType) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.conditionalParameterSpecs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parameterID.isEmpty {
      try visitor.visitSingularStringField(value: self.parameterID, fieldNumber: 1)
    }
    switch self.parameterValueSpec {
    case .doubleValueSpec?: try {
      guard case .doubleValueSpec(let v)? = self.parameterValueSpec else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .integerValueSpec?: try {
      guard case .integerValueSpec(let v)? = self.parameterValueSpec else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .categoricalValueSpec?: try {
      guard case .categoricalValueSpec(let v)? = self.parameterValueSpec else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .discreteValueSpec?: try {
      guard case .discreteValueSpec(let v)? = self.parameterValueSpec else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.scaleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.scaleType, fieldNumber: 6)
    }
    if !self.conditionalParameterSpecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditionalParameterSpecs, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec) -> Bool {
    if lhs.parameterValueSpec != rhs.parameterValueSpec {return false}
    if lhs.parameterID != rhs.parameterID {return false}
    if lhs.scaleType != rhs.scaleType {return false}
    if lhs.conditionalParameterSpecs != rhs.conditionalParameterSpecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ScaleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCALE_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNIT_LINEAR_SCALE"),
    2: .same(proto: "UNIT_LOG_SCALE"),
    3: .same(proto: "UNIT_REVERSE_LOG_SCALE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DoubleValueSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.protoMessageName + ".DoubleValueSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_value"),
    2: .standard(proto: "max_value"),
    4: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.minValue) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.maxValue) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minValue.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.minValue, fieldNumber: 1)
    }
    if self.maxValue.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.maxValue, fieldNumber: 2)
    }
    try { if let v = self._defaultValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DoubleValueSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DoubleValueSpec) -> Bool {
    if lhs.minValue != rhs.minValue {return false}
    if lhs.maxValue != rhs.maxValue {return false}
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.IntegerValueSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.protoMessageName + ".IntegerValueSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_value"),
    2: .standard(proto: "max_value"),
    4: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.minValue) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxValue) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minValue != 0 {
      try visitor.visitSingularInt64Field(value: self.minValue, fieldNumber: 1)
    }
    if self.maxValue != 0 {
      try visitor.visitSingularInt64Field(value: self.maxValue, fieldNumber: 2)
    }
    try { if let v = self._defaultValue {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.IntegerValueSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.IntegerValueSpec) -> Bool {
    if lhs.minValue != rhs.minValue {return false}
    if lhs.maxValue != rhs.maxValue {return false}
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.CategoricalValueSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.protoMessageName + ".CategoricalValueSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    3: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try { if let v = self._defaultValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.CategoricalValueSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.CategoricalValueSpec) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DiscreteValueSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.protoMessageName + ".DiscreteValueSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    3: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.values) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.values.isEmpty {
      try visitor.visitPackedDoubleField(value: self.values, fieldNumber: 1)
    }
    try { if let v = self._defaultValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DiscreteValueSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.DiscreteValueSpec) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.protoMessageName + ".ConditionalParameterSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "parent_discrete_values"),
    3: .standard(proto: "parent_int_values"),
    4: .standard(proto: "parent_categorical_values"),
    1: .standard(proto: "parameter_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameterSpec) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition?
        var hadOneofValue = false
        if let current = self.parentValueCondition {
          hadOneofValue = true
          if case .parentDiscreteValues(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parentValueCondition = .parentDiscreteValues(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition?
        var hadOneofValue = false
        if let current = self.parentValueCondition {
          hadOneofValue = true
          if case .parentIntValues(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parentValueCondition = .parentIntValues(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition?
        var hadOneofValue = false
        if let current = self.parentValueCondition {
          hadOneofValue = true
          if case .parentCategoricalValues(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parentValueCondition = .parentCategoricalValues(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameterSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.parentValueCondition {
    case .parentDiscreteValues?: try {
      guard case .parentDiscreteValues(let v)? = self.parentValueCondition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .parentIntValues?: try {
      guard case .parentIntValues(let v)? = self.parentValueCondition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .parentCategoricalValues?: try {
      guard case .parentCategoricalValues(let v)? = self.parentValueCondition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec) -> Bool {
    if lhs.parentValueCondition != rhs.parentValueCondition {return false}
    if lhs._parameterSpec != rhs._parameterSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.protoMessageName + ".DiscreteValueCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedDoubleField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.protoMessageName + ".IntValueCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedInt64Field(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.protoMessageName + ".CategoricalValueCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.DecayCurveAutomatedStoppingSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.protoMessageName + ".DecayCurveAutomatedStoppingSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_elapsed_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useElapsedDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useElapsedDuration != false {
      try visitor.visitSingularBoolField(value: self.useElapsedDuration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.DecayCurveAutomatedStoppingSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.DecayCurveAutomatedStoppingSpec) -> Bool {
    if lhs.useElapsedDuration != rhs.useElapsedDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.MedianAutomatedStoppingSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.protoMessageName + ".MedianAutomatedStoppingSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_elapsed_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useElapsedDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useElapsedDuration != false {
      try visitor.visitSingularBoolField(value: self.useElapsedDuration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.MedianAutomatedStoppingSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.MedianAutomatedStoppingSpec) -> Bool {
    if lhs.useElapsedDuration != rhs.useElapsedDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.ConvexAutomatedStoppingSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.protoMessageName + ".ConvexAutomatedStoppingSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_step_count"),
    2: .standard(proto: "min_step_count"),
    3: .standard(proto: "min_measurement_count"),
    4: .standard(proto: "learning_rate_parameter_name"),
    5: .standard(proto: "use_elapsed_duration"),
    6: .standard(proto: "update_all_stopped_trials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxStepCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.minStepCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.minMeasurementCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.learningRateParameterName) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.useElapsedDuration) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._updateAllStoppedTrials) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxStepCount != 0 {
      try visitor.visitSingularInt64Field(value: self.maxStepCount, fieldNumber: 1)
    }
    if self.minStepCount != 0 {
      try visitor.visitSingularInt64Field(value: self.minStepCount, fieldNumber: 2)
    }
    if self.minMeasurementCount != 0 {
      try visitor.visitSingularInt64Field(value: self.minMeasurementCount, fieldNumber: 3)
    }
    if !self.learningRateParameterName.isEmpty {
      try visitor.visitSingularStringField(value: self.learningRateParameterName, fieldNumber: 4)
    }
    if self.useElapsedDuration != false {
      try visitor.visitSingularBoolField(value: self.useElapsedDuration, fieldNumber: 5)
    }
    try { if let v = self._updateAllStoppedTrials {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.ConvexAutomatedStoppingSpec, rhs: Google_Cloud_Aiplatform_V1_StudySpec.ConvexAutomatedStoppingSpec) -> Bool {
    if lhs.maxStepCount != rhs.maxStepCount {return false}
    if lhs.minStepCount != rhs.minStepCount {return false}
    if lhs.minMeasurementCount != rhs.minMeasurementCount {return false}
    if lhs.learningRateParameterName != rhs.learningRateParameterName {return false}
    if lhs.useElapsedDuration != rhs.useElapsedDuration {return false}
    if lhs._updateAllStoppedTrials != rhs._updateAllStoppedTrials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_StudySpec.StudyStoppingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_StudySpec.protoMessageName + ".StudyStoppingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "should_stop_asap"),
    2: .standard(proto: "minimum_runtime_constraint"),
    3: .standard(proto: "maximum_runtime_constraint"),
    4: .standard(proto: "min_num_trials"),
    5: .standard(proto: "max_num_trials"),
    6: .standard(proto: "max_num_trials_no_progress"),
    7: .standard(proto: "max_duration_no_progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shouldStopAsap) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minimumRuntimeConstraint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maximumRuntimeConstraint) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minNumTrials) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maxNumTrials) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._maxNumTrialsNoProgress) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._maxDurationNoProgress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shouldStopAsap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minimumRuntimeConstraint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maximumRuntimeConstraint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minNumTrials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxNumTrials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._maxNumTrialsNoProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._maxDurationNoProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_StudySpec.StudyStoppingConfig, rhs: Google_Cloud_Aiplatform_V1_StudySpec.StudyStoppingConfig) -> Bool {
    if lhs._shouldStopAsap != rhs._shouldStopAsap {return false}
    if lhs._minimumRuntimeConstraint != rhs._minimumRuntimeConstraint {return false}
    if lhs._maximumRuntimeConstraint != rhs._maximumRuntimeConstraint {return false}
    if lhs._minNumTrials != rhs._minNumTrials {return false}
    if lhs._maxNumTrials != rhs._maxNumTrials {return false}
    if lhs._maxNumTrialsNoProgress != rhs._maxNumTrialsNoProgress {return false}
    if lhs._maxDurationNoProgress != rhs._maxDurationNoProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Measurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Measurement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elapsed_duration"),
    2: .standard(proto: "step_count"),
    3: .same(proto: "metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._elapsedDuration) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.stepCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.metrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._elapsedDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.stepCount != 0 {
      try visitor.visitSingularInt64Field(value: self.stepCount, fieldNumber: 2)
    }
    if !self.metrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Measurement, rhs: Google_Cloud_Aiplatform_V1_Measurement) -> Bool {
    if lhs._elapsedDuration != rhs._elapsedDuration {return false}
    if lhs.stepCount != rhs.stepCount {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Measurement.Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Measurement.protoMessageName + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_id"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metricID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metricID.isEmpty {
      try visitor.visitSingularStringField(value: self.metricID, fieldNumber: 1)
    }
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Measurement.Metric, rhs: Google_Cloud_Aiplatform_V1_Measurement.Metric) -> Bool {
    if lhs.metricID != rhs.metricID {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
