// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/feature_online_store_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Format of the data in the Feature View.
public enum Google_Cloud_Aiplatform_V1_FeatureViewDataFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Not set. Will be treated as the KeyValue format.
  case unspecified // = 0

  /// Return response data in key-value format.
  case keyValue // = 1

  /// Return response data in proto Struct format.
  case protoStruct // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .keyValue
    case 2: self = .protoStruct
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .keyValue: return 1
    case .protoStruct: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Cloud_Aiplatform_V1_FeatureViewDataFormat] = [
    .unspecified,
    .keyValue,
    .protoStruct,
  ]

}

/// Lookup key for a feature view.
public struct Google_Cloud_Aiplatform_V1_FeatureViewDataKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyOneof: Google_Cloud_Aiplatform_V1_FeatureViewDataKey.OneOf_KeyOneof? = nil

  /// String key to use for lookup.
  public var key: String {
    get {
      if case .key(let v)? = keyOneof {return v}
      return String()
    }
    set {keyOneof = .key(newValue)}
  }

  /// The actual Entity ID will be composed from this struct. This should match
  /// with the way ID is defined in the FeatureView spec.
  public var compositeKey: Google_Cloud_Aiplatform_V1_FeatureViewDataKey.CompositeKey {
    get {
      if case .compositeKey(let v)? = keyOneof {return v}
      return Google_Cloud_Aiplatform_V1_FeatureViewDataKey.CompositeKey()
    }
    set {keyOneof = .compositeKey(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_KeyOneof: Equatable, Sendable {
    /// String key to use for lookup.
    case key(String)
    /// The actual Entity ID will be composed from this struct. This should match
    /// with the way ID is defined in the FeatureView spec.
    case compositeKey(Google_Cloud_Aiplatform_V1_FeatureViewDataKey.CompositeKey)

  }

  /// ID that is comprised from several parts (columns).
  public struct CompositeKey: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parts to construct Entity ID. Should match with the same ID columns as
    /// defined in FeatureView in the same order.
    public var parts: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Request message for
/// [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues].
/// All the features under the requested feature view will be returned.
public struct Google_Cloud_Aiplatform_V1_FetchFeatureValuesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  public var featureView: String = String()

  /// Optional. The request key to fetch feature values for.
  public var dataKey: Google_Cloud_Aiplatform_V1_FeatureViewDataKey {
    get {return _dataKey ?? Google_Cloud_Aiplatform_V1_FeatureViewDataKey()}
    set {_dataKey = newValue}
  }
  /// Returns true if `dataKey` has been explicitly set.
  public var hasDataKey: Bool {return self._dataKey != nil}
  /// Clears the value of `dataKey`. Subsequent reads from it will return its default value.
  public mutating func clearDataKey() {self._dataKey = nil}

  /// Optional. Response data format. If not set,
  /// [FeatureViewDataFormat.KEY_VALUE][google.cloud.aiplatform.v1.FeatureViewDataFormat.KEY_VALUE]
  /// will be used.
  public var dataFormat: Google_Cloud_Aiplatform_V1_FeatureViewDataFormat = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dataKey: Google_Cloud_Aiplatform_V1_FeatureViewDataKey? = nil
}

/// Response message for
/// [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1.FeatureOnlineStoreService.FetchFeatureValues]
public struct Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.OneOf_Format? = nil

  /// Feature values in KeyValue format.
  public var keyValues: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList {
    get {
      if case .keyValues(let v)? = format {return v}
      return Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList()
    }
    set {format = .keyValues(newValue)}
  }

  /// Feature values in proto Struct format.
  public var protoStruct: SwiftProtobuf.Google_Protobuf_Struct {
    get {
      if case .protoStruct(let v)? = format {return v}
      return SwiftProtobuf.Google_Protobuf_Struct()
    }
    set {format = .protoStruct(newValue)}
  }

  /// The data key associated with this response.
  /// Will only be populated for
  /// [FeatureOnlineStoreService.StreamingFetchFeatureValues][] RPCs.
  public var dataKey: Google_Cloud_Aiplatform_V1_FeatureViewDataKey {
    get {return _dataKey ?? Google_Cloud_Aiplatform_V1_FeatureViewDataKey()}
    set {_dataKey = newValue}
  }
  /// Returns true if `dataKey` has been explicitly set.
  public var hasDataKey: Bool {return self._dataKey != nil}
  /// Clears the value of `dataKey`. Subsequent reads from it will return its default value.
  public mutating func clearDataKey() {self._dataKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Format: Equatable, Sendable {
    /// Feature values in KeyValue format.
    case keyValues(Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList)
    /// Feature values in proto Struct format.
    case protoStruct(SwiftProtobuf.Google_Protobuf_Struct)

  }

  /// Response structure in the format of key (feature name) and (feature) value
  /// pair.
  public struct FeatureNameValuePairList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of feature names and values.
    public var features: [Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Feature name & value pair.
    public struct FeatureNameValuePair: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var data: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair.OneOf_Data? = nil

      /// Feature value.
      public var value: Google_Cloud_Aiplatform_V1_FeatureValue {
        get {
          if case .value(let v)? = data {return v}
          return Google_Cloud_Aiplatform_V1_FeatureValue()
        }
        set {data = .value(newValue)}
      }

      /// Feature short name.
      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Data: Equatable, Sendable {
        /// Feature value.
        case value(Google_Cloud_Aiplatform_V1_FeatureValue)

      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _dataKey: Google_Cloud_Aiplatform_V1_FeatureViewDataKey? = nil
}

/// A query to find a number of similar entities.
public struct Google_Cloud_Aiplatform_V1_NearestNeighborQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var instance: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.OneOf_Instance? = nil

  /// Optional. The entity id whose similar entities should be searched for.
  /// If embedding is set, search will use embedding instead of
  /// entity_id.
  public var entityID: String {
    get {
      if case .entityID(let v)? = instance {return v}
      return String()
    }
    set {instance = .entityID(newValue)}
  }

  /// Optional. The embedding vector that be used for similar search.
  public var embedding: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Embedding {
    get {
      if case .embedding(let v)? = instance {return v}
      return Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Embedding()
    }
    set {instance = .embedding(newValue)}
  }

  /// Optional. The number of similar entities to be retrieved from feature view
  /// for each query.
  public var neighborCount: Int32 = 0

  /// Optional. The list of string filters.
  public var stringFilters: [Google_Cloud_Aiplatform_V1_NearestNeighborQuery.StringFilter] = []

  /// Optional. The list of numeric filters.
  public var numericFilters: [Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter] = []

  /// Optional. Crowding is a constraint on a neighbor list produced by nearest
  /// neighbor search requiring that no more than
  /// sper_crowding_attribute_neighbor_count of the k neighbors returned have the
  /// same value of crowding_attribute. It's used for improving result diversity.
  public var perCrowdingAttributeNeighborCount: Int32 = 0

  /// Optional. Parameters that can be set to tune query on the fly.
  public var parameters: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Parameters {
    get {return _parameters ?? Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Parameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Instance: Equatable, Sendable {
    /// Optional. The entity id whose similar entities should be searched for.
    /// If embedding is set, search will use embedding instead of
    /// entity_id.
    case entityID(String)
    /// Optional. The embedding vector that be used for similar search.
    case embedding(Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Embedding)

  }

  /// The embedding vector.
  public struct Embedding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. Individual value in the embedding.
    public var value: [Float] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// String filter is used to search a subset of the entities by using boolean
  /// rules on string columns.
  /// For example: if a query specifies string filter
  /// with 'name = color, allow_tokens = {red, blue}, deny_tokens = {purple}','
  /// then that query will match entities that are red or blue, but if those
  /// points are also purple, then they will be excluded even if they are
  /// red/blue. Only string filter is supported for now, numeric filter will be
  /// supported in the near future.
  public struct StringFilter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Column names in BigQuery that used as filters.
    public var name: String = String()

    /// Optional. The allowed tokens.
    public var allowTokens: [String] = []

    /// Optional. The denied tokens.
    public var denyTokens: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Numeric filter is used to search a subset of the entities by using boolean
  /// rules on numeric columns.
  /// For example:
  /// Database Point 0: {name: “a” value_int: 42} {name: “b” value_float: 1.0}
  /// Database Point 1:  {name: “a” value_int: 10} {name: “b” value_float: 2.0}
  /// Database Point 2: {name: “a” value_int: -1} {name: “b” value_float: 3.0}
  /// Query: {name: “a” value_int: 12 operator: LESS}    // Matches Point 1, 2
  /// {name: “b” value_float: 2.0 operator: EQUAL} // Matches Point 1
  public struct NumericFilter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of Value must be consistent for all datapoints with a given
    /// name.  This is verified at runtime.
    public var value: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter.OneOf_Value? = nil

    /// int value type.
    public var valueInt: Int64 {
      get {
        if case .valueInt(let v)? = value {return v}
        return 0
      }
      set {value = .valueInt(newValue)}
    }

    /// float value type.
    public var valueFloat: Float {
      get {
        if case .valueFloat(let v)? = value {return v}
        return 0
      }
      set {value = .valueFloat(newValue)}
    }

    /// double value type.
    public var valueDouble: Double {
      get {
        if case .valueDouble(let v)? = value {return v}
        return 0
      }
      set {value = .valueDouble(newValue)}
    }

    /// Required. Column name in BigQuery that used as filters.
    public var name: String = String()

    /// Optional. This MUST be specified for queries and must NOT be specified
    /// for database points.
    public var op: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter.Operator {
      get {return _op ?? .unspecified}
      set {_op = newValue}
    }
    /// Returns true if `op` has been explicitly set.
    public var hasOp: Bool {return self._op != nil}
    /// Clears the value of `op`. Subsequent reads from it will return its default value.
    public mutating func clearOp() {self._op = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of Value must be consistent for all datapoints with a given
    /// name.  This is verified at runtime.
    public enum OneOf_Value: Equatable, Sendable {
      /// int value type.
      case valueInt(Int64)
      /// float value type.
      case valueFloat(Float)
      /// double value type.
      case valueDouble(Double)

    }

    /// Datapoints for which Operator is true relative to the query’s Value
    /// field will be allowlisted.
    public enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Unspecified operator.
      case unspecified // = 0

      /// Entities are eligible if their value is < the query's.
      case less // = 1

      /// Entities are eligible if their value is <= the query's.
      case lessEqual // = 2

      /// Entities are eligible if their value is == the query's.
      case equal // = 3

      /// Entities are eligible if their value is >= the query's.
      case greaterEqual // = 4

      /// Entities are eligible if their value is > the query's.
      case greater // = 5

      /// Entities are eligible if their value is != the query's.
      case notEqual // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .less
        case 2: self = .lessEqual
        case 3: self = .equal
        case 4: self = .greaterEqual
        case 5: self = .greater
        case 6: self = .notEqual
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .less: return 1
        case .lessEqual: return 2
        case .equal: return 3
        case .greaterEqual: return 4
        case .greater: return 5
        case .notEqual: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter.Operator] = [
        .unspecified,
        .less,
        .lessEqual,
        .equal,
        .greaterEqual,
        .greater,
        .notEqual,
      ]

    }

    public init() {}

    fileprivate var _op: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter.Operator? = nil
  }

  /// Parameters that can be overrided in each query to tune query latency and
  /// recall.
  public struct Parameters: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. The number of neighbors to find via approximate search before
    /// exact reordering is performed; if set, this value must be >
    /// neighbor_count.
    public var approximateNeighborCandidates: Int32 = 0

    /// Optional. The fraction of the number of leaves to search, set at query
    /// time allows user to tune search performance. This value increase result
    /// in both search accuracy and latency increase. The value should be between
    /// 0.0 and 1.0.
    public var leafNodesSearchFraction: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _parameters: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Parameters? = nil
}

/// The request message for
/// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities].
public struct Google_Cloud_Aiplatform_V1_SearchNearestEntitiesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  public var featureView: String = String()

  /// Required. The query.
  public var query: Google_Cloud_Aiplatform_V1_NearestNeighborQuery {
    get {return _query ?? Google_Cloud_Aiplatform_V1_NearestNeighborQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  /// Optional. If set to true, the full entities (including all vector values
  /// and metadata) of the nearest neighbors are returned; otherwise only entity
  /// id of the nearest neighbors will be returned. Note that returning full
  /// entities will significantly increase the latency and cost of the query.
  public var returnFullEntity: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Google_Cloud_Aiplatform_V1_NearestNeighborQuery? = nil
}

/// Nearest neighbors for one query.
public struct Google_Cloud_Aiplatform_V1_NearestNeighbors: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All its neighbors.
  public var neighbors: [Google_Cloud_Aiplatform_V1_NearestNeighbors.Neighbor] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A neighbor of the query vector.
  public struct Neighbor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the similar entity.
    public var entityID: String = String()

    /// The distance between the neighbor and the query vector.
    public var distance: Double = 0

    /// The attributes of the neighbor, e.g. filters, crowding and metadata
    /// Note that full entities are returned only when "return_full_entity"
    /// is set to true. Otherwise, only the "entity_id" and "distance" fields
    /// are populated.
    public var entityKeyValues: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse {
      get {return _entityKeyValues ?? Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse()}
      set {_entityKeyValues = newValue}
    }
    /// Returns true if `entityKeyValues` has been explicitly set.
    public var hasEntityKeyValues: Bool {return self._entityKeyValues != nil}
    /// Clears the value of `entityKeyValues`. Subsequent reads from it will return its default value.
    public mutating func clearEntityKeyValues() {self._entityKeyValues = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityKeyValues: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse? = nil
  }

  public init() {}
}

/// Response message for
/// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]
public struct Google_Cloud_Aiplatform_V1_SearchNearestEntitiesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nearest neighbors of the query entity.
  public var nearestNeighbors: Google_Cloud_Aiplatform_V1_NearestNeighbors {
    get {return _nearestNeighbors ?? Google_Cloud_Aiplatform_V1_NearestNeighbors()}
    set {_nearestNeighbors = newValue}
  }
  /// Returns true if `nearestNeighbors` has been explicitly set.
  public var hasNearestNeighbors: Bool {return self._nearestNeighbors != nil}
  /// Clears the value of `nearestNeighbors`. Subsequent reads from it will return its default value.
  public mutating func clearNearestNeighbors() {self._nearestNeighbors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nearestNeighbors: Google_Cloud_Aiplatform_V1_NearestNeighbors? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_FeatureViewDataFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED"),
    1: .same(proto: "KEY_VALUE"),
    2: .same(proto: "PROTO_STRUCT"),
  ]
}

extension Google_Cloud_Aiplatform_V1_FeatureViewDataKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureViewDataKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "composite_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.keyOneof != nil {try decoder.handleConflictingOneOf()}
          self.keyOneof = .key(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_FeatureViewDataKey.CompositeKey?
        var hadOneofValue = false
        if let current = self.keyOneof {
          hadOneofValue = true
          if case .compositeKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.keyOneof = .compositeKey(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.keyOneof {
    case .key?: try {
      guard case .key(let v)? = self.keyOneof else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .compositeKey?: try {
      guard case .compositeKey(let v)? = self.keyOneof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureViewDataKey, rhs: Google_Cloud_Aiplatform_V1_FeatureViewDataKey) -> Bool {
    if lhs.keyOneof != rhs.keyOneof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureViewDataKey.CompositeKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureViewDataKey.protoMessageName + ".CompositeKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.parts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureViewDataKey.CompositeKey, rhs: Google_Cloud_Aiplatform_V1_FeatureViewDataKey.CompositeKey) -> Bool {
    if lhs.parts != rhs.parts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FetchFeatureValuesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchFeatureValuesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_view"),
    6: .standard(proto: "data_key"),
    7: .standard(proto: "data_format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.featureView) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._dataKey) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.dataFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.featureView.isEmpty {
      try visitor.visitSingularStringField(value: self.featureView, fieldNumber: 1)
    }
    try { if let v = self._dataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.dataFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataFormat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesRequest, rhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesRequest) -> Bool {
    if lhs.featureView != rhs.featureView {return false}
    if lhs._dataKey != rhs._dataKey {return false}
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchFeatureValuesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "key_values"),
    2: .standard(proto: "proto_struct"),
    4: .standard(proto: "data_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .protoStruct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .protoStruct(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .keyValues(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .keyValues(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._dataKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.format {
    case .protoStruct?: try {
      guard case .protoStruct(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .keyValues?: try {
      guard case .keyValues(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._dataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse, rhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs._dataKey != rhs._dataKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.protoMessageName + ".FeatureNameValuePairList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.features) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList, rhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList) -> Bool {
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList.protoMessageName + ".FeatureNameValuePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "value"),
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_FeatureValue?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .value(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .value(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if case .value(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair, rhs: Google_Cloud_Aiplatform_V1_FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NearestNeighborQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NearestNeighborQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .same(proto: "embedding"),
    3: .standard(proto: "neighbor_count"),
    4: .standard(proto: "string_filters"),
    8: .standard(proto: "numeric_filters"),
    5: .standard(proto: "per_crowding_attribute_neighbor_count"),
    7: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.instance != nil {try decoder.handleConflictingOneOf()}
          self.instance = .entityID(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Embedding?
        var hadOneofValue = false
        if let current = self.instance {
          hadOneofValue = true
          if case .embedding(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.instance = .embedding(v)
        }
      }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.neighborCount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.stringFilters) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.perCrowdingAttributeNeighborCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.numericFilters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.instance {
    case .entityID?: try {
      guard case .entityID(let v)? = self.instance else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .embedding?: try {
      guard case .embedding(let v)? = self.instance else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.neighborCount != 0 {
      try visitor.visitSingularInt32Field(value: self.neighborCount, fieldNumber: 3)
    }
    if !self.stringFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stringFilters, fieldNumber: 4)
    }
    if self.perCrowdingAttributeNeighborCount != 0 {
      try visitor.visitSingularInt32Field(value: self.perCrowdingAttributeNeighborCount, fieldNumber: 5)
    }
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.numericFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.numericFilters, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery, rhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery) -> Bool {
    if lhs.instance != rhs.instance {return false}
    if lhs.neighborCount != rhs.neighborCount {return false}
    if lhs.stringFilters != rhs.stringFilters {return false}
    if lhs.numericFilters != rhs.numericFilters {return false}
    if lhs.perCrowdingAttributeNeighborCount != rhs.perCrowdingAttributeNeighborCount {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Embedding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NearestNeighborQuery.protoMessageName + ".Embedding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitPackedFloatField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Embedding, rhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Embedding) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NearestNeighborQuery.StringFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NearestNeighborQuery.protoMessageName + ".StringFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "allow_tokens"),
    3: .standard(proto: "deny_tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowTokens) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.denyTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.allowTokens.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowTokens, fieldNumber: 2)
    }
    if !self.denyTokens.isEmpty {
      try visitor.visitRepeatedStringField(value: self.denyTokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.StringFilter, rhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.StringFilter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.allowTokens != rhs.allowTokens {return false}
    if lhs.denyTokens != rhs.denyTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NearestNeighborQuery.protoMessageName + ".NumericFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "value_int"),
    3: .standard(proto: "value_float"),
    4: .standard(proto: "value_double"),
    1: .same(proto: "name"),
    5: .same(proto: "op"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .valueInt(v)
        }
      }()
      case 3: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .valueFloat(v)
        }
      }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .valueDouble(v)
        }
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._op) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.value {
    case .valueInt?: try {
      guard case .valueInt(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .valueFloat?: try {
      guard case .valueFloat(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }()
    case .valueDouble?: try {
      guard case .valueDouble(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._op {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter, rhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.name != rhs.name {return false}
    if lhs._op != rhs._op {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NearestNeighborQuery.NumericFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "LESS"),
    2: .same(proto: "LESS_EQUAL"),
    3: .same(proto: "EQUAL"),
    4: .same(proto: "GREATER_EQUAL"),
    5: .same(proto: "GREATER"),
    6: .same(proto: "NOT_EQUAL"),
  ]
}

extension Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NearestNeighborQuery.protoMessageName + ".Parameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "approximate_neighbor_candidates"),
    2: .standard(proto: "leaf_nodes_search_fraction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.approximateNeighborCandidates) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.leafNodesSearchFraction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.approximateNeighborCandidates != 0 {
      try visitor.visitSingularInt32Field(value: self.approximateNeighborCandidates, fieldNumber: 1)
    }
    if self.leafNodesSearchFraction.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.leafNodesSearchFraction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Parameters, rhs: Google_Cloud_Aiplatform_V1_NearestNeighborQuery.Parameters) -> Bool {
    if lhs.approximateNeighborCandidates != rhs.approximateNeighborCandidates {return false}
    if lhs.leafNodesSearchFraction != rhs.leafNodesSearchFraction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SearchNearestEntitiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchNearestEntitiesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_view"),
    2: .same(proto: "query"),
    3: .standard(proto: "return_full_entity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.featureView) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.returnFullEntity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.featureView.isEmpty {
      try visitor.visitSingularStringField(value: self.featureView, fieldNumber: 1)
    }
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.returnFullEntity != false {
      try visitor.visitSingularBoolField(value: self.returnFullEntity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SearchNearestEntitiesRequest, rhs: Google_Cloud_Aiplatform_V1_SearchNearestEntitiesRequest) -> Bool {
    if lhs.featureView != rhs.featureView {return false}
    if lhs._query != rhs._query {return false}
    if lhs.returnFullEntity != rhs.returnFullEntity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NearestNeighbors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NearestNeighbors"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "neighbors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.neighbors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.neighbors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.neighbors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NearestNeighbors, rhs: Google_Cloud_Aiplatform_V1_NearestNeighbors) -> Bool {
    if lhs.neighbors != rhs.neighbors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NearestNeighbors.Neighbor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NearestNeighbors.protoMessageName + ".Neighbor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .same(proto: "distance"),
    3: .standard(proto: "entity_key_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.distance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._entityKeyValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 1)
    }
    if self.distance.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.distance, fieldNumber: 2)
    }
    try { if let v = self._entityKeyValues {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NearestNeighbors.Neighbor, rhs: Google_Cloud_Aiplatform_V1_NearestNeighbors.Neighbor) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs._entityKeyValues != rhs._entityKeyValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SearchNearestEntitiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchNearestEntitiesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nearest_neighbors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nearestNeighbors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nearestNeighbors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SearchNearestEntitiesResponse, rhs: Google_Cloud_Aiplatform_V1_SearchNearestEntitiesResponse) -> Bool {
    if lhs._nearestNeighbors != rhs._nearestNeighbors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
