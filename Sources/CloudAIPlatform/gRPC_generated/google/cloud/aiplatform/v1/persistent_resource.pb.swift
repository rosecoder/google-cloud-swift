// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/persistent_resource.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents long-lasting resources that are dedicated to users to runs custom
/// workloads.
/// A PersistentResource can have multiple node pools and each node
/// pool can have its own machine spec.
public struct Google_Cloud_Aiplatform_V1_PersistentResource: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. Resource name of a PersistentResource.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional. The display name of the PersistentResource.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Required. The spec of the pools of different resources.
  public var resourcePools: [Google_Cloud_Aiplatform_V1_ResourcePool] {
    get {return _storage._resourcePools}
    set {_uniqueStorage()._resourcePools = newValue}
  }

  /// Output only. The detailed state of a Study.
  public var state: Google_Cloud_Aiplatform_V1_PersistentResource.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. Only populated when persistent resource's state is `STOPPING`
  /// or `ERROR`.
  public var error: Google_Rpc_Status {
    get {return _storage._error ?? Google_Rpc_Status()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {_uniqueStorage()._error = nil}

  /// Output only. Time when the PersistentResource was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Time when the PersistentResource for the first time entered
  /// the `RUNNING` state.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Output only. Time when the PersistentResource was most recently updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Optional. The labels with user-defined metadata to organize
  /// PersistentResource.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Optional. The full name of the Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to peered with
  /// Vertex AI to host the persistent resources.
  /// For example, `projects/12345/global/networks/myVPC`.
  /// [Format](/compute/docs/reference/rest/v1/networks/insert)
  /// is of the form `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in `12345`, and {network} is a
  /// network name.
  ///
  /// To specify this field, you must have already [configured VPC Network
  /// Peering for Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  ///
  /// If this field is left unspecified, the resources aren't peered with any
  /// network.
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// Optional. Customer-managed encryption key spec for a PersistentResource.
  /// If set, this PersistentResource and all sub-resources of this
  /// PersistentResource will be secured by this key.
  public var encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec {
    get {return _storage._encryptionSpec ?? Google_Cloud_Aiplatform_V1_EncryptionSpec()}
    set {_uniqueStorage()._encryptionSpec = newValue}
  }
  /// Returns true if `encryptionSpec` has been explicitly set.
  public var hasEncryptionSpec: Bool {return _storage._encryptionSpec != nil}
  /// Clears the value of `encryptionSpec`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptionSpec() {_uniqueStorage()._encryptionSpec = nil}

  /// Optional. Persistent Resource runtime spec.
  /// For example, used for Ray cluster configuration.
  public var resourceRuntimeSpec: Google_Cloud_Aiplatform_V1_ResourceRuntimeSpec {
    get {return _storage._resourceRuntimeSpec ?? Google_Cloud_Aiplatform_V1_ResourceRuntimeSpec()}
    set {_uniqueStorage()._resourceRuntimeSpec = newValue}
  }
  /// Returns true if `resourceRuntimeSpec` has been explicitly set.
  public var hasResourceRuntimeSpec: Bool {return _storage._resourceRuntimeSpec != nil}
  /// Clears the value of `resourceRuntimeSpec`. Subsequent reads from it will return its default value.
  public mutating func clearResourceRuntimeSpec() {_uniqueStorage()._resourceRuntimeSpec = nil}

  /// Output only. Runtime information of the Persistent Resource.
  public var resourceRuntime: Google_Cloud_Aiplatform_V1_ResourceRuntime {
    get {return _storage._resourceRuntime ?? Google_Cloud_Aiplatform_V1_ResourceRuntime()}
    set {_uniqueStorage()._resourceRuntime = newValue}
  }
  /// Returns true if `resourceRuntime` has been explicitly set.
  public var hasResourceRuntime: Bool {return _storage._resourceRuntime != nil}
  /// Clears the value of `resourceRuntime`. Subsequent reads from it will return its default value.
  public mutating func clearResourceRuntime() {_uniqueStorage()._resourceRuntime = nil}

  /// Optional. A list of names for the reserved IP ranges under the VPC network
  /// that can be used for this persistent resource.
  ///
  /// If set, we will deploy the persistent resource within the provided IP
  /// ranges. Otherwise, the persistent resource is deployed to any IP
  /// ranges under the provided VPC network.
  ///
  /// Example: ['vertex-ai-ip-range'].
  public var reservedIpRanges: [String] {
    get {return _storage._reservedIpRanges}
    set {_uniqueStorage()._reservedIpRanges = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the PersistentResource state.
  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// The PROVISIONING state indicates the persistent resources is being
    /// created.
    case provisioning // = 1

    /// The RUNNING state indicates the persistent resource is healthy and fully
    /// usable.
    case running // = 3

    /// The STOPPING state indicates the persistent resource is being deleted.
    case stopping // = 4

    /// The ERROR state indicates the persistent resource may be unusable.
    /// Details can be found in the `error` field.
    case error // = 5

    /// The REBOOTING state indicates the persistent resource is being rebooted
    /// (PR is not available right now but is expected to be ready again later).
    case rebooting // = 6

    /// The UPDATING state indicates the persistent resource is being updated.
    case updating // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .provisioning
      case 3: self = .running
      case 4: self = .stopping
      case 5: self = .error
      case 6: self = .rebooting
      case 7: self = .updating
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .provisioning: return 1
      case .running: return 3
      case .stopping: return 4
      case .error: return 5
      case .rebooting: return 6
      case .updating: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_PersistentResource.State] = [
      .unspecified,
      .provisioning,
      .running,
      .stopping,
      .error,
      .rebooting,
      .updating,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents the spec of a group of resources of the same type,
/// for example machine type, disk, and accelerators, in a PersistentResource.
public struct Google_Cloud_Aiplatform_V1_ResourcePool: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. The unique ID in a PersistentResource for referring to this
  /// resource pool. User can specify it if necessary. Otherwise, it's generated
  /// automatically.
  public var id: String = String()

  /// Required. Immutable. The specification of a single machine.
  public var machineSpec: Google_Cloud_Aiplatform_V1_MachineSpec {
    get {return _machineSpec ?? Google_Cloud_Aiplatform_V1_MachineSpec()}
    set {_machineSpec = newValue}
  }
  /// Returns true if `machineSpec` has been explicitly set.
  public var hasMachineSpec: Bool {return self._machineSpec != nil}
  /// Clears the value of `machineSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMachineSpec() {self._machineSpec = nil}

  /// Optional. The total number of machines to use for this resource pool.
  public var replicaCount: Int64 {
    get {return _replicaCount ?? 0}
    set {_replicaCount = newValue}
  }
  /// Returns true if `replicaCount` has been explicitly set.
  public var hasReplicaCount: Bool {return self._replicaCount != nil}
  /// Clears the value of `replicaCount`. Subsequent reads from it will return its default value.
  public mutating func clearReplicaCount() {self._replicaCount = nil}

  /// Optional. Disk spec for the machine in this node pool.
  public var diskSpec: Google_Cloud_Aiplatform_V1_DiskSpec {
    get {return _diskSpec ?? Google_Cloud_Aiplatform_V1_DiskSpec()}
    set {_diskSpec = newValue}
  }
  /// Returns true if `diskSpec` has been explicitly set.
  public var hasDiskSpec: Bool {return self._diskSpec != nil}
  /// Clears the value of `diskSpec`. Subsequent reads from it will return its default value.
  public mutating func clearDiskSpec() {self._diskSpec = nil}

  /// Output only. The number of machines currently in use by training jobs for
  /// this resource pool. Will replace idle_replica_count.
  public var usedReplicaCount: Int64 = 0

  /// Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
  public var autoscalingSpec: Google_Cloud_Aiplatform_V1_ResourcePool.AutoscalingSpec {
    get {return _autoscalingSpec ?? Google_Cloud_Aiplatform_V1_ResourcePool.AutoscalingSpec()}
    set {_autoscalingSpec = newValue}
  }
  /// Returns true if `autoscalingSpec` has been explicitly set.
  public var hasAutoscalingSpec: Bool {return self._autoscalingSpec != nil}
  /// Clears the value of `autoscalingSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAutoscalingSpec() {self._autoscalingSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The min/max number of replicas allowed if enabling autoscaling
  public struct AutoscalingSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. min replicas in the node pool,
    /// must be ≤ replica_count and < max_replica_count or will throw error.
    /// For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
    /// resource_pool to be 0 to match the OSS Ray
    /// behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters).
    /// As for Persistent Resource, the min_replica_count must be > 0, we added
    /// a corresponding validation inside
    /// CreatePersistentResourceRequestValidator.java.
    public var minReplicaCount: Int64 {
      get {return _minReplicaCount ?? 0}
      set {_minReplicaCount = newValue}
    }
    /// Returns true if `minReplicaCount` has been explicitly set.
    public var hasMinReplicaCount: Bool {return self._minReplicaCount != nil}
    /// Clears the value of `minReplicaCount`. Subsequent reads from it will return its default value.
    public mutating func clearMinReplicaCount() {self._minReplicaCount = nil}

    /// Optional. max replicas in the node pool,
    /// must be ≥ replica_count and > min_replica_count or will throw error
    public var maxReplicaCount: Int64 {
      get {return _maxReplicaCount ?? 0}
      set {_maxReplicaCount = newValue}
    }
    /// Returns true if `maxReplicaCount` has been explicitly set.
    public var hasMaxReplicaCount: Bool {return self._maxReplicaCount != nil}
    /// Clears the value of `maxReplicaCount`. Subsequent reads from it will return its default value.
    public mutating func clearMaxReplicaCount() {self._maxReplicaCount = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _minReplicaCount: Int64? = nil
    fileprivate var _maxReplicaCount: Int64? = nil
  }

  public init() {}

  fileprivate var _machineSpec: Google_Cloud_Aiplatform_V1_MachineSpec? = nil
  fileprivate var _replicaCount: Int64? = nil
  fileprivate var _diskSpec: Google_Cloud_Aiplatform_V1_DiskSpec? = nil
  fileprivate var _autoscalingSpec: Google_Cloud_Aiplatform_V1_ResourcePool.AutoscalingSpec? = nil
}

/// Configuration for the runtime on a PersistentResource instance, including
/// but not limited to:
///
/// * Service accounts used to run the workloads.
/// * Whether to make it a dedicated Ray Cluster.
public struct Google_Cloud_Aiplatform_V1_ResourceRuntimeSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Configure the use of workload identity on the PersistentResource
  public var serviceAccountSpec: Google_Cloud_Aiplatform_V1_ServiceAccountSpec {
    get {return _serviceAccountSpec ?? Google_Cloud_Aiplatform_V1_ServiceAccountSpec()}
    set {_serviceAccountSpec = newValue}
  }
  /// Returns true if `serviceAccountSpec` has been explicitly set.
  public var hasServiceAccountSpec: Bool {return self._serviceAccountSpec != nil}
  /// Clears the value of `serviceAccountSpec`. Subsequent reads from it will return its default value.
  public mutating func clearServiceAccountSpec() {self._serviceAccountSpec = nil}

  /// Optional. Ray cluster configuration.
  /// Required when creating a dedicated RayCluster on the PersistentResource.
  public var raySpec: Google_Cloud_Aiplatform_V1_RaySpec {
    get {return _raySpec ?? Google_Cloud_Aiplatform_V1_RaySpec()}
    set {_raySpec = newValue}
  }
  /// Returns true if `raySpec` has been explicitly set.
  public var hasRaySpec: Bool {return self._raySpec != nil}
  /// Clears the value of `raySpec`. Subsequent reads from it will return its default value.
  public mutating func clearRaySpec() {self._raySpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serviceAccountSpec: Google_Cloud_Aiplatform_V1_ServiceAccountSpec? = nil
  fileprivate var _raySpec: Google_Cloud_Aiplatform_V1_RaySpec? = nil
}

/// Configuration information for the Ray cluster.
/// For experimental launch, Ray cluster creation and Persistent
/// cluster creation are 1:1 mapping: We will provision all the nodes within the
/// Persistent cluster as Ray nodes.
public struct Google_Cloud_Aiplatform_V1_RaySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Default image for user to choose a preferred ML framework
  /// (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt
  /// images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// Either this or the resource_pool_images is required. Use this field if
  /// you need all the resource pools to have the same Ray image. Otherwise, use
  /// the {@code resource_pool_images} field.
  public var imageUri: String = String()

  /// Optional. Required if image_uri isn't set. A map of resource_pool_id to
  /// prebuild Ray image if user need to use different images for different
  /// head/worker pools. This map needs to cover all the resource pool ids.
  /// Example:
  /// {
  ///   "ray_head_node_pool": "head image"
  ///   "ray_worker_node_pool1": "worker image"
  ///   "ray_worker_node_pool2": "another worker image"
  /// }
  public var resourcePoolImages: Dictionary<String,String> = [:]

  /// Optional. This will be used to indicate which resource pool will serve as
  /// the Ray head node(the first node within that pool). Will use the machine
  /// from the first workerpool as the head node by default if this field isn't
  /// set.
  public var headNodeResourcePoolID: String = String()

  /// Optional. Ray metrics configurations.
  public var rayMetricSpec: Google_Cloud_Aiplatform_V1_RayMetricSpec {
    get {return _rayMetricSpec ?? Google_Cloud_Aiplatform_V1_RayMetricSpec()}
    set {_rayMetricSpec = newValue}
  }
  /// Returns true if `rayMetricSpec` has been explicitly set.
  public var hasRayMetricSpec: Bool {return self._rayMetricSpec != nil}
  /// Clears the value of `rayMetricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearRayMetricSpec() {self._rayMetricSpec = nil}

  /// Optional. OSS Ray logging configurations.
  public var rayLogsSpec: Google_Cloud_Aiplatform_V1_RayLogsSpec {
    get {return _rayLogsSpec ?? Google_Cloud_Aiplatform_V1_RayLogsSpec()}
    set {_rayLogsSpec = newValue}
  }
  /// Returns true if `rayLogsSpec` has been explicitly set.
  public var hasRayLogsSpec: Bool {return self._rayLogsSpec != nil}
  /// Clears the value of `rayLogsSpec`. Subsequent reads from it will return its default value.
  public mutating func clearRayLogsSpec() {self._rayLogsSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rayMetricSpec: Google_Cloud_Aiplatform_V1_RayMetricSpec? = nil
  fileprivate var _rayLogsSpec: Google_Cloud_Aiplatform_V1_RayLogsSpec? = nil
}

/// Persistent Cluster runtime information as output
public struct Google_Cloud_Aiplatform_V1_ResourceRuntime: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. URIs for user to connect to the Cluster.
  /// Example:
  /// {
  ///   "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
  ///   "RAY_DASHBOARD_URI": "ray-dashboard-address:8888"
  /// }
  public var accessUris: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the use of custom service account to run the workloads.
public struct Google_Cloud_Aiplatform_V1_ServiceAccountSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. If true, custom user-managed service account is enforced to run
  /// any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses
  /// the [Vertex AI Custom Code Service
  /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  public var enableCustomServiceAccount: Bool = false

  /// Optional. Required when all below conditions are met
  ///  * `enable_custom_service_account` is true;
  ///  * any runtime is specified via `ResourceRuntimeSpec` on creation time,
  ///    for example, Ray
  ///
  /// The users must have `iam.serviceAccounts.actAs` permission on this service
  /// account and then the specified runtime containers will run as it.
  ///
  /// Do not set this field if you want to submit jobs using custom service
  /// account to this PersistentResource after creation, but only specify the
  /// `service_account` inside the job.
  public var serviceAccount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the Ray metrics.
public struct Google_Cloud_Aiplatform_V1_RayMetricSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Flag to disable the Ray metrics collection.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the Ray OSS Logs.
public struct Google_Cloud_Aiplatform_V1_RayLogsSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_PersistentResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersistentResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    4: .standard(proto: "resource_pools"),
    5: .same(proto: "state"),
    6: .same(proto: "error"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "start_time"),
    9: .standard(proto: "update_time"),
    10: .same(proto: "labels"),
    11: .same(proto: "network"),
    12: .standard(proto: "encryption_spec"),
    13: .standard(proto: "resource_runtime_spec"),
    14: .standard(proto: "resource_runtime"),
    15: .standard(proto: "reserved_ip_ranges"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _resourcePools: [Google_Cloud_Aiplatform_V1_ResourcePool] = []
    var _state: Google_Cloud_Aiplatform_V1_PersistentResource.State = .unspecified
    var _error: Google_Rpc_Status? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _labels: Dictionary<String,String> = [:]
    var _network: String = String()
    var _encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec? = nil
    var _resourceRuntimeSpec: Google_Cloud_Aiplatform_V1_ResourceRuntimeSpec? = nil
    var _resourceRuntime: Google_Cloud_Aiplatform_V1_ResourceRuntime? = nil
    var _reservedIpRanges: [String] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _resourcePools = source._resourcePools
      _state = source._state
      _error = source._error
      _createTime = source._createTime
      _startTime = source._startTime
      _updateTime = source._updateTime
      _labels = source._labels
      _network = source._network
      _encryptionSpec = source._encryptionSpec
      _resourceRuntimeSpec = source._resourceRuntimeSpec
      _resourceRuntime = source._resourceRuntime
      _reservedIpRanges = source._reservedIpRanges
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._resourcePools) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._network) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._encryptionSpec) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._resourceRuntimeSpec) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._resourceRuntime) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._reservedIpRanges) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if !_storage._resourcePools.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._resourcePools, fieldNumber: 4)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 5)
      }
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 10)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 11)
      }
      try { if let v = _storage._encryptionSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._resourceRuntimeSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._resourceRuntime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._reservedIpRanges.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._reservedIpRanges, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PersistentResource, rhs: Google_Cloud_Aiplatform_V1_PersistentResource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._resourcePools != rhs_storage._resourcePools {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._encryptionSpec != rhs_storage._encryptionSpec {return false}
        if _storage._resourceRuntimeSpec != rhs_storage._resourceRuntimeSpec {return false}
        if _storage._resourceRuntime != rhs_storage._resourceRuntime {return false}
        if _storage._reservedIpRanges != rhs_storage._reservedIpRanges {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PersistentResource.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "PROVISIONING"),
    3: .same(proto: "RUNNING"),
    4: .same(proto: "STOPPING"),
    5: .same(proto: "ERROR"),
    6: .same(proto: "REBOOTING"),
    7: .same(proto: "UPDATING"),
  ]
}

extension Google_Cloud_Aiplatform_V1_ResourcePool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourcePool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "machine_spec"),
    3: .standard(proto: "replica_count"),
    4: .standard(proto: "disk_spec"),
    6: .standard(proto: "used_replica_count"),
    7: .standard(proto: "autoscaling_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._machineSpec) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._replicaCount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._diskSpec) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.usedReplicaCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._autoscalingSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._machineSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._replicaCount {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._diskSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.usedReplicaCount != 0 {
      try visitor.visitSingularInt64Field(value: self.usedReplicaCount, fieldNumber: 6)
    }
    try { if let v = self._autoscalingSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ResourcePool, rhs: Google_Cloud_Aiplatform_V1_ResourcePool) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._machineSpec != rhs._machineSpec {return false}
    if lhs._replicaCount != rhs._replicaCount {return false}
    if lhs._diskSpec != rhs._diskSpec {return false}
    if lhs.usedReplicaCount != rhs.usedReplicaCount {return false}
    if lhs._autoscalingSpec != rhs._autoscalingSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ResourcePool.AutoscalingSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ResourcePool.protoMessageName + ".AutoscalingSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_replica_count"),
    2: .standard(proto: "max_replica_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._minReplicaCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._maxReplicaCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minReplicaCount {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxReplicaCount {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ResourcePool.AutoscalingSpec, rhs: Google_Cloud_Aiplatform_V1_ResourcePool.AutoscalingSpec) -> Bool {
    if lhs._minReplicaCount != rhs._minReplicaCount {return false}
    if lhs._maxReplicaCount != rhs._maxReplicaCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ResourceRuntimeSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceRuntimeSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "service_account_spec"),
    1: .standard(proto: "ray_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._raySpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._serviceAccountSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._raySpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serviceAccountSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ResourceRuntimeSpec, rhs: Google_Cloud_Aiplatform_V1_ResourceRuntimeSpec) -> Bool {
    if lhs._serviceAccountSpec != rhs._serviceAccountSpec {return false}
    if lhs._raySpec != rhs._raySpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RaySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RaySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_uri"),
    6: .standard(proto: "resource_pool_images"),
    7: .standard(proto: "head_node_resource_pool_id"),
    8: .standard(proto: "ray_metric_spec"),
    10: .standard(proto: "ray_logs_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imageUri) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.resourcePoolImages) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.headNodeResourcePoolID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._rayMetricSpec) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._rayLogsSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.imageUri.isEmpty {
      try visitor.visitSingularStringField(value: self.imageUri, fieldNumber: 1)
    }
    if !self.resourcePoolImages.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.resourcePoolImages, fieldNumber: 6)
    }
    if !self.headNodeResourcePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.headNodeResourcePoolID, fieldNumber: 7)
    }
    try { if let v = self._rayMetricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._rayLogsSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RaySpec, rhs: Google_Cloud_Aiplatform_V1_RaySpec) -> Bool {
    if lhs.imageUri != rhs.imageUri {return false}
    if lhs.resourcePoolImages != rhs.resourcePoolImages {return false}
    if lhs.headNodeResourcePoolID != rhs.headNodeResourcePoolID {return false}
    if lhs._rayMetricSpec != rhs._rayMetricSpec {return false}
    if lhs._rayLogsSpec != rhs._rayLogsSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ResourceRuntime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceRuntime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_uris"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.accessUris) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessUris.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.accessUris, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ResourceRuntime, rhs: Google_Cloud_Aiplatform_V1_ResourceRuntime) -> Bool {
    if lhs.accessUris != rhs.accessUris {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ServiceAccountSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceAccountSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_custom_service_account"),
    2: .standard(proto: "service_account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableCustomServiceAccount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceAccount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableCustomServiceAccount != false {
      try visitor.visitSingularBoolField(value: self.enableCustomServiceAccount, fieldNumber: 1)
    }
    if !self.serviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ServiceAccountSpec, rhs: Google_Cloud_Aiplatform_V1_ServiceAccountSpec) -> Bool {
    if lhs.enableCustomServiceAccount != rhs.enableCustomServiceAccount {return false}
    if lhs.serviceAccount != rhs.serviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RayMetricSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RayMetricSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RayMetricSpec, rhs: Google_Cloud_Aiplatform_V1_RayMetricSpec) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RayLogsSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RayLogsSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RayLogsSpec, rhs: Google_Cloud_Aiplatform_V1_RayLogsSpec) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
