// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/match_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request message for
/// [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
public struct Google_Cloud_Aiplatform_V1_FindNeighborsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the index endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  public var indexEndpoint: String = String()

  /// The ID of the DeployedIndex that will serve the request. This request is
  /// sent to a specific IndexEndpoint, as per the IndexEndpoint.network. That
  /// IndexEndpoint also has IndexEndpoint.deployed_indexes, and each such index
  /// has a DeployedIndex.id field.
  /// The value of the field below must equal one of the DeployedIndex.id
  /// fields of the IndexEndpoint that is being called for this request.
  public var deployedIndexID: String = String()

  /// The list of queries.
  public var queries: [Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query] = []

  /// If set to true, the full datapoints (including all vector values and
  /// restricts) of the nearest neighbors are returned.
  /// Note that returning full datapoint will significantly increase the
  /// latency and cost of the query.
  public var returnFullDatapoint: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A query to find a number of the nearest neighbors (most similar vectors)
  /// of a vector.
  public struct Query: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ranking: Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.OneOf_Ranking? = nil

    /// Optional. Represents RRF algorithm that combines search results.
    public var rrf: Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.RRF {
      get {
        if case .rrf(let v)? = ranking {return v}
        return Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.RRF()
      }
      set {ranking = .rrf(newValue)}
    }

    /// Required. The datapoint/vector whose nearest neighbors should be searched
    /// for.
    public var datapoint: Google_Cloud_Aiplatform_V1_IndexDatapoint {
      get {return _datapoint ?? Google_Cloud_Aiplatform_V1_IndexDatapoint()}
      set {_datapoint = newValue}
    }
    /// Returns true if `datapoint` has been explicitly set.
    public var hasDatapoint: Bool {return self._datapoint != nil}
    /// Clears the value of `datapoint`. Subsequent reads from it will return its default value.
    public mutating func clearDatapoint() {self._datapoint = nil}

    /// The number of nearest neighbors to be retrieved from database for each
    /// query. If not set, will use the default from the service configuration
    /// (https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config).
    public var neighborCount: Int32 = 0

    /// Crowding is a constraint on a neighbor list produced by nearest neighbor
    /// search requiring that no more than some value k' of the k neighbors
    /// returned have the same value of crowding_attribute.
    /// It's used for improving result diversity.
    /// This field is the maximum number of matches with the same crowding tag.
    public var perCrowdingAttributeNeighborCount: Int32 = 0

    /// The number of neighbors to find via approximate search before
    /// exact reordering is performed. If not set, the default value from scam
    /// config is used; if set, this value must be > 0.
    public var approximateNeighborCount: Int32 = 0

    /// The fraction of the number of leaves to search, set at query time allows
    /// user to tune search performance. This value increase result in both
    /// search accuracy and latency increase. The value should be between 0.0
    /// and 1.0. If not set or set to 0.0, query uses the default value specified
    /// in
    /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
    public var fractionLeafNodesToSearchOverride: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Ranking: Equatable, Sendable {
      /// Optional. Represents RRF algorithm that combines search results.
      case rrf(Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.RRF)

    }

    /// Parameters for RRF algorithm that combines search results.
    public struct RRF: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Users can provide an alpha value to give more weight to dense
      /// vs sparse results. For example, if the alpha is 0, we only return
      /// sparse and if the alpha is 1, we only return dense.
      public var alpha: Float = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _datapoint: Google_Cloud_Aiplatform_V1_IndexDatapoint? = nil
  }

  public init() {}
}

/// The response message for
/// [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
public struct Google_Cloud_Aiplatform_V1_FindNeighborsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nearest neighbors of the query datapoints.
  public var nearestNeighbors: [Google_Cloud_Aiplatform_V1_FindNeighborsResponse.NearestNeighbors] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A neighbor of the query vector.
  public struct Neighbor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The datapoint of the neighbor.
    /// Note that full datapoints are returned only when "return_full_datapoint"
    /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
    /// fields are populated.
    public var datapoint: Google_Cloud_Aiplatform_V1_IndexDatapoint {
      get {return _datapoint ?? Google_Cloud_Aiplatform_V1_IndexDatapoint()}
      set {_datapoint = newValue}
    }
    /// Returns true if `datapoint` has been explicitly set.
    public var hasDatapoint: Bool {return self._datapoint != nil}
    /// Clears the value of `datapoint`. Subsequent reads from it will return its default value.
    public mutating func clearDatapoint() {self._datapoint = nil}

    /// The distance between the neighbor and the dense embedding query.
    public var distance: Double = 0

    /// The distance between the neighbor and the query sparse_embedding.
    public var sparseDistance: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _datapoint: Google_Cloud_Aiplatform_V1_IndexDatapoint? = nil
  }

  /// Nearest neighbors for one query.
  public struct NearestNeighbors: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the query datapoint.
    public var id: String = String()

    /// All its neighbors.
    public var neighbors: [Google_Cloud_Aiplatform_V1_FindNeighborsResponse.Neighbor] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// The request message for
/// [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
public struct Google_Cloud_Aiplatform_V1_ReadIndexDatapointsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the index endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  public var indexEndpoint: String = String()

  /// The ID of the DeployedIndex that will serve the request.
  public var deployedIndexID: String = String()

  /// IDs of the datapoints to be searched for.
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response message for
/// [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
public struct Google_Cloud_Aiplatform_V1_ReadIndexDatapointsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result list of datapoints.
  public var datapoints: [Google_Cloud_Aiplatform_V1_IndexDatapoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_FindNeighborsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindNeighborsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_endpoint"),
    2: .standard(proto: "deployed_index_id"),
    3: .same(proto: "queries"),
    4: .standard(proto: "return_full_datapoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexEndpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deployedIndexID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.returnFullDatapoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.indexEndpoint, fieldNumber: 1)
    }
    if !self.deployedIndexID.isEmpty {
      try visitor.visitSingularStringField(value: self.deployedIndexID, fieldNumber: 2)
    }
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 3)
    }
    if self.returnFullDatapoint != false {
      try visitor.visitSingularBoolField(value: self.returnFullDatapoint, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FindNeighborsRequest, rhs: Google_Cloud_Aiplatform_V1_FindNeighborsRequest) -> Bool {
    if lhs.indexEndpoint != rhs.indexEndpoint {return false}
    if lhs.deployedIndexID != rhs.deployedIndexID {return false}
    if lhs.queries != rhs.queries {return false}
    if lhs.returnFullDatapoint != rhs.returnFullDatapoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FindNeighborsRequest.protoMessageName + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "rrf"),
    1: .same(proto: "datapoint"),
    2: .standard(proto: "neighbor_count"),
    3: .standard(proto: "per_crowding_attribute_neighbor_count"),
    4: .standard(proto: "approximate_neighbor_count"),
    5: .standard(proto: "fraction_leaf_nodes_to_search_override"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._datapoint) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.neighborCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.perCrowdingAttributeNeighborCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.approximateNeighborCount) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.fractionLeafNodesToSearchOverride) }()
      case 6: try {
        var v: Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.RRF?
        var hadOneofValue = false
        if let current = self.ranking {
          hadOneofValue = true
          if case .rrf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ranking = .rrf(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._datapoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.neighborCount != 0 {
      try visitor.visitSingularInt32Field(value: self.neighborCount, fieldNumber: 2)
    }
    if self.perCrowdingAttributeNeighborCount != 0 {
      try visitor.visitSingularInt32Field(value: self.perCrowdingAttributeNeighborCount, fieldNumber: 3)
    }
    if self.approximateNeighborCount != 0 {
      try visitor.visitSingularInt32Field(value: self.approximateNeighborCount, fieldNumber: 4)
    }
    if self.fractionLeafNodesToSearchOverride.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fractionLeafNodesToSearchOverride, fieldNumber: 5)
    }
    try { if case .rrf(let v)? = self.ranking {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query, rhs: Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query) -> Bool {
    if lhs.ranking != rhs.ranking {return false}
    if lhs._datapoint != rhs._datapoint {return false}
    if lhs.neighborCount != rhs.neighborCount {return false}
    if lhs.perCrowdingAttributeNeighborCount != rhs.perCrowdingAttributeNeighborCount {return false}
    if lhs.approximateNeighborCount != rhs.approximateNeighborCount {return false}
    if lhs.fractionLeafNodesToSearchOverride != rhs.fractionLeafNodesToSearchOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.RRF: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.protoMessageName + ".RRF"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.RRF, rhs: Google_Cloud_Aiplatform_V1_FindNeighborsRequest.Query.RRF) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FindNeighborsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindNeighborsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nearest_neighbors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nearestNeighbors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nearestNeighbors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nearestNeighbors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FindNeighborsResponse, rhs: Google_Cloud_Aiplatform_V1_FindNeighborsResponse) -> Bool {
    if lhs.nearestNeighbors != rhs.nearestNeighbors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FindNeighborsResponse.Neighbor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FindNeighborsResponse.protoMessageName + ".Neighbor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datapoint"),
    2: .same(proto: "distance"),
    3: .standard(proto: "sparse_distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._datapoint) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.distance) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.sparseDistance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._datapoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.distance.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.distance, fieldNumber: 2)
    }
    if self.sparseDistance.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.sparseDistance, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FindNeighborsResponse.Neighbor, rhs: Google_Cloud_Aiplatform_V1_FindNeighborsResponse.Neighbor) -> Bool {
    if lhs._datapoint != rhs._datapoint {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.sparseDistance != rhs.sparseDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FindNeighborsResponse.NearestNeighbors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FindNeighborsResponse.protoMessageName + ".NearestNeighbors"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "neighbors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.neighbors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.neighbors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.neighbors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FindNeighborsResponse.NearestNeighbors, rhs: Google_Cloud_Aiplatform_V1_FindNeighborsResponse.NearestNeighbors) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.neighbors != rhs.neighbors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ReadIndexDatapointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadIndexDatapointsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_endpoint"),
    2: .standard(proto: "deployed_index_id"),
    3: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexEndpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deployedIndexID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.indexEndpoint, fieldNumber: 1)
    }
    if !self.deployedIndexID.isEmpty {
      try visitor.visitSingularStringField(value: self.deployedIndexID, fieldNumber: 2)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ReadIndexDatapointsRequest, rhs: Google_Cloud_Aiplatform_V1_ReadIndexDatapointsRequest) -> Bool {
    if lhs.indexEndpoint != rhs.indexEndpoint {return false}
    if lhs.deployedIndexID != rhs.deployedIndexID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ReadIndexDatapointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadIndexDatapointsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datapoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.datapoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datapoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datapoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ReadIndexDatapointsResponse, rhs: Google_Cloud_Aiplatform_V1_ReadIndexDatapointsResponse) -> Bool {
    if lhs.datapoints != rhs.datapoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
