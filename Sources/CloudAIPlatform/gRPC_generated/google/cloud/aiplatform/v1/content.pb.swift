// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/content.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Harm categories that will block the content.
public enum Google_Cloud_Aiplatform_V1_HarmCategory: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The harm category is unspecified.
  case unspecified // = 0

  /// The harm category is hate speech.
  case hateSpeech // = 1

  /// The harm category is dangerous content.
  case dangerousContent // = 2

  /// The harm category is harassment.
  case harassment // = 3

  /// The harm category is sexually explicit content.
  case sexuallyExplicit // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .hateSpeech
    case 2: self = .dangerousContent
    case 3: self = .harassment
    case 4: self = .sexuallyExplicit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .hateSpeech: return 1
    case .dangerousContent: return 2
    case .harassment: return 3
    case .sexuallyExplicit: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Cloud_Aiplatform_V1_HarmCategory] = [
    .unspecified,
    .hateSpeech,
    .dangerousContent,
    .harassment,
    .sexuallyExplicit,
  ]

}

/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the `Content`
/// and a `parts` field containing multi-part data that contains the content of
/// the message turn.
public struct Google_Cloud_Aiplatform_V1_Content: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The producer of the content. Must be either 'user' or 'model'.
  ///
  /// Useful to set for multi-turn conversations, otherwise can be left blank
  /// or unset.
  public var role: String = String()

  /// Required. Ordered `Parts` that constitute a single message. Parts may have
  /// different IANA MIME types.
  public var parts: [Google_Cloud_Aiplatform_V1_Part] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can only
/// contain one of the accepted types in `Part.data`.
///
/// A `Part` must have a fixed IANA MIME type identifying the type and subtype
/// of the media if `inline_data` or `file_data` field is filled with raw bytes.
public struct Google_Cloud_Aiplatform_V1_Part: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Google_Cloud_Aiplatform_V1_Part.OneOf_Data? = nil

  /// Optional. Text part (can be code).
  public var text: String {
    get {
      if case .text(let v)? = data {return v}
      return String()
    }
    set {data = .text(newValue)}
  }

  /// Optional. Inlined bytes data.
  public var inlineData: Google_Cloud_Aiplatform_V1_Blob {
    get {
      if case .inlineData(let v)? = data {return v}
      return Google_Cloud_Aiplatform_V1_Blob()
    }
    set {data = .inlineData(newValue)}
  }

  /// Optional. URI based data.
  public var fileData: Google_Cloud_Aiplatform_V1_FileData {
    get {
      if case .fileData(let v)? = data {return v}
      return Google_Cloud_Aiplatform_V1_FileData()
    }
    set {data = .fileData(newValue)}
  }

  /// Optional. A predicted [FunctionCall] returned from the model that
  /// contains a string representing the [FunctionDeclaration.name] with the
  /// parameters and their values.
  public var functionCall: Google_Cloud_Aiplatform_V1_FunctionCall {
    get {
      if case .functionCall(let v)? = data {return v}
      return Google_Cloud_Aiplatform_V1_FunctionCall()
    }
    set {data = .functionCall(newValue)}
  }

  /// Optional. The result output of a [FunctionCall] that contains a string
  /// representing the [FunctionDeclaration.name] and a structured JSON object
  /// containing any output from the function call. It is used as context to
  /// the model.
  public var functionResponse: Google_Cloud_Aiplatform_V1_FunctionResponse {
    get {
      if case .functionResponse(let v)? = data {return v}
      return Google_Cloud_Aiplatform_V1_FunctionResponse()
    }
    set {data = .functionResponse(newValue)}
  }

  public var metadata: Google_Cloud_Aiplatform_V1_Part.OneOf_Metadata? = nil

  /// Optional. Video metadata. The metadata should only be specified while the
  /// video data is presented in inline_data or file_data.
  public var videoMetadata: Google_Cloud_Aiplatform_V1_VideoMetadata {
    get {
      if case .videoMetadata(let v)? = metadata {return v}
      return Google_Cloud_Aiplatform_V1_VideoMetadata()
    }
    set {metadata = .videoMetadata(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    /// Optional. Text part (can be code).
    case text(String)
    /// Optional. Inlined bytes data.
    case inlineData(Google_Cloud_Aiplatform_V1_Blob)
    /// Optional. URI based data.
    case fileData(Google_Cloud_Aiplatform_V1_FileData)
    /// Optional. A predicted [FunctionCall] returned from the model that
    /// contains a string representing the [FunctionDeclaration.name] with the
    /// parameters and their values.
    case functionCall(Google_Cloud_Aiplatform_V1_FunctionCall)
    /// Optional. The result output of a [FunctionCall] that contains a string
    /// representing the [FunctionDeclaration.name] and a structured JSON object
    /// containing any output from the function call. It is used as context to
    /// the model.
    case functionResponse(Google_Cloud_Aiplatform_V1_FunctionResponse)

  }

  public enum OneOf_Metadata: Equatable, Sendable {
    /// Optional. Video metadata. The metadata should only be specified while the
    /// video data is presented in inline_data or file_data.
    case videoMetadata(Google_Cloud_Aiplatform_V1_VideoMetadata)

  }

  public init() {}
}

/// Content blob.
///
/// It's preferred to send as [text][google.cloud.aiplatform.v1.Part.text]
/// directly rather than raw bytes.
public struct Google_Cloud_Aiplatform_V1_Blob: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The IANA standard MIME type of the source data.
  public var mimeType: String = String()

  /// Required. Raw bytes.
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// URI based data.
public struct Google_Cloud_Aiplatform_V1_FileData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The IANA standard MIME type of the source data.
  public var mimeType: String = String()

  /// Required. URI.
  public var fileUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata describes the input video content.
public struct Google_Cloud_Aiplatform_V1_VideoMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The start offset of the video.
  public var startOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startOffset = newValue}
  }
  /// Returns true if `startOffset` has been explicitly set.
  public var hasStartOffset: Bool {return self._startOffset != nil}
  /// Clears the value of `startOffset`. Subsequent reads from it will return its default value.
  public mutating func clearStartOffset() {self._startOffset = nil}

  /// Optional. The end offset of the video.
  public var endOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _endOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_endOffset = newValue}
  }
  /// Returns true if `endOffset` has been explicitly set.
  public var hasEndOffset: Bool {return self._endOffset != nil}
  /// Clears the value of `endOffset`. Subsequent reads from it will return its default value.
  public mutating func clearEndOffset() {self._endOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _endOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Generation config.
public struct Google_Cloud_Aiplatform_V1_GenerationConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Controls the randomness of predictions.
  public var temperature: Float {
    get {return _temperature ?? 0}
    set {_temperature = newValue}
  }
  /// Returns true if `temperature` has been explicitly set.
  public var hasTemperature: Bool {return self._temperature != nil}
  /// Clears the value of `temperature`. Subsequent reads from it will return its default value.
  public mutating func clearTemperature() {self._temperature = nil}

  /// Optional. If specified, nucleus sampling will be used.
  public var topP: Float {
    get {return _topP ?? 0}
    set {_topP = newValue}
  }
  /// Returns true if `topP` has been explicitly set.
  public var hasTopP: Bool {return self._topP != nil}
  /// Clears the value of `topP`. Subsequent reads from it will return its default value.
  public mutating func clearTopP() {self._topP = nil}

  /// Optional. If specified, top-k sampling will be used.
  public var topK: Float {
    get {return _topK ?? 0}
    set {_topK = newValue}
  }
  /// Returns true if `topK` has been explicitly set.
  public var hasTopK: Bool {return self._topK != nil}
  /// Clears the value of `topK`. Subsequent reads from it will return its default value.
  public mutating func clearTopK() {self._topK = nil}

  /// Optional. Number of candidates to generate.
  public var candidateCount: Int32 {
    get {return _candidateCount ?? 0}
    set {_candidateCount = newValue}
  }
  /// Returns true if `candidateCount` has been explicitly set.
  public var hasCandidateCount: Bool {return self._candidateCount != nil}
  /// Clears the value of `candidateCount`. Subsequent reads from it will return its default value.
  public mutating func clearCandidateCount() {self._candidateCount = nil}

  /// Optional. The maximum number of output tokens to generate per message.
  public var maxOutputTokens: Int32 {
    get {return _maxOutputTokens ?? 0}
    set {_maxOutputTokens = newValue}
  }
  /// Returns true if `maxOutputTokens` has been explicitly set.
  public var hasMaxOutputTokens: Bool {return self._maxOutputTokens != nil}
  /// Clears the value of `maxOutputTokens`. Subsequent reads from it will return its default value.
  public mutating func clearMaxOutputTokens() {self._maxOutputTokens = nil}

  /// Optional. Stop sequences.
  public var stopSequences: [String] = []

  /// Optional. Positive penalties.
  public var presencePenalty: Float {
    get {return _presencePenalty ?? 0}
    set {_presencePenalty = newValue}
  }
  /// Returns true if `presencePenalty` has been explicitly set.
  public var hasPresencePenalty: Bool {return self._presencePenalty != nil}
  /// Clears the value of `presencePenalty`. Subsequent reads from it will return its default value.
  public mutating func clearPresencePenalty() {self._presencePenalty = nil}

  /// Optional. Frequency penalties.
  public var frequencyPenalty: Float {
    get {return _frequencyPenalty ?? 0}
    set {_frequencyPenalty = newValue}
  }
  /// Returns true if `frequencyPenalty` has been explicitly set.
  public var hasFrequencyPenalty: Bool {return self._frequencyPenalty != nil}
  /// Clears the value of `frequencyPenalty`. Subsequent reads from it will return its default value.
  public mutating func clearFrequencyPenalty() {self._frequencyPenalty = nil}

  /// Optional. Seed.
  public var seed: Int32 {
    get {return _seed ?? 0}
    set {_seed = newValue}
  }
  /// Returns true if `seed` has been explicitly set.
  public var hasSeed: Bool {return self._seed != nil}
  /// Clears the value of `seed`. Subsequent reads from it will return its default value.
  public mutating func clearSeed() {self._seed = nil}

  /// Optional. Output response mimetype of the generated candidate text.
  /// Supported mimetype:
  /// - `text/plain`: (default) Text output.
  /// - `application/json`: JSON response in the candidates.
  /// The model needs to be prompted to output the appropriate response type,
  /// otherwise the behavior is undefined.
  /// This is a preview feature.
  public var responseMimeType: String = String()

  /// Optional. The `Schema` object allows the definition of input and output
  /// data types. These types can be objects, but also primitives and arrays.
  /// Represents a select subset of an [OpenAPI 3.0 schema
  /// object](https://spec.openapis.org/oas/v3.0.3#schema).
  /// If set, a compatible response_mime_type must also be set.
  /// Compatible mimetypes:
  /// `application/json`: Schema for JSON response.
  public var responseSchema: Google_Cloud_Aiplatform_V1_Schema {
    get {return _responseSchema ?? Google_Cloud_Aiplatform_V1_Schema()}
    set {_responseSchema = newValue}
  }
  /// Returns true if `responseSchema` has been explicitly set.
  public var hasResponseSchema: Bool {return self._responseSchema != nil}
  /// Clears the value of `responseSchema`. Subsequent reads from it will return its default value.
  public mutating func clearResponseSchema() {self._responseSchema = nil}

  /// Optional. Routing configuration.
  public var routingConfig: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig {
    get {return _routingConfig ?? Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig()}
    set {_routingConfig = newValue}
  }
  /// Returns true if `routingConfig` has been explicitly set.
  public var hasRoutingConfig: Bool {return self._routingConfig != nil}
  /// Clears the value of `routingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRoutingConfig() {self._routingConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The configuration for routing the request to a specific model.
  public struct RoutingConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Routing mode.
    public var routingConfig: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.OneOf_RoutingConfig? = nil

    /// Automated routing.
    public var autoMode: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode {
      get {
        if case .autoMode(let v)? = routingConfig {return v}
        return Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode()
      }
      set {routingConfig = .autoMode(newValue)}
    }

    /// Manual routing.
    public var manualMode: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.ManualRoutingMode {
      get {
        if case .manualMode(let v)? = routingConfig {return v}
        return Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.ManualRoutingMode()
      }
      set {routingConfig = .manualMode(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Routing mode.
    public enum OneOf_RoutingConfig: Equatable, Sendable {
      /// Automated routing.
      case autoMode(Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode)
      /// Manual routing.
      case manualMode(Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.ManualRoutingMode)

    }

    /// When automated routing is specified, the routing will be determined by
    /// the pretrained routing model and customer provided model routing
    /// preference.
    public struct AutoRoutingMode: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The model routing preference.
      public var modelRoutingPreference: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode.ModelRoutingPreference {
        get {return _modelRoutingPreference ?? .unknown}
        set {_modelRoutingPreference = newValue}
      }
      /// Returns true if `modelRoutingPreference` has been explicitly set.
      public var hasModelRoutingPreference: Bool {return self._modelRoutingPreference != nil}
      /// Clears the value of `modelRoutingPreference`. Subsequent reads from it will return its default value.
      public mutating func clearModelRoutingPreference() {self._modelRoutingPreference = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The model routing preference.
      public enum ModelRoutingPreference: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Unspecified model routing preference.
        case unknown // = 0

        /// Prefer higher quality over low cost.
        case prioritizeQuality // = 1

        /// Balanced model routing preference.
        case balanced // = 2

        /// Prefer lower cost over higher quality.
        case prioritizeCost // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .unknown
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .prioritizeQuality
          case 2: self = .balanced
          case 3: self = .prioritizeCost
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .prioritizeQuality: return 1
          case .balanced: return 2
          case .prioritizeCost: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode.ModelRoutingPreference] = [
          .unknown,
          .prioritizeQuality,
          .balanced,
          .prioritizeCost,
        ]

      }

      public init() {}

      fileprivate var _modelRoutingPreference: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode.ModelRoutingPreference? = nil
    }

    /// When manual routing is set, the specified model will be used directly.
    public struct ManualRoutingMode: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The model name to use. Only the public LLM models are accepted. e.g.
      /// 'gemini-1.5-pro-001'.
      public var modelName: String {
        get {return _modelName ?? String()}
        set {_modelName = newValue}
      }
      /// Returns true if `modelName` has been explicitly set.
      public var hasModelName: Bool {return self._modelName != nil}
      /// Clears the value of `modelName`. Subsequent reads from it will return its default value.
      public mutating func clearModelName() {self._modelName = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _modelName: String? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _temperature: Float? = nil
  fileprivate var _topP: Float? = nil
  fileprivate var _topK: Float? = nil
  fileprivate var _candidateCount: Int32? = nil
  fileprivate var _maxOutputTokens: Int32? = nil
  fileprivate var _presencePenalty: Float? = nil
  fileprivate var _frequencyPenalty: Float? = nil
  fileprivate var _seed: Int32? = nil
  fileprivate var _responseSchema: Google_Cloud_Aiplatform_V1_Schema? = nil
  fileprivate var _routingConfig: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig? = nil
}

/// Safety settings.
public struct Google_Cloud_Aiplatform_V1_SafetySetting: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Harm category.
  public var category: Google_Cloud_Aiplatform_V1_HarmCategory = .unspecified

  /// Required. The harm block threshold.
  public var threshold: Google_Cloud_Aiplatform_V1_SafetySetting.HarmBlockThreshold = .unspecified

  /// Optional. Specify if the threshold is used for probability or severity
  /// score. If not specified, the threshold is used for probability score.
  public var method: Google_Cloud_Aiplatform_V1_SafetySetting.HarmBlockMethod = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Probability based thresholds levels for blocking.
  public enum HarmBlockThreshold: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Unspecified harm block threshold.
    case unspecified // = 0

    /// Block low threshold and above (i.e. block more).
    case blockLowAndAbove // = 1

    /// Block medium threshold and above.
    case blockMediumAndAbove // = 2

    /// Block only high threshold (i.e. block less).
    case blockOnlyHigh // = 3

    /// Block none.
    case blockNone // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .blockLowAndAbove
      case 2: self = .blockMediumAndAbove
      case 3: self = .blockOnlyHigh
      case 4: self = .blockNone
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .blockLowAndAbove: return 1
      case .blockMediumAndAbove: return 2
      case .blockOnlyHigh: return 3
      case .blockNone: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_SafetySetting.HarmBlockThreshold] = [
      .unspecified,
      .blockLowAndAbove,
      .blockMediumAndAbove,
      .blockOnlyHigh,
      .blockNone,
    ]

  }

  /// Probability vs severity.
  public enum HarmBlockMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The harm block method is unspecified.
    case unspecified // = 0

    /// The harm block method uses both probability and severity scores.
    case severity // = 1

    /// The harm block method uses the probability score.
    case probability // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .severity
      case 2: self = .probability
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .severity: return 1
      case .probability: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_SafetySetting.HarmBlockMethod] = [
      .unspecified,
      .severity,
      .probability,
    ]

  }

  public init() {}
}

/// Safety rating corresponding to the generated content.
public struct Google_Cloud_Aiplatform_V1_SafetyRating: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Harm category.
  public var category: Google_Cloud_Aiplatform_V1_HarmCategory = .unspecified

  /// Output only. Harm probability levels in the content.
  public var probability: Google_Cloud_Aiplatform_V1_SafetyRating.HarmProbability = .unspecified

  /// Output only. Harm probability score.
  public var probabilityScore: Float = 0

  /// Output only. Harm severity levels in the content.
  public var severity: Google_Cloud_Aiplatform_V1_SafetyRating.HarmSeverity = .unspecified

  /// Output only. Harm severity score.
  public var severityScore: Float = 0

  /// Output only. Indicates whether the content was filtered out because of this
  /// rating.
  public var blocked: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Harm probability levels in the content.
  public enum HarmProbability: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Harm probability unspecified.
    case unspecified // = 0

    /// Negligible level of harm.
    case negligible // = 1

    /// Low level of harm.
    case low // = 2

    /// Medium level of harm.
    case medium // = 3

    /// High level of harm.
    case high // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .negligible
      case 2: self = .low
      case 3: self = .medium
      case 4: self = .high
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .negligible: return 1
      case .low: return 2
      case .medium: return 3
      case .high: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_SafetyRating.HarmProbability] = [
      .unspecified,
      .negligible,
      .low,
      .medium,
      .high,
    ]

  }

  /// Harm severity levels.
  public enum HarmSeverity: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Harm severity unspecified.
    case unspecified // = 0

    /// Negligible level of harm severity.
    case negligible // = 1

    /// Low level of harm severity.
    case low // = 2

    /// Medium level of harm severity.
    case medium // = 3

    /// High level of harm severity.
    case high // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .negligible
      case 2: self = .low
      case 3: self = .medium
      case 4: self = .high
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .negligible: return 1
      case .low: return 2
      case .medium: return 3
      case .high: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_SafetyRating.HarmSeverity] = [
      .unspecified,
      .negligible,
      .low,
      .medium,
      .high,
    ]

  }

  public init() {}
}

/// A collection of source attributions for a piece of content.
public struct Google_Cloud_Aiplatform_V1_CitationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. List of citations.
  public var citations: [Google_Cloud_Aiplatform_V1_Citation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Source attributions for content.
public struct Google_Cloud_Aiplatform_V1_Citation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Start index into the content.
  public var startIndex: Int32 = 0

  /// Output only. End index into the content.
  public var endIndex: Int32 = 0

  /// Output only. Url reference of the attribution.
  public var uri: String = String()

  /// Output only. Title of the attribution.
  public var title: String = String()

  /// Output only. License of the attribution.
  public var license: String = String()

  /// Output only. Publication date of the attribution.
  public var publicationDate: Google_Type_Date {
    get {return _publicationDate ?? Google_Type_Date()}
    set {_publicationDate = newValue}
  }
  /// Returns true if `publicationDate` has been explicitly set.
  public var hasPublicationDate: Bool {return self._publicationDate != nil}
  /// Clears the value of `publicationDate`. Subsequent reads from it will return its default value.
  public mutating func clearPublicationDate() {self._publicationDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicationDate: Google_Type_Date? = nil
}

/// A response candidate generated from the model.
public struct Google_Cloud_Aiplatform_V1_Candidate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Index of the candidate.
  public var index: Int32 = 0

  /// Output only. Content parts of the candidate.
  public var content: Google_Cloud_Aiplatform_V1_Content {
    get {return _content ?? Google_Cloud_Aiplatform_V1_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  /// Output only. Confidence score of the candidate.
  public var score: Double = 0

  /// Output only. Average log probability score of the candidate.
  public var avgLogprobs: Double = 0

  /// Output only. The reason why the model stopped generating tokens.
  /// If empty, the model has not stopped generating the tokens.
  public var finishReason: Google_Cloud_Aiplatform_V1_Candidate.FinishReason = .unspecified

  /// Output only. List of ratings for the safety of a response candidate.
  ///
  /// There is at most one rating per category.
  public var safetyRatings: [Google_Cloud_Aiplatform_V1_SafetyRating] = []

  /// Output only. Describes the reason the mode stopped generating tokens in
  /// more detail. This is only filled when `finish_reason` is set.
  public var finishMessage: String {
    get {return _finishMessage ?? String()}
    set {_finishMessage = newValue}
  }
  /// Returns true if `finishMessage` has been explicitly set.
  public var hasFinishMessage: Bool {return self._finishMessage != nil}
  /// Clears the value of `finishMessage`. Subsequent reads from it will return its default value.
  public mutating func clearFinishMessage() {self._finishMessage = nil}

  /// Output only. Source attribution of the generated content.
  public var citationMetadata: Google_Cloud_Aiplatform_V1_CitationMetadata {
    get {return _citationMetadata ?? Google_Cloud_Aiplatform_V1_CitationMetadata()}
    set {_citationMetadata = newValue}
  }
  /// Returns true if `citationMetadata` has been explicitly set.
  public var hasCitationMetadata: Bool {return self._citationMetadata != nil}
  /// Clears the value of `citationMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearCitationMetadata() {self._citationMetadata = nil}

  /// Output only. Metadata specifies sources used to ground generated content.
  public var groundingMetadata: Google_Cloud_Aiplatform_V1_GroundingMetadata {
    get {return _groundingMetadata ?? Google_Cloud_Aiplatform_V1_GroundingMetadata()}
    set {_groundingMetadata = newValue}
  }
  /// Returns true if `groundingMetadata` has been explicitly set.
  public var hasGroundingMetadata: Bool {return self._groundingMetadata != nil}
  /// Clears the value of `groundingMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGroundingMetadata() {self._groundingMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The reason why the model stopped generating tokens.
  /// If empty, the model has not stopped generating the tokens.
  public enum FinishReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The finish reason is unspecified.
    case unspecified // = 0

    /// Token generation reached a natural stopping point or a configured stop
    /// sequence.
    case stop // = 1

    /// Token generation reached the configured maximum output tokens.
    case maxTokens // = 2

    /// Token generation stopped because the content potentially contains safety
    /// violations. NOTE: When streaming,
    /// [content][google.cloud.aiplatform.v1.Candidate.content] is empty if
    /// content filters blocks the output.
    case safety // = 3

    /// Token generation stopped because the content potentially contains
    /// copyright violations.
    case recitation // = 4

    /// All other reasons that stopped the token generation.
    case other // = 5

    /// Token generation stopped because the content contains forbidden terms.
    case blocklist // = 6

    /// Token generation stopped for potentially containing prohibited content.
    case prohibitedContent // = 7

    /// Token generation stopped because the content potentially contains
    /// Sensitive Personally Identifiable Information (SPII).
    case spii // = 8

    /// The function call generated by the model is invalid.
    case malformedFunctionCall // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .stop
      case 2: self = .maxTokens
      case 3: self = .safety
      case 4: self = .recitation
      case 5: self = .other
      case 6: self = .blocklist
      case 7: self = .prohibitedContent
      case 8: self = .spii
      case 9: self = .malformedFunctionCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .stop: return 1
      case .maxTokens: return 2
      case .safety: return 3
      case .recitation: return 4
      case .other: return 5
      case .blocklist: return 6
      case .prohibitedContent: return 7
      case .spii: return 8
      case .malformedFunctionCall: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Candidate.FinishReason] = [
      .unspecified,
      .stop,
      .maxTokens,
      .safety,
      .recitation,
      .other,
      .blocklist,
      .prohibitedContent,
      .spii,
      .malformedFunctionCall,
    ]

  }

  public init() {}

  fileprivate var _content: Google_Cloud_Aiplatform_V1_Content? = nil
  fileprivate var _finishMessage: String? = nil
  fileprivate var _citationMetadata: Google_Cloud_Aiplatform_V1_CitationMetadata? = nil
  fileprivate var _groundingMetadata: Google_Cloud_Aiplatform_V1_GroundingMetadata? = nil
}

/// Segment of the content.
public struct Google_Cloud_Aiplatform_V1_Segment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The index of a Part object within its parent Content object.
  public var partIndex: Int32 = 0

  /// Output only. Start index in the given Part, measured in bytes. Offset from
  /// the start of the Part, inclusive, starting at zero.
  public var startIndex: Int32 = 0

  /// Output only. End index in the given Part, measured in bytes. Offset from
  /// the start of the Part, exclusive, starting at zero.
  public var endIndex: Int32 = 0

  /// Output only. The text corresponding to the segment from the response.
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Grounding chunk.
public struct Google_Cloud_Aiplatform_V1_GroundingChunk: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Chunk type.
  public var chunkType: Google_Cloud_Aiplatform_V1_GroundingChunk.OneOf_ChunkType? = nil

  /// Grounding chunk from the web.
  public var web: Google_Cloud_Aiplatform_V1_GroundingChunk.Web {
    get {
      if case .web(let v)? = chunkType {return v}
      return Google_Cloud_Aiplatform_V1_GroundingChunk.Web()
    }
    set {chunkType = .web(newValue)}
  }

  /// Grounding chunk from context retrieved by the retrieval tools.
  public var retrievedContext: Google_Cloud_Aiplatform_V1_GroundingChunk.RetrievedContext {
    get {
      if case .retrievedContext(let v)? = chunkType {return v}
      return Google_Cloud_Aiplatform_V1_GroundingChunk.RetrievedContext()
    }
    set {chunkType = .retrievedContext(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Chunk type.
  public enum OneOf_ChunkType: Equatable, Sendable {
    /// Grounding chunk from the web.
    case web(Google_Cloud_Aiplatform_V1_GroundingChunk.Web)
    /// Grounding chunk from context retrieved by the retrieval tools.
    case retrievedContext(Google_Cloud_Aiplatform_V1_GroundingChunk.RetrievedContext)

  }

  /// Chunk from the web.
  public struct Web: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// URI reference of the chunk.
    public var uri: String {
      get {return _uri ?? String()}
      set {_uri = newValue}
    }
    /// Returns true if `uri` has been explicitly set.
    public var hasUri: Bool {return self._uri != nil}
    /// Clears the value of `uri`. Subsequent reads from it will return its default value.
    public mutating func clearUri() {self._uri = nil}

    /// Title of the chunk.
    public var title: String {
      get {return _title ?? String()}
      set {_title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    public var hasTitle: Bool {return self._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    public mutating func clearTitle() {self._title = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uri: String? = nil
    fileprivate var _title: String? = nil
  }

  /// Chunk from context retrieved by the retrieval tools.
  public struct RetrievedContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// URI reference of the attribution.
    public var uri: String {
      get {return _uri ?? String()}
      set {_uri = newValue}
    }
    /// Returns true if `uri` has been explicitly set.
    public var hasUri: Bool {return self._uri != nil}
    /// Clears the value of `uri`. Subsequent reads from it will return its default value.
    public mutating func clearUri() {self._uri = nil}

    /// Title of the attribution.
    public var title: String {
      get {return _title ?? String()}
      set {_title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    public var hasTitle: Bool {return self._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    public mutating func clearTitle() {self._title = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uri: String? = nil
    fileprivate var _title: String? = nil
  }

  public init() {}
}

/// Grounding support.
public struct Google_Cloud_Aiplatform_V1_GroundingSupport: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Segment of the content this support belongs to.
  public var segment: Google_Cloud_Aiplatform_V1_Segment {
    get {return _segment ?? Google_Cloud_Aiplatform_V1_Segment()}
    set {_segment = newValue}
  }
  /// Returns true if `segment` has been explicitly set.
  public var hasSegment: Bool {return self._segment != nil}
  /// Clears the value of `segment`. Subsequent reads from it will return its default value.
  public mutating func clearSegment() {self._segment = nil}

  /// A list of indices (into 'grounding_chunk') specifying the
  /// citations associated with the claim. For instance [1,3,4] means
  /// that grounding_chunk[1], grounding_chunk[3],
  /// grounding_chunk[4] are the retrieved content attributed to the claim.
  public var groundingChunkIndices: [Int32] = []

  /// Confidence score of the support references. Ranges from 0 to 1. 1 is the
  /// most confident. This list must have the same size as the
  /// grounding_chunk_indices.
  public var confidenceScores: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _segment: Google_Cloud_Aiplatform_V1_Segment? = nil
}

/// Metadata returned to client when grounding is enabled.
public struct Google_Cloud_Aiplatform_V1_GroundingMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Web search queries for the following-up web search.
  public var webSearchQueries: [String] = []

  /// Optional. Google search entry for the following-up web searches.
  public var searchEntryPoint: Google_Cloud_Aiplatform_V1_SearchEntryPoint {
    get {return _searchEntryPoint ?? Google_Cloud_Aiplatform_V1_SearchEntryPoint()}
    set {_searchEntryPoint = newValue}
  }
  /// Returns true if `searchEntryPoint` has been explicitly set.
  public var hasSearchEntryPoint: Bool {return self._searchEntryPoint != nil}
  /// Clears the value of `searchEntryPoint`. Subsequent reads from it will return its default value.
  public mutating func clearSearchEntryPoint() {self._searchEntryPoint = nil}

  /// List of supporting references retrieved from specified grounding source.
  public var groundingChunks: [Google_Cloud_Aiplatform_V1_GroundingChunk] = []

  /// Optional. List of grounding support.
  public var groundingSupports: [Google_Cloud_Aiplatform_V1_GroundingSupport] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _searchEntryPoint: Google_Cloud_Aiplatform_V1_SearchEntryPoint? = nil
}

/// Google search entry point.
public struct Google_Cloud_Aiplatform_V1_SearchEntryPoint: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Web content snippet that can be embedded in a web page or an app
  /// webview.
  public var renderedContent: String = String()

  /// Optional. Base64 encoded JSON representing array of <search term, search
  /// url> tuple.
  public var sdkBlob: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_HarmCategory: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HARM_CATEGORY_UNSPECIFIED"),
    1: .same(proto: "HARM_CATEGORY_HATE_SPEECH"),
    2: .same(proto: "HARM_CATEGORY_DANGEROUS_CONTENT"),
    3: .same(proto: "HARM_CATEGORY_HARASSMENT"),
    4: .same(proto: "HARM_CATEGORY_SEXUALLY_EXPLICIT"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "parts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.parts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.parts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Content, rhs: Google_Cloud_Aiplatform_V1_Content) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Part: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Part"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "inline_data"),
    3: .standard(proto: "file_data"),
    5: .standard(proto: "function_call"),
    6: .standard(proto: "function_response"),
    4: .standard(proto: "video_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .text(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_Blob?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .inlineData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .inlineData(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_FileData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .fileData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .fileData(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_VideoMetadata?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .videoMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .videoMetadata(v)
        }
      }()
      case 5: try {
        var v: Google_Cloud_Aiplatform_V1_FunctionCall?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .functionCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .functionCall(v)
        }
      }()
      case 6: try {
        var v: Google_Cloud_Aiplatform_V1_FunctionResponse?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .functionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .functionResponse(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .text?: try {
      guard case .text(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .inlineData?: try {
      guard case .inlineData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .fileData?: try {
      guard case .fileData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    try { if case .videoMetadata(let v)? = self.metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.data {
    case .functionCall?: try {
      guard case .functionCall(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .functionResponse?: try {
      guard case .functionResponse(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Part, rhs: Google_Cloud_Aiplatform_V1_Part) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Blob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Blob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Blob, rhs: Google_Cloud_Aiplatform_V1_Blob) -> Bool {
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FileData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .standard(proto: "file_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 1)
    }
    if !self.fileUri.isEmpty {
      try visitor.visitSingularStringField(value: self.fileUri, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FileData, rhs: Google_Cloud_Aiplatform_V1_FileData) -> Bool {
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileUri != rhs.fileUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_VideoMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_offset"),
    2: .standard(proto: "end_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startOffset) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_VideoMetadata, rhs: Google_Cloud_Aiplatform_V1_VideoMetadata) -> Bool {
    if lhs._startOffset != rhs._startOffset {return false}
    if lhs._endOffset != rhs._endOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GenerationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "temperature"),
    2: .standard(proto: "top_p"),
    3: .standard(proto: "top_k"),
    4: .standard(proto: "candidate_count"),
    5: .standard(proto: "max_output_tokens"),
    6: .standard(proto: "stop_sequences"),
    8: .standard(proto: "presence_penalty"),
    9: .standard(proto: "frequency_penalty"),
    12: .same(proto: "seed"),
    13: .standard(proto: "response_mime_type"),
    16: .standard(proto: "response_schema"),
    17: .standard(proto: "routing_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._temperature) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._topP) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._topK) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._candidateCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._maxOutputTokens) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.stopSequences) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._presencePenalty) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._frequencyPenalty) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self._seed) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.responseMimeType) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._responseSchema) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._routingConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._temperature {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topP {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._topK {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._candidateCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxOutputTokens {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.stopSequences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stopSequences, fieldNumber: 6)
    }
    try { if let v = self._presencePenalty {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._frequencyPenalty {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._seed {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
    } }()
    if !self.responseMimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.responseMimeType, fieldNumber: 13)
    }
    try { if let v = self._responseSchema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._routingConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GenerationConfig, rhs: Google_Cloud_Aiplatform_V1_GenerationConfig) -> Bool {
    if lhs._temperature != rhs._temperature {return false}
    if lhs._topP != rhs._topP {return false}
    if lhs._topK != rhs._topK {return false}
    if lhs._candidateCount != rhs._candidateCount {return false}
    if lhs._maxOutputTokens != rhs._maxOutputTokens {return false}
    if lhs.stopSequences != rhs.stopSequences {return false}
    if lhs._presencePenalty != rhs._presencePenalty {return false}
    if lhs._frequencyPenalty != rhs._frequencyPenalty {return false}
    if lhs._seed != rhs._seed {return false}
    if lhs.responseMimeType != rhs.responseMimeType {return false}
    if lhs._responseSchema != rhs._responseSchema {return false}
    if lhs._routingConfig != rhs._routingConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_GenerationConfig.protoMessageName + ".RoutingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_mode"),
    2: .standard(proto: "manual_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode?
        var hadOneofValue = false
        if let current = self.routingConfig {
          hadOneofValue = true
          if case .autoMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.routingConfig = .autoMode(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.ManualRoutingMode?
        var hadOneofValue = false
        if let current = self.routingConfig {
          hadOneofValue = true
          if case .manualMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.routingConfig = .manualMode(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.routingConfig {
    case .autoMode?: try {
      guard case .autoMode(let v)? = self.routingConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .manualMode?: try {
      guard case .manualMode(let v)? = self.routingConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig, rhs: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig) -> Bool {
    if lhs.routingConfig != rhs.routingConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.protoMessageName + ".AutoRoutingMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_routing_preference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._modelRoutingPreference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modelRoutingPreference {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode, rhs: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode) -> Bool {
    if lhs._modelRoutingPreference != rhs._modelRoutingPreference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.AutoRoutingMode.ModelRoutingPreference: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PRIORITIZE_QUALITY"),
    2: .same(proto: "BALANCED"),
    3: .same(proto: "PRIORITIZE_COST"),
  ]
}

extension Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.ManualRoutingMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.protoMessageName + ".ManualRoutingMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._modelName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modelName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.ManualRoutingMode, rhs: Google_Cloud_Aiplatform_V1_GenerationConfig.RoutingConfig.ManualRoutingMode) -> Bool {
    if lhs._modelName != rhs._modelName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SafetySetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafetySetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "threshold"),
    4: .same(proto: "method"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.threshold) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .unspecified {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    if self.threshold != .unspecified {
      try visitor.visitSingularEnumField(value: self.threshold, fieldNumber: 2)
    }
    if self.method != .unspecified {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SafetySetting, rhs: Google_Cloud_Aiplatform_V1_SafetySetting) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SafetySetting.HarmBlockThreshold: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HARM_BLOCK_THRESHOLD_UNSPECIFIED"),
    1: .same(proto: "BLOCK_LOW_AND_ABOVE"),
    2: .same(proto: "BLOCK_MEDIUM_AND_ABOVE"),
    3: .same(proto: "BLOCK_ONLY_HIGH"),
    4: .same(proto: "BLOCK_NONE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_SafetySetting.HarmBlockMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HARM_BLOCK_METHOD_UNSPECIFIED"),
    1: .same(proto: "SEVERITY"),
    2: .same(proto: "PROBABILITY"),
  ]
}

extension Google_Cloud_Aiplatform_V1_SafetyRating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafetyRating"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "probability"),
    5: .standard(proto: "probability_score"),
    6: .same(proto: "severity"),
    7: .standard(proto: "severity_score"),
    3: .same(proto: "blocked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.probability) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.probabilityScore) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.severityScore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .unspecified {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    if self.probability != .unspecified {
      try visitor.visitSingularEnumField(value: self.probability, fieldNumber: 2)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 3)
    }
    if self.probabilityScore.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.probabilityScore, fieldNumber: 5)
    }
    if self.severity != .unspecified {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 6)
    }
    if self.severityScore.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.severityScore, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SafetyRating, rhs: Google_Cloud_Aiplatform_V1_SafetyRating) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.probability != rhs.probability {return false}
    if lhs.probabilityScore != rhs.probabilityScore {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.severityScore != rhs.severityScore {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SafetyRating.HarmProbability: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HARM_PROBABILITY_UNSPECIFIED"),
    1: .same(proto: "NEGLIGIBLE"),
    2: .same(proto: "LOW"),
    3: .same(proto: "MEDIUM"),
    4: .same(proto: "HIGH"),
  ]
}

extension Google_Cloud_Aiplatform_V1_SafetyRating.HarmSeverity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HARM_SEVERITY_UNSPECIFIED"),
    1: .same(proto: "HARM_SEVERITY_NEGLIGIBLE"),
    2: .same(proto: "HARM_SEVERITY_LOW"),
    3: .same(proto: "HARM_SEVERITY_MEDIUM"),
    4: .same(proto: "HARM_SEVERITY_HIGH"),
  ]
}

extension Google_Cloud_Aiplatform_V1_CitationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CitationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "citations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.citations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.citations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.citations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CitationMetadata, rhs: Google_Cloud_Aiplatform_V1_CitationMetadata) -> Bool {
    if lhs.citations != rhs.citations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Citation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Citation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_index"),
    2: .standard(proto: "end_index"),
    3: .same(proto: "uri"),
    4: .same(proto: "title"),
    5: .same(proto: "license"),
    6: .standard(proto: "publication_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.license) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._publicationDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.startIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.startIndex, fieldNumber: 1)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.endIndex, fieldNumber: 2)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if !self.license.isEmpty {
      try visitor.visitSingularStringField(value: self.license, fieldNumber: 5)
    }
    try { if let v = self._publicationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Citation, rhs: Google_Cloud_Aiplatform_V1_Citation) -> Bool {
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.title != rhs.title {return false}
    if lhs.license != rhs.license {return false}
    if lhs._publicationDate != rhs._publicationDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Candidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Candidate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "content"),
    8: .same(proto: "score"),
    9: .standard(proto: "avg_logprobs"),
    3: .standard(proto: "finish_reason"),
    4: .standard(proto: "safety_ratings"),
    5: .standard(proto: "finish_message"),
    6: .standard(proto: "citation_metadata"),
    7: .standard(proto: "grounding_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.finishReason) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.safetyRatings) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._finishMessage) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._citationMetadata) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._groundingMetadata) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.score) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.avgLogprobs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.finishReason != .unspecified {
      try visitor.visitSingularEnumField(value: self.finishReason, fieldNumber: 3)
    }
    if !self.safetyRatings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.safetyRatings, fieldNumber: 4)
    }
    try { if let v = self._finishMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._citationMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._groundingMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.score.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.score, fieldNumber: 8)
    }
    if self.avgLogprobs.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.avgLogprobs, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Candidate, rhs: Google_Cloud_Aiplatform_V1_Candidate) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._content != rhs._content {return false}
    if lhs.score != rhs.score {return false}
    if lhs.avgLogprobs != rhs.avgLogprobs {return false}
    if lhs.finishReason != rhs.finishReason {return false}
    if lhs.safetyRatings != rhs.safetyRatings {return false}
    if lhs._finishMessage != rhs._finishMessage {return false}
    if lhs._citationMetadata != rhs._citationMetadata {return false}
    if lhs._groundingMetadata != rhs._groundingMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Candidate.FinishReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FINISH_REASON_UNSPECIFIED"),
    1: .same(proto: "STOP"),
    2: .same(proto: "MAX_TOKENS"),
    3: .same(proto: "SAFETY"),
    4: .same(proto: "RECITATION"),
    5: .same(proto: "OTHER"),
    6: .same(proto: "BLOCKLIST"),
    7: .same(proto: "PROHIBITED_CONTENT"),
    8: .same(proto: "SPII"),
    9: .same(proto: "MALFORMED_FUNCTION_CALL"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Segment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "part_index"),
    2: .standard(proto: "start_index"),
    3: .standard(proto: "end_index"),
    4: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.partIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.partIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.partIndex, fieldNumber: 1)
    }
    if self.startIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.startIndex, fieldNumber: 2)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.endIndex, fieldNumber: 3)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Segment, rhs: Google_Cloud_Aiplatform_V1_Segment) -> Bool {
    if lhs.partIndex != rhs.partIndex {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundingChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroundingChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "web"),
    2: .standard(proto: "retrieved_context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_GroundingChunk.Web?
        var hadOneofValue = false
        if let current = self.chunkType {
          hadOneofValue = true
          if case .web(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chunkType = .web(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_GroundingChunk.RetrievedContext?
        var hadOneofValue = false
        if let current = self.chunkType {
          hadOneofValue = true
          if case .retrievedContext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chunkType = .retrievedContext(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.chunkType {
    case .web?: try {
      guard case .web(let v)? = self.chunkType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .retrievedContext?: try {
      guard case .retrievedContext(let v)? = self.chunkType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundingChunk, rhs: Google_Cloud_Aiplatform_V1_GroundingChunk) -> Bool {
    if lhs.chunkType != rhs.chunkType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundingChunk.Web: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_GroundingChunk.protoMessageName + ".Web"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uri {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundingChunk.Web, rhs: Google_Cloud_Aiplatform_V1_GroundingChunk.Web) -> Bool {
    if lhs._uri != rhs._uri {return false}
    if lhs._title != rhs._title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundingChunk.RetrievedContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_GroundingChunk.protoMessageName + ".RetrievedContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uri {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundingChunk.RetrievedContext, rhs: Google_Cloud_Aiplatform_V1_GroundingChunk.RetrievedContext) -> Bool {
    if lhs._uri != rhs._uri {return false}
    if lhs._title != rhs._title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundingSupport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroundingSupport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "segment"),
    2: .standard(proto: "grounding_chunk_indices"),
    3: .standard(proto: "confidence_scores"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._segment) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.groundingChunkIndices) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.confidenceScores) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._segment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.groundingChunkIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.groundingChunkIndices, fieldNumber: 2)
    }
    if !self.confidenceScores.isEmpty {
      try visitor.visitPackedFloatField(value: self.confidenceScores, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundingSupport, rhs: Google_Cloud_Aiplatform_V1_GroundingSupport) -> Bool {
    if lhs._segment != rhs._segment {return false}
    if lhs.groundingChunkIndices != rhs.groundingChunkIndices {return false}
    if lhs.confidenceScores != rhs.confidenceScores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundingMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroundingMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "web_search_queries"),
    4: .standard(proto: "search_entry_point"),
    5: .standard(proto: "grounding_chunks"),
    6: .standard(proto: "grounding_supports"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.webSearchQueries) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._searchEntryPoint) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.groundingChunks) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.groundingSupports) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.webSearchQueries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.webSearchQueries, fieldNumber: 1)
    }
    try { if let v = self._searchEntryPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.groundingChunks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groundingChunks, fieldNumber: 5)
    }
    if !self.groundingSupports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groundingSupports, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundingMetadata, rhs: Google_Cloud_Aiplatform_V1_GroundingMetadata) -> Bool {
    if lhs.webSearchQueries != rhs.webSearchQueries {return false}
    if lhs._searchEntryPoint != rhs._searchEntryPoint {return false}
    if lhs.groundingChunks != rhs.groundingChunks {return false}
    if lhs.groundingSupports != rhs.groundingSupports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SearchEntryPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchEntryPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rendered_content"),
    2: .standard(proto: "sdk_blob"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.renderedContent) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sdkBlob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.renderedContent.isEmpty {
      try visitor.visitSingularStringField(value: self.renderedContent, fieldNumber: 1)
    }
    if !self.sdkBlob.isEmpty {
      try visitor.visitSingularBytesField(value: self.sdkBlob, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SearchEntryPoint, rhs: Google_Cloud_Aiplatform_V1_SearchEntryPoint) -> Bool {
    if lhs.renderedContent != rhs.renderedContent {return false}
    if lhs.sdkBlob != rhs.sdkBlob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
