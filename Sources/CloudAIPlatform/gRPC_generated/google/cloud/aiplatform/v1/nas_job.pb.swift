// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/nas_job.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents a Neural Architecture Search (NAS) job.
public struct Google_Cloud_Aiplatform_V1_NasJob: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Resource name of the NasJob.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. The display name of the NasJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Required. The specification of a NasJob.
  public var nasJobSpec: Google_Cloud_Aiplatform_V1_NasJobSpec {
    get {return _storage._nasJobSpec ?? Google_Cloud_Aiplatform_V1_NasJobSpec()}
    set {_uniqueStorage()._nasJobSpec = newValue}
  }
  /// Returns true if `nasJobSpec` has been explicitly set.
  public var hasNasJobSpec: Bool {return _storage._nasJobSpec != nil}
  /// Clears the value of `nasJobSpec`. Subsequent reads from it will return its default value.
  public mutating func clearNasJobSpec() {_uniqueStorage()._nasJobSpec = nil}

  /// Output only. Output of the NasJob.
  public var nasJobOutput: Google_Cloud_Aiplatform_V1_NasJobOutput {
    get {return _storage._nasJobOutput ?? Google_Cloud_Aiplatform_V1_NasJobOutput()}
    set {_uniqueStorage()._nasJobOutput = newValue}
  }
  /// Returns true if `nasJobOutput` has been explicitly set.
  public var hasNasJobOutput: Bool {return _storage._nasJobOutput != nil}
  /// Clears the value of `nasJobOutput`. Subsequent reads from it will return its default value.
  public mutating func clearNasJobOutput() {_uniqueStorage()._nasJobOutput = nil}

  /// Output only. The detailed state of the job.
  public var state: Google_Cloud_Aiplatform_V1_JobState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. Time when the NasJob was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Time when the NasJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Output only. Time when the NasJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Output only. Time when the NasJob was most recently updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  public var error: Google_Rpc_Status {
    get {return _storage._error ?? Google_Rpc_Status()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {_uniqueStorage()._error = nil}

  /// The labels with user-defined metadata to organize NasJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Customer-managed encryption key options for a NasJob.
  /// If this is set, then all resources created by the NasJob
  /// will be encrypted with the provided encryption key.
  public var encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec {
    get {return _storage._encryptionSpec ?? Google_Cloud_Aiplatform_V1_EncryptionSpec()}
    set {_uniqueStorage()._encryptionSpec = newValue}
  }
  /// Returns true if `encryptionSpec` has been explicitly set.
  public var hasEncryptionSpec: Bool {return _storage._encryptionSpec != nil}
  /// Clears the value of `encryptionSpec`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptionSpec() {_uniqueStorage()._encryptionSpec = nil}

  /// Optional. Enable a separation of Custom model training
  /// and restricted image training for tenant project.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var enableRestrictedImageTraining: Bool {
    get {return _storage._enableRestrictedImageTraining}
    set {_uniqueStorage()._enableRestrictedImageTraining = newValue}
  }

  /// Output only. Reserved for future use.
  public var satisfiesPzs: Bool {
    get {return _storage._satisfiesPzs}
    set {_uniqueStorage()._satisfiesPzs = newValue}
  }

  /// Output only. Reserved for future use.
  public var satisfiesPzi: Bool {
    get {return _storage._satisfiesPzi}
    set {_uniqueStorage()._satisfiesPzi = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a NasTrial details along with its parameters. If there is a
/// corresponding train NasTrial, the train NasTrial is also returned.
public struct Google_Cloud_Aiplatform_V1_NasTrialDetail: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Resource name of the NasTrialDetail.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The parameters for the NasJob NasTrial.
  public var parameters: String {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  /// The requested search NasTrial.
  public var searchTrial: Google_Cloud_Aiplatform_V1_NasTrial {
    get {return _storage._searchTrial ?? Google_Cloud_Aiplatform_V1_NasTrial()}
    set {_uniqueStorage()._searchTrial = newValue}
  }
  /// Returns true if `searchTrial` has been explicitly set.
  public var hasSearchTrial: Bool {return _storage._searchTrial != nil}
  /// Clears the value of `searchTrial`. Subsequent reads from it will return its default value.
  public mutating func clearSearchTrial() {_uniqueStorage()._searchTrial = nil}

  /// The train NasTrial corresponding to
  /// [search_trial][google.cloud.aiplatform.v1.NasTrialDetail.search_trial].
  /// Only populated if
  /// [search_trial][google.cloud.aiplatform.v1.NasTrialDetail.search_trial] is
  /// used for training.
  public var trainTrial: Google_Cloud_Aiplatform_V1_NasTrial {
    get {return _storage._trainTrial ?? Google_Cloud_Aiplatform_V1_NasTrial()}
    set {_uniqueStorage()._trainTrial = newValue}
  }
  /// Returns true if `trainTrial` has been explicitly set.
  public var hasTrainTrial: Bool {return _storage._trainTrial != nil}
  /// Clears the value of `trainTrial`. Subsequent reads from it will return its default value.
  public mutating func clearTrainTrial() {_uniqueStorage()._trainTrial = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents the spec of a NasJob.
public struct Google_Cloud_Aiplatform_V1_NasJobSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Neural Architecture Search (NAS) algorithm specification.
  public var nasAlgorithmSpec: Google_Cloud_Aiplatform_V1_NasJobSpec.OneOf_NasAlgorithmSpec? = nil

  /// The spec of multi-trial algorithms.
  public var multiTrialAlgorithmSpec: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec {
    get {
      if case .multiTrialAlgorithmSpec(let v)? = nasAlgorithmSpec {return v}
      return Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec()
    }
    set {nasAlgorithmSpec = .multiTrialAlgorithmSpec(newValue)}
  }

  /// The ID of the existing NasJob in the same Project and Location
  /// which will be used to resume search. search_space_spec and
  /// nas_algorithm_spec are obtained from previous NasJob hence should not
  /// provide them again for this NasJob.
  public var resumeNasJobID: String = String()

  /// It defines the search space for Neural Architecture Search (NAS).
  public var searchSpaceSpec: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The Neural Architecture Search (NAS) algorithm specification.
  public enum OneOf_NasAlgorithmSpec: Equatable, Sendable {
    /// The spec of multi-trial algorithms.
    case multiTrialAlgorithmSpec(Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec)

  }

  /// The spec of multi-trial Neural Architecture Search (NAS).
  public struct MultiTrialAlgorithmSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The multi-trial Neural Architecture Search (NAS) algorithm
    /// type. Defaults to `REINFORCEMENT_LEARNING`.
    public var multiTrialAlgorithm: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MultiTrialAlgorithm = .unspecified

    /// Metric specs for the NAS job.
    /// Validation for this field is done at `multi_trial_algorithm_spec` field.
    public var metric: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec {
      get {return _metric ?? Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec()}
      set {_metric = newValue}
    }
    /// Returns true if `metric` has been explicitly set.
    public var hasMetric: Bool {return self._metric != nil}
    /// Clears the value of `metric`. Subsequent reads from it will return its default value.
    public mutating func clearMetric() {self._metric = nil}

    /// Required. Spec for search trials.
    public var searchTrialSpec: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec {
      get {return _searchTrialSpec ?? Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec()}
      set {_searchTrialSpec = newValue}
    }
    /// Returns true if `searchTrialSpec` has been explicitly set.
    public var hasSearchTrialSpec: Bool {return self._searchTrialSpec != nil}
    /// Clears the value of `searchTrialSpec`. Subsequent reads from it will return its default value.
    public mutating func clearSearchTrialSpec() {self._searchTrialSpec = nil}

    /// Spec for train trials. Top N [TrainTrialSpec.max_parallel_trial_count]
    /// search trials will be trained for every M
    /// [TrainTrialSpec.frequency] trials searched.
    public var trainTrialSpec: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec {
      get {return _trainTrialSpec ?? Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec()}
      set {_trainTrialSpec = newValue}
    }
    /// Returns true if `trainTrialSpec` has been explicitly set.
    public var hasTrainTrialSpec: Bool {return self._trainTrialSpec != nil}
    /// Clears the value of `trainTrialSpec`. Subsequent reads from it will return its default value.
    public mutating func clearTrainTrialSpec() {self._trainTrialSpec = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The available types of multi-trial algorithms.
    public enum MultiTrialAlgorithm: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Defaults to `REINFORCEMENT_LEARNING`.
      case unspecified // = 0

      /// The Reinforcement Learning Algorithm for Multi-trial Neural
      /// Architecture Search (NAS).
      case reinforcementLearning // = 1

      /// The Grid Search Algorithm for Multi-trial Neural
      /// Architecture Search (NAS).
      case gridSearch // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .reinforcementLearning
        case 2: self = .gridSearch
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .reinforcementLearning: return 1
        case .gridSearch: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MultiTrialAlgorithm] = [
        .unspecified,
        .reinforcementLearning,
        .gridSearch,
      ]

    }

    /// Represents a metric to optimize.
    public struct MetricSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The ID of the metric. Must not contain whitespaces.
      public var metricID: String = String()

      /// Required. The optimization goal of the metric.
      public var goal: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec.GoalType = .unspecified

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The available types of optimization goals.
      public enum GoalType: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Goal Type will default to maximize.
        case unspecified // = 0

        /// Maximize the goal metric.
        case maximize // = 1

        /// Minimize the goal metric.
        case minimize // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecified
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .maximize
          case 2: self = .minimize
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .maximize: return 1
          case .minimize: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec.GoalType] = [
          .unspecified,
          .maximize,
          .minimize,
        ]

      }

      public init() {}
    }

    /// Represent spec for search trials.
    public struct SearchTrialSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The spec of a search trial job. The same spec applies to
      /// all search trials.
      public var searchTrialJobSpec: Google_Cloud_Aiplatform_V1_CustomJobSpec {
        get {return _searchTrialJobSpec ?? Google_Cloud_Aiplatform_V1_CustomJobSpec()}
        set {_searchTrialJobSpec = newValue}
      }
      /// Returns true if `searchTrialJobSpec` has been explicitly set.
      public var hasSearchTrialJobSpec: Bool {return self._searchTrialJobSpec != nil}
      /// Clears the value of `searchTrialJobSpec`. Subsequent reads from it will return its default value.
      public mutating func clearSearchTrialJobSpec() {self._searchTrialJobSpec = nil}

      /// Required. The maximum number of Neural Architecture Search (NAS) trials
      /// to run.
      public var maxTrialCount: Int32 = 0

      /// Required. The maximum number of trials to run in parallel.
      public var maxParallelTrialCount: Int32 = 0

      /// The number of failed trials that need to be seen before failing
      /// the NasJob.
      ///
      /// If set to 0, Vertex AI decides how many trials must fail
      /// before the whole job fails.
      public var maxFailedTrialCount: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _searchTrialJobSpec: Google_Cloud_Aiplatform_V1_CustomJobSpec? = nil
    }

    /// Represent spec for train trials.
    public struct TrainTrialSpec: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The spec of a train trial job. The same spec applies to
      /// all train trials.
      public var trainTrialJobSpec: Google_Cloud_Aiplatform_V1_CustomJobSpec {
        get {return _trainTrialJobSpec ?? Google_Cloud_Aiplatform_V1_CustomJobSpec()}
        set {_trainTrialJobSpec = newValue}
      }
      /// Returns true if `trainTrialJobSpec` has been explicitly set.
      public var hasTrainTrialJobSpec: Bool {return self._trainTrialJobSpec != nil}
      /// Clears the value of `trainTrialJobSpec`. Subsequent reads from it will return its default value.
      public mutating func clearTrainTrialJobSpec() {self._trainTrialJobSpec = nil}

      /// Required. The maximum number of trials to run in parallel.
      public var maxParallelTrialCount: Int32 = 0

      /// Required. Frequency of search trials to start train stage. Top N
      /// [TrainTrialSpec.max_parallel_trial_count]
      /// search trials will be trained for every M
      /// [TrainTrialSpec.frequency] trials searched.
      public var frequency: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _trainTrialJobSpec: Google_Cloud_Aiplatform_V1_CustomJobSpec? = nil
    }

    public init() {}

    fileprivate var _metric: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec? = nil
    fileprivate var _searchTrialSpec: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec? = nil
    fileprivate var _trainTrialSpec: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec? = nil
  }

  public init() {}
}

/// Represents a uCAIP NasJob output.
public struct Google_Cloud_Aiplatform_V1_NasJobOutput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The output of this Neural Architecture Search (NAS) job.
  public var output: Google_Cloud_Aiplatform_V1_NasJobOutput.OneOf_Output? = nil

  /// Output only. The output of this multi-trial Neural Architecture Search
  /// (NAS) job.
  public var multiTrialJobOutput: Google_Cloud_Aiplatform_V1_NasJobOutput.MultiTrialJobOutput {
    get {
      if case .multiTrialJobOutput(let v)? = output {return v}
      return Google_Cloud_Aiplatform_V1_NasJobOutput.MultiTrialJobOutput()
    }
    set {output = .multiTrialJobOutput(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The output of this Neural Architecture Search (NAS) job.
  public enum OneOf_Output: Equatable, Sendable {
    /// Output only. The output of this multi-trial Neural Architecture Search
    /// (NAS) job.
    case multiTrialJobOutput(Google_Cloud_Aiplatform_V1_NasJobOutput.MultiTrialJobOutput)

  }

  /// The output of a multi-trial Neural Architecture Search (NAS) jobs.
  public struct MultiTrialJobOutput: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. List of NasTrials that were started as part of search stage.
    public var searchTrials: [Google_Cloud_Aiplatform_V1_NasTrial] = []

    /// Output only. List of NasTrials that were started as part of train stage.
    public var trainTrials: [Google_Cloud_Aiplatform_V1_NasTrial] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Represents a uCAIP NasJob trial.
public struct Google_Cloud_Aiplatform_V1_NasTrial: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The identifier of the NasTrial assigned by the service.
  public var id: String = String()

  /// Output only. The detailed state of the NasTrial.
  public var state: Google_Cloud_Aiplatform_V1_NasTrial.State = .unspecified

  /// Output only. The final measurement containing the objective value.
  public var finalMeasurement: Google_Cloud_Aiplatform_V1_Measurement {
    get {return _finalMeasurement ?? Google_Cloud_Aiplatform_V1_Measurement()}
    set {_finalMeasurement = newValue}
  }
  /// Returns true if `finalMeasurement` has been explicitly set.
  public var hasFinalMeasurement: Bool {return self._finalMeasurement != nil}
  /// Clears the value of `finalMeasurement`. Subsequent reads from it will return its default value.
  public mutating func clearFinalMeasurement() {self._finalMeasurement = nil}

  /// Output only. Time when the NasTrial was started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Output only. Time when the NasTrial's status changed to `SUCCEEDED` or
  /// `INFEASIBLE`.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes a NasTrial state.
  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The NasTrial state is unspecified.
    case unspecified // = 0

    /// Indicates that a specific NasTrial has been requested, but it has not yet
    /// been suggested by the service.
    case requested // = 1

    /// Indicates that the NasTrial has been suggested.
    case active // = 2

    /// Indicates that the NasTrial should stop according to the service.
    case stopping // = 3

    /// Indicates that the NasTrial is completed successfully.
    case succeeded // = 4

    /// Indicates that the NasTrial should not be attempted again.
    /// The service will set a NasTrial to INFEASIBLE when it's done but missing
    /// the final_measurement.
    case infeasible // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .requested
      case 2: self = .active
      case 3: self = .stopping
      case 4: self = .succeeded
      case 5: self = .infeasible
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .requested: return 1
      case .active: return 2
      case .stopping: return 3
      case .succeeded: return 4
      case .infeasible: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_NasTrial.State] = [
      .unspecified,
      .requested,
      .active,
      .stopping,
      .succeeded,
      .infeasible,
    ]

  }

  public init() {}

  fileprivate var _finalMeasurement: Google_Cloud_Aiplatform_V1_Measurement? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_NasJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NasJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    4: .standard(proto: "nas_job_spec"),
    5: .standard(proto: "nas_job_output"),
    6: .same(proto: "state"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "start_time"),
    9: .standard(proto: "end_time"),
    10: .standard(proto: "update_time"),
    11: .same(proto: "error"),
    12: .same(proto: "labels"),
    13: .standard(proto: "encryption_spec"),
    14: .standard(proto: "enable_restricted_image_training"),
    15: .standard(proto: "satisfies_pzs"),
    16: .standard(proto: "satisfies_pzi"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _nasJobSpec: Google_Cloud_Aiplatform_V1_NasJobSpec? = nil
    var _nasJobOutput: Google_Cloud_Aiplatform_V1_NasJobOutput? = nil
    var _state: Google_Cloud_Aiplatform_V1_JobState = .unspecified
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _error: Google_Rpc_Status? = nil
    var _labels: Dictionary<String,String> = [:]
    var _encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec? = nil
    var _enableRestrictedImageTraining: Bool = false
    var _satisfiesPzs: Bool = false
    var _satisfiesPzi: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _nasJobSpec = source._nasJobSpec
      _nasJobOutput = source._nasJobOutput
      _state = source._state
      _createTime = source._createTime
      _startTime = source._startTime
      _endTime = source._endTime
      _updateTime = source._updateTime
      _error = source._error
      _labels = source._labels
      _encryptionSpec = source._encryptionSpec
      _enableRestrictedImageTraining = source._enableRestrictedImageTraining
      _satisfiesPzs = source._satisfiesPzs
      _satisfiesPzi = source._satisfiesPzi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nasJobSpec) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._nasJobOutput) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._encryptionSpec) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._enableRestrictedImageTraining) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzs) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzi) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      try { if let v = _storage._nasJobSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._nasJobOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 12)
      }
      try { if let v = _storage._encryptionSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._enableRestrictedImageTraining != false {
        try visitor.visitSingularBoolField(value: _storage._enableRestrictedImageTraining, fieldNumber: 14)
      }
      if _storage._satisfiesPzs != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzs, fieldNumber: 15)
      }
      if _storage._satisfiesPzi != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzi, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJob, rhs: Google_Cloud_Aiplatform_V1_NasJob) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._nasJobSpec != rhs_storage._nasJobSpec {return false}
        if _storage._nasJobOutput != rhs_storage._nasJobOutput {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._encryptionSpec != rhs_storage._encryptionSpec {return false}
        if _storage._enableRestrictedImageTraining != rhs_storage._enableRestrictedImageTraining {return false}
        if _storage._satisfiesPzs != rhs_storage._satisfiesPzs {return false}
        if _storage._satisfiesPzi != rhs_storage._satisfiesPzi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasTrialDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NasTrialDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "parameters"),
    3: .standard(proto: "search_trial"),
    4: .standard(proto: "train_trial"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _parameters: String = String()
    var _searchTrial: Google_Cloud_Aiplatform_V1_NasTrial? = nil
    var _trainTrial: Google_Cloud_Aiplatform_V1_NasTrial? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _parameters = source._parameters
      _searchTrial = source._searchTrial
      _trainTrial = source._trainTrial
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._parameters) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._searchTrial) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._trainTrial) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parameters, fieldNumber: 2)
      }
      try { if let v = _storage._searchTrial {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._trainTrial {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasTrialDetail, rhs: Google_Cloud_Aiplatform_V1_NasTrialDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._searchTrial != rhs_storage._searchTrial {return false}
        if _storage._trainTrial != rhs_storage._trainTrial {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasJobSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NasJobSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "multi_trial_algorithm_spec"),
    3: .standard(proto: "resume_nas_job_id"),
    1: .standard(proto: "search_space_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.searchSpaceSpec) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec?
        var hadOneofValue = false
        if let current = self.nasAlgorithmSpec {
          hadOneofValue = true
          if case .multiTrialAlgorithmSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nasAlgorithmSpec = .multiTrialAlgorithmSpec(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resumeNasJobID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.searchSpaceSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.searchSpaceSpec, fieldNumber: 1)
    }
    try { if case .multiTrialAlgorithmSpec(let v)? = self.nasAlgorithmSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resumeNasJobID.isEmpty {
      try visitor.visitSingularStringField(value: self.resumeNasJobID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJobSpec, rhs: Google_Cloud_Aiplatform_V1_NasJobSpec) -> Bool {
    if lhs.nasAlgorithmSpec != rhs.nasAlgorithmSpec {return false}
    if lhs.resumeNasJobID != rhs.resumeNasJobID {return false}
    if lhs.searchSpaceSpec != rhs.searchSpaceSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NasJobSpec.protoMessageName + ".MultiTrialAlgorithmSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "multi_trial_algorithm"),
    2: .same(proto: "metric"),
    3: .standard(proto: "search_trial_spec"),
    4: .standard(proto: "train_trial_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.multiTrialAlgorithm) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metric) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._searchTrialSpec) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._trainTrialSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.multiTrialAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.multiTrialAlgorithm, fieldNumber: 1)
    }
    try { if let v = self._metric {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._searchTrialSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._trainTrialSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec, rhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec) -> Bool {
    if lhs.multiTrialAlgorithm != rhs.multiTrialAlgorithm {return false}
    if lhs._metric != rhs._metric {return false}
    if lhs._searchTrialSpec != rhs._searchTrialSpec {return false}
    if lhs._trainTrialSpec != rhs._trainTrialSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MultiTrialAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MULTI_TRIAL_ALGORITHM_UNSPECIFIED"),
    1: .same(proto: "REINFORCEMENT_LEARNING"),
    2: .same(proto: "GRID_SEARCH"),
  ]
}

extension Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.protoMessageName + ".MetricSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_id"),
    2: .same(proto: "goal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metricID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.goal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metricID.isEmpty {
      try visitor.visitSingularStringField(value: self.metricID, fieldNumber: 1)
    }
    if self.goal != .unspecified {
      try visitor.visitSingularEnumField(value: self.goal, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec, rhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec) -> Bool {
    if lhs.metricID != rhs.metricID {return false}
    if lhs.goal != rhs.goal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec.GoalType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GOAL_TYPE_UNSPECIFIED"),
    1: .same(proto: "MAXIMIZE"),
    2: .same(proto: "MINIMIZE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.protoMessageName + ".SearchTrialSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "search_trial_job_spec"),
    2: .standard(proto: "max_trial_count"),
    3: .standard(proto: "max_parallel_trial_count"),
    4: .standard(proto: "max_failed_trial_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._searchTrialJobSpec) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxTrialCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxParallelTrialCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maxFailedTrialCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._searchTrialJobSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.maxTrialCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTrialCount, fieldNumber: 2)
    }
    if self.maxParallelTrialCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxParallelTrialCount, fieldNumber: 3)
    }
    if self.maxFailedTrialCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxFailedTrialCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec, rhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec) -> Bool {
    if lhs._searchTrialJobSpec != rhs._searchTrialJobSpec {return false}
    if lhs.maxTrialCount != rhs.maxTrialCount {return false}
    if lhs.maxParallelTrialCount != rhs.maxParallelTrialCount {return false}
    if lhs.maxFailedTrialCount != rhs.maxFailedTrialCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.protoMessageName + ".TrainTrialSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "train_trial_job_spec"),
    2: .standard(proto: "max_parallel_trial_count"),
    3: .same(proto: "frequency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trainTrialJobSpec) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxParallelTrialCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.frequency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trainTrialJobSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.maxParallelTrialCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxParallelTrialCount, fieldNumber: 2)
    }
    if self.frequency != 0 {
      try visitor.visitSingularInt32Field(value: self.frequency, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec, rhs: Google_Cloud_Aiplatform_V1_NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec) -> Bool {
    if lhs._trainTrialJobSpec != rhs._trainTrialJobSpec {return false}
    if lhs.maxParallelTrialCount != rhs.maxParallelTrialCount {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasJobOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NasJobOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "multi_trial_job_output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_NasJobOutput.MultiTrialJobOutput?
        var hadOneofValue = false
        if let current = self.output {
          hadOneofValue = true
          if case .multiTrialJobOutput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.output = .multiTrialJobOutput(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .multiTrialJobOutput(let v)? = self.output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJobOutput, rhs: Google_Cloud_Aiplatform_V1_NasJobOutput) -> Bool {
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasJobOutput.MultiTrialJobOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_NasJobOutput.protoMessageName + ".MultiTrialJobOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "search_trials"),
    2: .standard(proto: "train_trials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.searchTrials) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.trainTrials) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchTrials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searchTrials, fieldNumber: 1)
    }
    if !self.trainTrials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trainTrials, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasJobOutput.MultiTrialJobOutput, rhs: Google_Cloud_Aiplatform_V1_NasJobOutput.MultiTrialJobOutput) -> Bool {
    if lhs.searchTrials != rhs.searchTrials {return false}
    if lhs.trainTrials != rhs.trainTrials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasTrial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NasTrial"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "state"),
    3: .standard(proto: "final_measurement"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._finalMeasurement) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._finalMeasurement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_NasTrial, rhs: Google_Cloud_Aiplatform_V1_NasTrial) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.state != rhs.state {return false}
    if lhs._finalMeasurement != rhs._finalMeasurement {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_NasTrial.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "REQUESTED"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "STOPPING"),
    4: .same(proto: "SUCCEEDED"),
    5: .same(proto: "INFEASIBLE"),
  ]
}
