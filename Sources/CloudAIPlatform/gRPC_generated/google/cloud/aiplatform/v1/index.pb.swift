// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/index.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
public struct Google_Cloud_Aiplatform_V1_Index: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name of the Index.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. The display name of the Index.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// The description of the Index.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Index, that is specific to it. Unset if
  /// the Index does not have any additional information. The schema is defined
  /// as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  public var metadataSchemaUri: String {
    get {return _storage._metadataSchemaUri}
    set {_uniqueStorage()._metadataSchemaUri = newValue}
  }

  /// An additional information about the Index; the schema of the metadata can
  /// be found in
  /// [metadata_schema][google.cloud.aiplatform.v1.Index.metadata_schema_uri].
  public var metadata: SwiftProtobuf.Google_Protobuf_Value {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Output only. The pointers to DeployedIndexes created from this Index.
  /// An Index can be only deleted if all its DeployedIndexes had been undeployed
  /// first.
  public var deployedIndexes: [Google_Cloud_Aiplatform_V1_DeployedIndexRef] {
    get {return _storage._deployedIndexes}
    set {_uniqueStorage()._deployedIndexes = newValue}
  }

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  public var etag: String {
    get {return _storage._etag}
    set {_uniqueStorage()._etag = newValue}
  }

  /// The labels with user-defined metadata to organize your Indexes.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Output only. Timestamp when this Index was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Timestamp when this Index was most recently updated.
  /// This also includes any update to the contents of the Index.
  /// Note that Operations working on this Index may have their
  /// [Operations.metadata.generic_metadata.update_time]
  /// [google.cloud.aiplatform.v1.GenericOperationMetadata.update_time] a little
  /// after the value of this timestamp, yet that does not mean their results are
  /// not already reflected in the Index. Result of any successfully completed
  /// Operation on the Index is reflected in it.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. Stats of the index resource.
  public var indexStats: Google_Cloud_Aiplatform_V1_IndexStats {
    get {return _storage._indexStats ?? Google_Cloud_Aiplatform_V1_IndexStats()}
    set {_uniqueStorage()._indexStats = newValue}
  }
  /// Returns true if `indexStats` has been explicitly set.
  public var hasIndexStats: Bool {return _storage._indexStats != nil}
  /// Clears the value of `indexStats`. Subsequent reads from it will return its default value.
  public mutating func clearIndexStats() {_uniqueStorage()._indexStats = nil}

  /// Immutable. The update method to use with this Index. If not set,
  /// BATCH_UPDATE will be used by default.
  public var indexUpdateMethod: Google_Cloud_Aiplatform_V1_Index.IndexUpdateMethod {
    get {return _storage._indexUpdateMethod}
    set {_uniqueStorage()._indexUpdateMethod = newValue}
  }

  /// Immutable. Customer-managed encryption key spec for an Index. If set, this
  /// Index and all sub-resources of this Index will be secured by this key.
  public var encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec {
    get {return _storage._encryptionSpec ?? Google_Cloud_Aiplatform_V1_EncryptionSpec()}
    set {_uniqueStorage()._encryptionSpec = newValue}
  }
  /// Returns true if `encryptionSpec` has been explicitly set.
  public var hasEncryptionSpec: Bool {return _storage._encryptionSpec != nil}
  /// Clears the value of `encryptionSpec`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptionSpec() {_uniqueStorage()._encryptionSpec = nil}

  /// Output only. Reserved for future use.
  public var satisfiesPzs: Bool {
    get {return _storage._satisfiesPzs}
    set {_uniqueStorage()._satisfiesPzs = newValue}
  }

  /// Output only. Reserved for future use.
  public var satisfiesPzi: Bool {
    get {return _storage._satisfiesPzi}
    set {_uniqueStorage()._satisfiesPzi = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The update method of an Index.
  public enum IndexUpdateMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Should not be used.
    case unspecified // = 0

    /// BatchUpdate: user can call UpdateIndex with files on Cloud Storage of
    /// Datapoints to update.
    case batchUpdate // = 1

    /// StreamUpdate: user can call UpsertDatapoints/DeleteDatapoints to update
    /// the Index and the updates will be applied in corresponding
    /// DeployedIndexes in nearly real-time.
    case streamUpdate // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .batchUpdate
      case 2: self = .streamUpdate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .batchUpdate: return 1
      case .streamUpdate: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Index.IndexUpdateMethod] = [
      .unspecified,
      .batchUpdate,
      .streamUpdate,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A datapoint of Index.
public struct Google_Cloud_Aiplatform_V1_IndexDatapoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Unique identifier of the datapoint.
  public var datapointID: String = String()

  /// Required. Feature embedding vector for dense index. An array of numbers
  /// with the length of [NearestNeighborSearchConfig.dimensions].
  public var featureVector: [Float] = []

  /// Optional. Feature embedding vector for sparse index.
  public var sparseEmbedding: Google_Cloud_Aiplatform_V1_IndexDatapoint.SparseEmbedding {
    get {return _sparseEmbedding ?? Google_Cloud_Aiplatform_V1_IndexDatapoint.SparseEmbedding()}
    set {_sparseEmbedding = newValue}
  }
  /// Returns true if `sparseEmbedding` has been explicitly set.
  public var hasSparseEmbedding: Bool {return self._sparseEmbedding != nil}
  /// Clears the value of `sparseEmbedding`. Subsequent reads from it will return its default value.
  public mutating func clearSparseEmbedding() {self._sparseEmbedding = nil}

  /// Optional. List of Restrict of the datapoint, used to perform "restricted
  /// searches" where boolean rule are used to filter the subset of the database
  /// eligible for matching. This uses categorical tokens. See:
  /// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering
  public var restricts: [Google_Cloud_Aiplatform_V1_IndexDatapoint.Restriction] = []

  /// Optional. List of Restrict of the datapoint, used to perform "restricted
  /// searches" where boolean rule are used to filter the subset of the database
  /// eligible for matching. This uses numeric comparisons.
  public var numericRestricts: [Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction] = []

  /// Optional. CrowdingTag of the datapoint, the number of neighbors to return
  /// in each crowding can be configured during query.
  public var crowdingTag: Google_Cloud_Aiplatform_V1_IndexDatapoint.CrowdingTag {
    get {return _crowdingTag ?? Google_Cloud_Aiplatform_V1_IndexDatapoint.CrowdingTag()}
    set {_crowdingTag = newValue}
  }
  /// Returns true if `crowdingTag` has been explicitly set.
  public var hasCrowdingTag: Bool {return self._crowdingTag != nil}
  /// Clears the value of `crowdingTag`. Subsequent reads from it will return its default value.
  public mutating func clearCrowdingTag() {self._crowdingTag = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Feature embedding vector for sparse index. An array of numbers whose values
  /// are located in the specified dimensions.
  public struct SparseEmbedding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The list of embedding values of the sparse vector.
    public var values: [Float] = []

    /// Required. The list of indexes for the embedding values of the sparse
    /// vector.
    public var dimensions: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Restriction of a datapoint which describe its attributes(tokens) from each
  /// of several attribute categories(namespaces).
  public struct Restriction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace of this restriction. e.g.: color.
    public var namespace: String = String()

    /// The attributes to allow in this namespace. e.g.: 'red'
    public var allowList: [String] = []

    /// The attributes to deny in this namespace. e.g.: 'blue'
    public var denyList: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// This field allows restricts to be based on numeric comparisons rather
  /// than categorical tokens.
  public struct NumericRestriction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of Value must be consistent for all datapoints with a given
    /// namespace name. This is verified at runtime.
    public var value: Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction.OneOf_Value? = nil

    /// Represents 64 bit integer.
    public var valueInt: Int64 {
      get {
        if case .valueInt(let v)? = value {return v}
        return 0
      }
      set {value = .valueInt(newValue)}
    }

    /// Represents 32 bit float.
    public var valueFloat: Float {
      get {
        if case .valueFloat(let v)? = value {return v}
        return 0
      }
      set {value = .valueFloat(newValue)}
    }

    /// Represents 64 bit float.
    public var valueDouble: Double {
      get {
        if case .valueDouble(let v)? = value {return v}
        return 0
      }
      set {value = .valueDouble(newValue)}
    }

    /// The namespace of this restriction. e.g.: cost.
    public var namespace: String = String()

    /// This MUST be specified for queries and must NOT be specified for
    /// datapoints.
    public var op: Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction.Operator = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of Value must be consistent for all datapoints with a given
    /// namespace name. This is verified at runtime.
    public enum OneOf_Value: Equatable, Sendable {
      /// Represents 64 bit integer.
      case valueInt(Int64)
      /// Represents 32 bit float.
      case valueFloat(Float)
      /// Represents 64 bit float.
      case valueDouble(Double)

    }

    /// Which comparison operator to use.  Should be specified for queries only;
    /// specifying this for a datapoint is an error.
    ///
    /// Datapoints for which Operator is true relative to the query's Value
    /// field will be allowlisted.
    public enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Default value of the enum.
      case unspecified // = 0

      /// Datapoints are eligible iff their value is < the query's.
      case less // = 1

      /// Datapoints are eligible iff their value is <= the query's.
      case lessEqual // = 2

      /// Datapoints are eligible iff their value is == the query's.
      case equal // = 3

      /// Datapoints are eligible iff their value is >= the query's.
      case greaterEqual // = 4

      /// Datapoints are eligible iff their value is > the query's.
      case greater // = 5

      /// Datapoints are eligible iff their value is != the query's.
      case notEqual // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .less
        case 2: self = .lessEqual
        case 3: self = .equal
        case 4: self = .greaterEqual
        case 5: self = .greater
        case 6: self = .notEqual
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .less: return 1
        case .lessEqual: return 2
        case .equal: return 3
        case .greaterEqual: return 4
        case .greater: return 5
        case .notEqual: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction.Operator] = [
        .unspecified,
        .less,
        .lessEqual,
        .equal,
        .greaterEqual,
        .greater,
        .notEqual,
      ]

    }

    public init() {}
  }

  /// Crowding tag is a constraint on a neighbor list produced by nearest
  /// neighbor search requiring that no more than some value k' of the k
  /// neighbors returned have the same value of crowding_attribute.
  public struct CrowdingTag: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The attribute value used for crowding.  The maximum number of neighbors
    /// to return per crowding attribute value
    /// (per_crowding_attribute_num_neighbors) is configured per-query. This
    /// field is ignored if per_crowding_attribute_num_neighbors is larger than
    /// the total number of neighbors to return for a given query.
    public var crowdingAttribute: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _sparseEmbedding: Google_Cloud_Aiplatform_V1_IndexDatapoint.SparseEmbedding? = nil
  fileprivate var _crowdingTag: Google_Cloud_Aiplatform_V1_IndexDatapoint.CrowdingTag? = nil
}

/// Stats of the Index.
public struct Google_Cloud_Aiplatform_V1_IndexStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The number of dense vectors in the Index.
  public var vectorsCount: Int64 = 0

  /// Output only. The number of sparse vectors in the Index.
  public var sparseVectorsCount: Int64 = 0

  /// Output only. The number of shards in the Index.
  public var shardsCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_Index: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Index"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "metadata_schema_uri"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "deployed_indexes"),
    8: .same(proto: "etag"),
    9: .same(proto: "labels"),
    10: .standard(proto: "create_time"),
    11: .standard(proto: "update_time"),
    14: .standard(proto: "index_stats"),
    16: .standard(proto: "index_update_method"),
    17: .standard(proto: "encryption_spec"),
    18: .standard(proto: "satisfies_pzs"),
    19: .standard(proto: "satisfies_pzi"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _description_p: String = String()
    var _metadataSchemaUri: String = String()
    var _metadata: SwiftProtobuf.Google_Protobuf_Value? = nil
    var _deployedIndexes: [Google_Cloud_Aiplatform_V1_DeployedIndexRef] = []
    var _etag: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _indexStats: Google_Cloud_Aiplatform_V1_IndexStats? = nil
    var _indexUpdateMethod: Google_Cloud_Aiplatform_V1_Index.IndexUpdateMethod = .unspecified
    var _encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec? = nil
    var _satisfiesPzs: Bool = false
    var _satisfiesPzi: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _description_p = source._description_p
      _metadataSchemaUri = source._metadataSchemaUri
      _metadata = source._metadata
      _deployedIndexes = source._deployedIndexes
      _etag = source._etag
      _labels = source._labels
      _createTime = source._createTime
      _updateTime = source._updateTime
      _indexStats = source._indexStats
      _indexUpdateMethod = source._indexUpdateMethod
      _encryptionSpec = source._encryptionSpec
      _satisfiesPzs = source._satisfiesPzs
      _satisfiesPzi = source._satisfiesPzi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._metadataSchemaUri) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._deployedIndexes) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._etag) }()
        case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._indexStats) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._indexUpdateMethod) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._encryptionSpec) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzs) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzi) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if !_storage._metadataSchemaUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadataSchemaUri, fieldNumber: 4)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._deployedIndexes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deployedIndexes, fieldNumber: 7)
      }
      if !_storage._etag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._etag, fieldNumber: 8)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 9)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._indexStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._indexUpdateMethod != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._indexUpdateMethod, fieldNumber: 16)
      }
      try { if let v = _storage._encryptionSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if _storage._satisfiesPzs != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzs, fieldNumber: 18)
      }
      if _storage._satisfiesPzi != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzi, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Index, rhs: Google_Cloud_Aiplatform_V1_Index) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._metadataSchemaUri != rhs_storage._metadataSchemaUri {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._deployedIndexes != rhs_storage._deployedIndexes {return false}
        if _storage._etag != rhs_storage._etag {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._indexStats != rhs_storage._indexStats {return false}
        if _storage._indexUpdateMethod != rhs_storage._indexUpdateMethod {return false}
        if _storage._encryptionSpec != rhs_storage._encryptionSpec {return false}
        if _storage._satisfiesPzs != rhs_storage._satisfiesPzs {return false}
        if _storage._satisfiesPzi != rhs_storage._satisfiesPzi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Index.IndexUpdateMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INDEX_UPDATE_METHOD_UNSPECIFIED"),
    1: .same(proto: "BATCH_UPDATE"),
    2: .same(proto: "STREAM_UPDATE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_IndexDatapoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexDatapoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "datapoint_id"),
    2: .standard(proto: "feature_vector"),
    7: .standard(proto: "sparse_embedding"),
    4: .same(proto: "restricts"),
    6: .standard(proto: "numeric_restricts"),
    5: .standard(proto: "crowding_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datapointID) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.featureVector) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.restricts) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._crowdingTag) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.numericRestricts) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._sparseEmbedding) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.datapointID.isEmpty {
      try visitor.visitSingularStringField(value: self.datapointID, fieldNumber: 1)
    }
    if !self.featureVector.isEmpty {
      try visitor.visitPackedFloatField(value: self.featureVector, fieldNumber: 2)
    }
    if !self.restricts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.restricts, fieldNumber: 4)
    }
    try { if let v = self._crowdingTag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.numericRestricts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.numericRestricts, fieldNumber: 6)
    }
    try { if let v = self._sparseEmbedding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_IndexDatapoint, rhs: Google_Cloud_Aiplatform_V1_IndexDatapoint) -> Bool {
    if lhs.datapointID != rhs.datapointID {return false}
    if lhs.featureVector != rhs.featureVector {return false}
    if lhs._sparseEmbedding != rhs._sparseEmbedding {return false}
    if lhs.restricts != rhs.restricts {return false}
    if lhs.numericRestricts != rhs.numericRestricts {return false}
    if lhs._crowdingTag != rhs._crowdingTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_IndexDatapoint.SparseEmbedding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_IndexDatapoint.protoMessageName + ".SparseEmbedding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "dimensions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.values) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.dimensions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedFloatField(value: self.values, fieldNumber: 1)
    }
    if !self.dimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.dimensions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.SparseEmbedding, rhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.SparseEmbedding) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.dimensions != rhs.dimensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_IndexDatapoint.Restriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_IndexDatapoint.protoMessageName + ".Restriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .standard(proto: "allow_list"),
    3: .standard(proto: "deny_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowList) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.denyList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.allowList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowList, fieldNumber: 2)
    }
    if !self.denyList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.denyList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.Restriction, rhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.Restriction) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.allowList != rhs.allowList {return false}
    if lhs.denyList != rhs.denyList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_IndexDatapoint.protoMessageName + ".NumericRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "value_int"),
    3: .standard(proto: "value_float"),
    4: .standard(proto: "value_double"),
    1: .same(proto: "namespace"),
    5: .same(proto: "op"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .valueInt(v)
        }
      }()
      case 3: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .valueFloat(v)
        }
      }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .valueDouble(v)
        }
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    switch self.value {
    case .valueInt?: try {
      guard case .valueInt(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .valueFloat?: try {
      guard case .valueFloat(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }()
    case .valueDouble?: try {
      guard case .valueDouble(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction, rhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.op != rhs.op {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_IndexDatapoint.NumericRestriction.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "LESS"),
    2: .same(proto: "LESS_EQUAL"),
    3: .same(proto: "EQUAL"),
    4: .same(proto: "GREATER_EQUAL"),
    5: .same(proto: "GREATER"),
    6: .same(proto: "NOT_EQUAL"),
  ]
}

extension Google_Cloud_Aiplatform_V1_IndexDatapoint.CrowdingTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_IndexDatapoint.protoMessageName + ".CrowdingTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crowding_attribute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.crowdingAttribute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.crowdingAttribute.isEmpty {
      try visitor.visitSingularStringField(value: self.crowdingAttribute, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.CrowdingTag, rhs: Google_Cloud_Aiplatform_V1_IndexDatapoint.CrowdingTag) -> Bool {
    if lhs.crowdingAttribute != rhs.crowdingAttribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_IndexStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vectors_count"),
    3: .standard(proto: "sparse_vectors_count"),
    2: .standard(proto: "shards_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.vectorsCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.shardsCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.sparseVectorsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vectorsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.vectorsCount, fieldNumber: 1)
    }
    if self.shardsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.shardsCount, fieldNumber: 2)
    }
    if self.sparseVectorsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.sparseVectorsCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_IndexStats, rhs: Google_Cloud_Aiplatform_V1_IndexStats) -> Bool {
    if lhs.vectorsCount != rhs.vectorsCount {return false}
    if lhs.sparseVectorsCount != rhs.sparseVectorsCount {return false}
    if lhs.shardsCount != rhs.shardsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
