// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/schedule.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An instance of a Schedule periodically schedules runs to make API calls based
/// on user specified time specification and API request type.
public struct Google_Cloud_Aiplatform_V1_Schedule: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  /// The time specification to launch scheduled runs.
  public var timeSpecification: OneOf_TimeSpecification? {
    get {return _storage._timeSpecification}
    set {_uniqueStorage()._timeSpecification = newValue}
  }

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs. To explicitly set a timezone to the cron tab, apply a prefix in the
  /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
  /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
  /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
  /// "TZ=America/New_York 1 * * * *".
  public var cron: String {
    get {
      if case .cron(let v)? = _storage._timeSpecification {return v}
      return String()
    }
    set {_uniqueStorage()._timeSpecification = .cron(newValue)}
  }

  /// Required.
  /// The API request template to launch the scheduled runs.
  /// User-specified ID is not supported in the request template.
  public var request: OneOf_Request? {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  /// Request for
  /// [PipelineService.CreatePipelineJob][google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob].
  /// CreatePipelineJobRequest.parent field is required (format:
  /// projects/{project}/locations/{location}).
  public var createPipelineJobRequest: Google_Cloud_Aiplatform_V1_CreatePipelineJobRequest {
    get {
      if case .createPipelineJobRequest(let v)? = _storage._request {return v}
      return Google_Cloud_Aiplatform_V1_CreatePipelineJobRequest()
    }
    set {_uniqueStorage()._request = .createPipelineJobRequest(newValue)}
  }

  /// Immutable. The resource name of the Schedule.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. User provided name of the Schedule.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Optional. Timestamp after which the first run can be scheduled.
  /// Default to Schedule create time if not specified.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Optional. Timestamp after which no new runs can be scheduled.
  /// If specified, The schedule will be completed when either
  /// end_time is reached or when scheduled_run_count >= max_run_count.
  /// If not specified, new runs will keep getting scheduled until this Schedule
  /// is paused or deleted. Already scheduled runs will be allowed to complete.
  /// Unset if not specified.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Optional. Maximum run count of the schedule.
  /// If specified, The schedule will be completed when either
  /// started_run_count >= max_run_count or when end_time is reached.
  /// If not specified, new runs will keep getting scheduled until this Schedule
  /// is paused or deleted. Already scheduled runs will be allowed to complete.
  /// Unset if not specified.
  public var maxRunCount: Int64 {
    get {return _storage._maxRunCount}
    set {_uniqueStorage()._maxRunCount = newValue}
  }

  /// Output only. The number of runs started by this schedule.
  public var startedRunCount: Int64 {
    get {return _storage._startedRunCount}
    set {_uniqueStorage()._startedRunCount = newValue}
  }

  /// Output only. The state of this Schedule.
  public var state: Google_Cloud_Aiplatform_V1_Schedule.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. Timestamp when this Schedule was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Timestamp when this Schedule was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. Timestamp when this Schedule should schedule the next run.
  /// Having a next_run_time in the past means the runs are being started
  /// behind schedule.
  public var nextRunTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._nextRunTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._nextRunTime = newValue}
  }
  /// Returns true if `nextRunTime` has been explicitly set.
  public var hasNextRunTime: Bool {return _storage._nextRunTime != nil}
  /// Clears the value of `nextRunTime`. Subsequent reads from it will return its default value.
  public mutating func clearNextRunTime() {_uniqueStorage()._nextRunTime = nil}

  /// Output only. Timestamp when this Schedule was last paused.
  /// Unset if never paused.
  public var lastPauseTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastPauseTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastPauseTime = newValue}
  }
  /// Returns true if `lastPauseTime` has been explicitly set.
  public var hasLastPauseTime: Bool {return _storage._lastPauseTime != nil}
  /// Clears the value of `lastPauseTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastPauseTime() {_uniqueStorage()._lastPauseTime = nil}

  /// Output only. Timestamp when this Schedule was last resumed.
  /// Unset if never resumed from pause.
  public var lastResumeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastResumeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastResumeTime = newValue}
  }
  /// Returns true if `lastResumeTime` has been explicitly set.
  public var hasLastResumeTime: Bool {return _storage._lastResumeTime != nil}
  /// Clears the value of `lastResumeTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastResumeTime() {_uniqueStorage()._lastResumeTime = nil}

  /// Required. Maximum number of runs that can be started concurrently for this
  /// Schedule. This is the limit for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  public var maxConcurrentRunCount: Int64 {
    get {return _storage._maxConcurrentRunCount}
    set {_uniqueStorage()._maxConcurrentRunCount = newValue}
  }

  /// Optional. Whether new scheduled runs can be queued when max_concurrent_runs
  /// limit is reached. If set to true, new runs will be queued instead of
  /// skipped. Default to false.
  public var allowQueueing: Bool {
    get {return _storage._allowQueueing}
    set {_uniqueStorage()._allowQueueing = newValue}
  }

  /// Output only. Whether to backfill missed runs when the schedule is resumed
  /// from PAUSED state. If set to true, all missed runs will be scheduled. New
  /// runs will be scheduled after the backfill is complete. Default to false.
  public var catchUp: Bool {
    get {return _storage._catchUp}
    set {_uniqueStorage()._catchUp = newValue}
  }

  /// Output only. Response of the last scheduled run.
  /// This is the response for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  /// Unset if no run has been scheduled yet.
  public var lastScheduledRunResponse: Google_Cloud_Aiplatform_V1_Schedule.RunResponse {
    get {return _storage._lastScheduledRunResponse ?? Google_Cloud_Aiplatform_V1_Schedule.RunResponse()}
    set {_uniqueStorage()._lastScheduledRunResponse = newValue}
  }
  /// Returns true if `lastScheduledRunResponse` has been explicitly set.
  public var hasLastScheduledRunResponse: Bool {return _storage._lastScheduledRunResponse != nil}
  /// Clears the value of `lastScheduledRunResponse`. Subsequent reads from it will return its default value.
  public mutating func clearLastScheduledRunResponse() {_uniqueStorage()._lastScheduledRunResponse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required.
  /// The time specification to launch scheduled runs.
  public enum OneOf_TimeSpecification: Equatable, Sendable {
    /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
    /// runs. To explicitly set a timezone to the cron tab, apply a prefix in the
    /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
    /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
    /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
    /// "TZ=America/New_York 1 * * * *".
    case cron(String)

  }

  /// Required.
  /// The API request template to launch the scheduled runs.
  /// User-specified ID is not supported in the request template.
  public enum OneOf_Request: Equatable, Sendable {
    /// Request for
    /// [PipelineService.CreatePipelineJob][google.cloud.aiplatform.v1.PipelineService.CreatePipelineJob].
    /// CreatePipelineJobRequest.parent field is required (format:
    /// projects/{project}/locations/{location}).
    case createPipelineJobRequest(Google_Cloud_Aiplatform_V1_CreatePipelineJobRequest)

  }

  /// Possible state of the schedule.
  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// The Schedule is active. Runs are being scheduled on the user-specified
    /// timespec.
    case active // = 1

    /// The schedule is paused. No new runs will be created until the schedule
    /// is resumed. Already started runs will be allowed to complete.
    case paused // = 2

    /// The Schedule is completed. No new runs will be scheduled. Already started
    /// runs will be allowed to complete. Schedules in completed state cannot be
    /// paused or resumed.
    case completed // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .paused
      case 3: self = .completed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .paused: return 2
      case .completed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Schedule.State] = [
      .unspecified,
      .active,
      .paused,
      .completed,
    ]

  }

  /// Status of a scheduled run.
  public struct RunResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The scheduled run time based on the user-specified schedule.
    public var scheduledRunTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _scheduledRunTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_scheduledRunTime = newValue}
    }
    /// Returns true if `scheduledRunTime` has been explicitly set.
    public var hasScheduledRunTime: Bool {return self._scheduledRunTime != nil}
    /// Clears the value of `scheduledRunTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduledRunTime() {self._scheduledRunTime = nil}

    /// The response of the scheduled run.
    public var runResponse: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _scheduledRunTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "cron"),
    14: .standard(proto: "create_pipeline_job_request"),
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
    16: .standard(proto: "max_run_count"),
    17: .standard(proto: "started_run_count"),
    5: .same(proto: "state"),
    6: .standard(proto: "create_time"),
    19: .standard(proto: "update_time"),
    7: .standard(proto: "next_run_time"),
    8: .standard(proto: "last_pause_time"),
    9: .standard(proto: "last_resume_time"),
    11: .standard(proto: "max_concurrent_run_count"),
    12: .standard(proto: "allow_queueing"),
    13: .standard(proto: "catch_up"),
    18: .standard(proto: "last_scheduled_run_response"),
  ]

  fileprivate class _StorageClass {
    var _timeSpecification: Google_Cloud_Aiplatform_V1_Schedule.OneOf_TimeSpecification?
    var _request: Google_Cloud_Aiplatform_V1_Schedule.OneOf_Request?
    var _name: String = String()
    var _displayName: String = String()
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _maxRunCount: Int64 = 0
    var _startedRunCount: Int64 = 0
    var _state: Google_Cloud_Aiplatform_V1_Schedule.State = .unspecified
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nextRunTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastPauseTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastResumeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _maxConcurrentRunCount: Int64 = 0
    var _allowQueueing: Bool = false
    var _catchUp: Bool = false
    var _lastScheduledRunResponse: Google_Cloud_Aiplatform_V1_Schedule.RunResponse? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _timeSpecification = source._timeSpecification
      _request = source._request
      _name = source._name
      _displayName = source._displayName
      _startTime = source._startTime
      _endTime = source._endTime
      _maxRunCount = source._maxRunCount
      _startedRunCount = source._startedRunCount
      _state = source._state
      _createTime = source._createTime
      _updateTime = source._updateTime
      _nextRunTime = source._nextRunTime
      _lastPauseTime = source._lastPauseTime
      _lastResumeTime = source._lastResumeTime
      _maxConcurrentRunCount = source._maxConcurrentRunCount
      _allowQueueing = source._allowQueueing
      _catchUp = source._catchUp
      _lastScheduledRunResponse = source._lastScheduledRunResponse
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._nextRunTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastPauseTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lastResumeTime) }()
        case 10: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._timeSpecification != nil {try decoder.handleConflictingOneOf()}
            _storage._timeSpecification = .cron(v)
          }
        }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._maxConcurrentRunCount) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._allowQueueing) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._catchUp) }()
        case 14: try {
          var v: Google_Cloud_Aiplatform_V1_CreatePipelineJobRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .createPipelineJobRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .createPipelineJobRequest(v)
          }
        }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._maxRunCount) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._startedRunCount) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._lastScheduledRunResponse) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 5)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._nextRunTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastPauseTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._lastResumeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if case .cron(let v)? = _storage._timeSpecification {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      if _storage._maxConcurrentRunCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxConcurrentRunCount, fieldNumber: 11)
      }
      if _storage._allowQueueing != false {
        try visitor.visitSingularBoolField(value: _storage._allowQueueing, fieldNumber: 12)
      }
      if _storage._catchUp != false {
        try visitor.visitSingularBoolField(value: _storage._catchUp, fieldNumber: 13)
      }
      try { if case .createPipelineJobRequest(let v)? = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._maxRunCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxRunCount, fieldNumber: 16)
      }
      if _storage._startedRunCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._startedRunCount, fieldNumber: 17)
      }
      try { if let v = _storage._lastScheduledRunResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Schedule, rhs: Google_Cloud_Aiplatform_V1_Schedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeSpecification != rhs_storage._timeSpecification {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._maxRunCount != rhs_storage._maxRunCount {return false}
        if _storage._startedRunCount != rhs_storage._startedRunCount {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._nextRunTime != rhs_storage._nextRunTime {return false}
        if _storage._lastPauseTime != rhs_storage._lastPauseTime {return false}
        if _storage._lastResumeTime != rhs_storage._lastResumeTime {return false}
        if _storage._maxConcurrentRunCount != rhs_storage._maxConcurrentRunCount {return false}
        if _storage._allowQueueing != rhs_storage._allowQueueing {return false}
        if _storage._catchUp != rhs_storage._catchUp {return false}
        if _storage._lastScheduledRunResponse != rhs_storage._lastScheduledRunResponse {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Schedule.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "PAUSED"),
    3: .same(proto: "COMPLETED"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Schedule.RunResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Schedule.protoMessageName + ".RunResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scheduled_run_time"),
    2: .standard(proto: "run_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scheduledRunTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runResponse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scheduledRunTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.runResponse.isEmpty {
      try visitor.visitSingularStringField(value: self.runResponse, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Schedule.RunResponse, rhs: Google_Cloud_Aiplatform_V1_Schedule.RunResponse) -> Bool {
    if lhs._scheduledRunTime != rhs._scheduledRunTime {return false}
    if lhs.runResponse != rhs.runResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
