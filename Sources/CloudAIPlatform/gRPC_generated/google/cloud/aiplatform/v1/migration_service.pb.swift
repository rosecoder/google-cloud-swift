// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/migration_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for
/// [MigrationService.SearchMigratableResources][google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources].
public struct Google_Cloud_Aiplatform_V1_SearchMigratableResourcesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The location that the migratable resources should be searched
  /// from. It's the Vertex AI location that the resources can be migrated to,
  /// not the resources' original location. Format:
  /// `projects/{project}/locations/{location}`
  public var parent: String = String()

  /// The standard page size.
  /// The default and maximum value is 100.
  public var pageSize: Int32 = 0

  /// The standard page token.
  public var pageToken: String = String()

  /// A filter for your search. You can use the following types of filters:
  ///
  /// *   Resource type filters. The following strings filter for a specific type
  ///     of [MigratableResource][google.cloud.aiplatform.v1.MigratableResource]:
  ///     *   `ml_engine_model_version:*`
  ///     *   `automl_model:*`
  ///     *   `automl_dataset:*`
  ///     *   `data_labeling_dataset:*`
  /// *   "Migrated or not" filters. The following strings filter for resources
  ///     that either have or have not already been migrated:
  ///     *   `last_migrate_time:*` filters for migrated resources.
  ///     *   `NOT last_migrate_time:*` filters for not yet migrated resources.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [MigrationService.SearchMigratableResources][google.cloud.aiplatform.v1.MigrationService.SearchMigratableResources].
public struct Google_Cloud_Aiplatform_V1_SearchMigratableResourcesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All migratable resources that can be migrated to the
  /// location specified in the request.
  public var migratableResources: [Google_Cloud_Aiplatform_V1_MigratableResource] = []

  /// The standard next-page token.
  /// The migratable_resources may not fill page_size in
  /// SearchMigratableResourcesRequest even when there are subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
public struct Google_Cloud_Aiplatform_V1_BatchMigrateResourcesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The location of the migrated resource will live in.
  /// Format: `projects/{project}/locations/{location}`
  public var parent: String = String()

  /// Required. The request messages specifying the resources to migrate.
  /// They must be in the same location as the destination.
  /// Up to 50 resources can be migrated in one batch.
  public var migrateResourceRequests: [Google_Cloud_Aiplatform_V1_MigrateResourceRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
public struct Google_Cloud_Aiplatform_V1_MigrateResourceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.OneOf_Request? = nil

  /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
  public var migrateMlEngineModelVersionConfig: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateMlEngineModelVersionConfig {
    get {
      if case .migrateMlEngineModelVersionConfig(let v)? = request {return v}
      return Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateMlEngineModelVersionConfig()
    }
    set {request = .migrateMlEngineModelVersionConfig(newValue)}
  }

  /// Config for migrating Model in automl.googleapis.com to Vertex AI's
  /// Model.
  public var migrateAutomlModelConfig: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlModelConfig {
    get {
      if case .migrateAutomlModelConfig(let v)? = request {return v}
      return Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlModelConfig()
    }
    set {request = .migrateAutomlModelConfig(newValue)}
  }

  /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
  /// Dataset.
  public var migrateAutomlDatasetConfig: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlDatasetConfig {
    get {
      if case .migrateAutomlDatasetConfig(let v)? = request {return v}
      return Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlDatasetConfig()
    }
    set {request = .migrateAutomlDatasetConfig(newValue)}
  }

  /// Config for migrating Dataset in datalabeling.googleapis.com to
  /// Vertex AI's Dataset.
  public var migrateDataLabelingDatasetConfig: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig {
    get {
      if case .migrateDataLabelingDatasetConfig(let v)? = request {return v}
      return Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig()
    }
    set {request = .migrateDataLabelingDatasetConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
    case migrateMlEngineModelVersionConfig(Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateMlEngineModelVersionConfig)
    /// Config for migrating Model in automl.googleapis.com to Vertex AI's
    /// Model.
    case migrateAutomlModelConfig(Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlModelConfig)
    /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
    /// Dataset.
    case migrateAutomlDatasetConfig(Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlDatasetConfig)
    /// Config for migrating Dataset in datalabeling.googleapis.com to
    /// Vertex AI's Dataset.
    case migrateDataLabelingDatasetConfig(Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig)

  }

  /// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
  public struct MigrateMlEngineModelVersionConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The ml.googleapis.com endpoint that this model version should
    /// be migrated from. Example values:
    ///
    /// * ml.googleapis.com
    ///
    /// * us-centrall-ml.googleapis.com
    ///
    /// * europe-west4-ml.googleapis.com
    ///
    /// * asia-east1-ml.googleapis.com
    public var endpoint: String = String()

    /// Required. Full resource name of ml engine model version.
    /// Format: `projects/{project}/models/{model}/versions/{version}`.
    public var modelVersion: String = String()

    /// Required. Display name of the model in Vertex AI.
    /// System will pick a display name if unspecified.
    public var modelDisplayName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
  public struct MigrateAutomlModelConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Full resource name of automl Model.
    /// Format:
    /// `projects/{project}/locations/{location}/models/{model}`.
    public var model: String = String()

    /// Optional. Display name of the model in Vertex AI.
    /// System will pick a display name if unspecified.
    public var modelDisplayName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
  /// Dataset.
  public struct MigrateAutomlDatasetConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Full resource name of automl Dataset.
    /// Format:
    /// `projects/{project}/locations/{location}/datasets/{dataset}`.
    public var dataset: String = String()

    /// Required. Display name of the Dataset in Vertex AI.
    /// System will pick a display name if unspecified.
    public var datasetDisplayName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Config for migrating Dataset in datalabeling.googleapis.com to Vertex
  /// AI's Dataset.
  public struct MigrateDataLabelingDatasetConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Full resource name of data labeling Dataset.
    /// Format:
    /// `projects/{project}/datasets/{dataset}`.
    public var dataset: String = String()

    /// Optional. Display name of the Dataset in Vertex AI.
    /// System will pick a display name if unspecified.
    public var datasetDisplayName: String = String()

    /// Optional. Configs for migrating AnnotatedDataset in
    /// datalabeling.googleapis.com to Vertex AI's SavedQuery. The specified
    /// AnnotatedDatasets have to belong to the datalabeling Dataset.
    public var migrateDataLabelingAnnotatedDatasetConfigs: [Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
    /// Vertex AI's SavedQuery.
    public struct MigrateDataLabelingAnnotatedDatasetConfig: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Full resource name of data labeling AnnotatedDataset.
      /// Format:
      /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
      public var annotatedDataset: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

/// Response message for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
public struct Google_Cloud_Aiplatform_V1_BatchMigrateResourcesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Successfully migrated resources.
  public var migrateResourceResponses: [Google_Cloud_Aiplatform_V1_MigrateResourceResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a successfully migrated resource.
public struct Google_Cloud_Aiplatform_V1_MigrateResourceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// After migration, the resource name in Vertex AI.
  public var migratedResource: Google_Cloud_Aiplatform_V1_MigrateResourceResponse.OneOf_MigratedResource? = nil

  /// Migrated Dataset's resource name.
  public var dataset: String {
    get {
      if case .dataset(let v)? = migratedResource {return v}
      return String()
    }
    set {migratedResource = .dataset(newValue)}
  }

  /// Migrated Model's resource name.
  public var model: String {
    get {
      if case .model(let v)? = migratedResource {return v}
      return String()
    }
    set {migratedResource = .model(newValue)}
  }

  /// Before migration, the identifier in ml.googleapis.com,
  /// automl.googleapis.com or datalabeling.googleapis.com.
  public var migratableResource: Google_Cloud_Aiplatform_V1_MigratableResource {
    get {return _migratableResource ?? Google_Cloud_Aiplatform_V1_MigratableResource()}
    set {_migratableResource = newValue}
  }
  /// Returns true if `migratableResource` has been explicitly set.
  public var hasMigratableResource: Bool {return self._migratableResource != nil}
  /// Clears the value of `migratableResource`. Subsequent reads from it will return its default value.
  public mutating func clearMigratableResource() {self._migratableResource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// After migration, the resource name in Vertex AI.
  public enum OneOf_MigratedResource: Equatable, Sendable {
    /// Migrated Dataset's resource name.
    case dataset(String)
    /// Migrated Model's resource name.
    case model(String)

  }

  public init() {}

  fileprivate var _migratableResource: Google_Cloud_Aiplatform_V1_MigratableResource? = nil
}

/// Runtime operation information for
/// [MigrationService.BatchMigrateResources][google.cloud.aiplatform.v1.MigrationService.BatchMigrateResources].
public struct Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The common part of the operation metadata.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  /// Partial results that reflect the latest migration operation progress.
  public var partialResults: [Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata.PartialResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents a partial result in batch migration operation for one
  /// [MigrateResourceRequest][google.cloud.aiplatform.v1.MigrateResourceRequest].
  public struct PartialResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If the resource's migration is ongoing, none of the result will be set.
    /// If the resource's migration is finished, either error or one of the
    /// migrated resource name will be filled.
    public var result: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata.PartialResult.OneOf_Result? = nil

    /// The error result of the migration request in case of failure.
    public var error: Google_Rpc_Status {
      get {
        if case .error(let v)? = result {return v}
        return Google_Rpc_Status()
      }
      set {result = .error(newValue)}
    }

    /// Migrated model resource name.
    public var model: String {
      get {
        if case .model(let v)? = result {return v}
        return String()
      }
      set {result = .model(newValue)}
    }

    /// Migrated dataset resource name.
    public var dataset: String {
      get {
        if case .dataset(let v)? = result {return v}
        return String()
      }
      set {result = .dataset(newValue)}
    }

    /// It's the same as the value in
    /// [MigrateResourceRequest.migrate_resource_requests][].
    public var request: Google_Cloud_Aiplatform_V1_MigrateResourceRequest {
      get {return _request ?? Google_Cloud_Aiplatform_V1_MigrateResourceRequest()}
      set {_request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return self._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {self._request = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If the resource's migration is ongoing, none of the result will be set.
    /// If the resource's migration is finished, either error or one of the
    /// migrated resource name will be filled.
    public enum OneOf_Result: Equatable, Sendable {
      /// The error result of the migration request in case of failure.
      case error(Google_Rpc_Status)
      /// Migrated model resource name.
      case model(String)
      /// Migrated dataset resource name.
      case dataset(String)

    }

    public init() {}

    fileprivate var _request: Google_Cloud_Aiplatform_V1_MigrateResourceRequest? = nil
  }

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_SearchMigratableResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMigratableResourcesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SearchMigratableResourcesRequest, rhs: Google_Cloud_Aiplatform_V1_SearchMigratableResourcesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SearchMigratableResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMigratableResourcesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "migratable_resources"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.migratableResources) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.migratableResources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.migratableResources, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SearchMigratableResourcesResponse, rhs: Google_Cloud_Aiplatform_V1_SearchMigratableResourcesResponse) -> Bool {
    if lhs.migratableResources != rhs.migratableResources {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchMigrateResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchMigrateResourcesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "migrate_resource_requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.migrateResourceRequests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.migrateResourceRequests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.migrateResourceRequests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesRequest, rhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.migrateResourceRequests != rhs.migrateResourceRequests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_MigrateResourceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MigrateResourceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "migrate_ml_engine_model_version_config"),
    2: .standard(proto: "migrate_automl_model_config"),
    3: .standard(proto: "migrate_automl_dataset_config"),
    4: .standard(proto: "migrate_data_labeling_dataset_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateMlEngineModelVersionConfig?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .migrateMlEngineModelVersionConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .migrateMlEngineModelVersionConfig(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlModelConfig?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .migrateAutomlModelConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .migrateAutomlModelConfig(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlDatasetConfig?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .migrateAutomlDatasetConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .migrateAutomlDatasetConfig(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .migrateDataLabelingDatasetConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .migrateDataLabelingDatasetConfig(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .migrateMlEngineModelVersionConfig?: try {
      guard case .migrateMlEngineModelVersionConfig(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .migrateAutomlModelConfig?: try {
      guard case .migrateAutomlModelConfig(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .migrateAutomlDatasetConfig?: try {
      guard case .migrateAutomlDatasetConfig(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .migrateDataLabelingDatasetConfig?: try {
      guard case .migrateDataLabelingDatasetConfig(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest, rhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateMlEngineModelVersionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_MigrateResourceRequest.protoMessageName + ".MigrateMlEngineModelVersionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoint"),
    2: .standard(proto: "model_version"),
    3: .standard(proto: "model_display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelDisplayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.modelVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersion, fieldNumber: 2)
    }
    if !self.modelDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.modelDisplayName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateMlEngineModelVersionConfig, rhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateMlEngineModelVersionConfig) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.modelVersion != rhs.modelVersion {return false}
    if lhs.modelDisplayName != rhs.modelDisplayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlModelConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_MigrateResourceRequest.protoMessageName + ".MigrateAutomlModelConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .standard(proto: "model_display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelDisplayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 1)
    }
    if !self.modelDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.modelDisplayName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlModelConfig, rhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlModelConfig) -> Bool {
    if lhs.model != rhs.model {return false}
    if lhs.modelDisplayName != rhs.modelDisplayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlDatasetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_MigrateResourceRequest.protoMessageName + ".MigrateAutomlDatasetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataset"),
    2: .standard(proto: "dataset_display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dataset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetDisplayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataset.isEmpty {
      try visitor.visitSingularStringField(value: self.dataset, fieldNumber: 1)
    }
    if !self.datasetDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetDisplayName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlDatasetConfig, rhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateAutomlDatasetConfig) -> Bool {
    if lhs.dataset != rhs.dataset {return false}
    if lhs.datasetDisplayName != rhs.datasetDisplayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_MigrateResourceRequest.protoMessageName + ".MigrateDataLabelingDatasetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataset"),
    2: .standard(proto: "dataset_display_name"),
    3: .standard(proto: "migrate_data_labeling_annotated_dataset_configs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dataset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetDisplayName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.migrateDataLabelingAnnotatedDatasetConfigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataset.isEmpty {
      try visitor.visitSingularStringField(value: self.dataset, fieldNumber: 1)
    }
    if !self.datasetDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetDisplayName, fieldNumber: 2)
    }
    if !self.migrateDataLabelingAnnotatedDatasetConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.migrateDataLabelingAnnotatedDatasetConfigs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig, rhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig) -> Bool {
    if lhs.dataset != rhs.dataset {return false}
    if lhs.datasetDisplayName != rhs.datasetDisplayName {return false}
    if lhs.migrateDataLabelingAnnotatedDatasetConfigs != rhs.migrateDataLabelingAnnotatedDatasetConfigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig.protoMessageName + ".MigrateDataLabelingAnnotatedDatasetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotated_dataset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotatedDataset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotatedDataset.isEmpty {
      try visitor.visitSingularStringField(value: self.annotatedDataset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig, rhs: Google_Cloud_Aiplatform_V1_MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig) -> Bool {
    if lhs.annotatedDataset != rhs.annotatedDataset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchMigrateResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchMigrateResourcesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "migrate_resource_responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.migrateResourceResponses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.migrateResourceResponses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.migrateResourceResponses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesResponse, rhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesResponse) -> Bool {
    if lhs.migrateResourceResponses != rhs.migrateResourceResponses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_MigrateResourceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MigrateResourceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataset"),
    2: .same(proto: "model"),
    3: .standard(proto: "migratable_resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.migratedResource != nil {try decoder.handleConflictingOneOf()}
          self.migratedResource = .dataset(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.migratedResource != nil {try decoder.handleConflictingOneOf()}
          self.migratedResource = .model(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._migratableResource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.migratedResource {
    case .dataset?: try {
      guard case .dataset(let v)? = self.migratedResource else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .model?: try {
      guard case .model(let v)? = self.migratedResource else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._migratableResource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_MigrateResourceResponse, rhs: Google_Cloud_Aiplatform_V1_MigrateResourceResponse) -> Bool {
    if lhs.migratedResource != rhs.migratedResource {return false}
    if lhs._migratableResource != rhs._migratableResource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchMigrateResourcesOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
    2: .standard(proto: "partial_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.partialResults) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.partialResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.partialResults, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.partialResults != rhs.partialResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata.PartialResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata.protoMessageName + ".PartialResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "error"),
    3: .same(proto: "model"),
    4: .same(proto: "dataset"),
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 2: try {
        var v: Google_Rpc_Status?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .model(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .dataset(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.result {
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .model?: try {
      guard case .model(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .dataset?: try {
      guard case .dataset(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata.PartialResult, rhs: Google_Cloud_Aiplatform_V1_BatchMigrateResourcesOperationMetadata.PartialResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
