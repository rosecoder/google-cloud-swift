// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/evaluation_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Pairwise prediction autorater preference.
public enum Google_Cloud_Aiplatform_V1_PairwiseChoice: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Unspecified prediction choice.
  case unspecified // = 0

  /// Baseline prediction wins
  case baseline // = 1

  /// Candidate prediction wins
  case candidate // = 2

  /// Winner cannot be determined
  case tie // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .baseline
    case 2: self = .candidate
    case 3: self = .tie
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .baseline: return 1
    case .candidate: return 2
    case .tie: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Cloud_Aiplatform_V1_PairwiseChoice] = [
    .unspecified,
    .baseline,
    .candidate,
    .tie,
  ]

}

/// Request message for EvaluationService.EvaluateInstances.
public struct Google_Cloud_Aiplatform_V1_EvaluateInstancesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Instances and specs for evaluation
  public var metricInputs: Google_Cloud_Aiplatform_V1_EvaluateInstancesRequest.OneOf_MetricInputs? = nil

  /// Auto metric instances.
  /// Instances and metric spec for exact match metric.
  public var exactMatchInput: Google_Cloud_Aiplatform_V1_ExactMatchInput {
    get {
      if case .exactMatchInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_ExactMatchInput()
    }
    set {metricInputs = .exactMatchInput(newValue)}
  }

  /// Instances and metric spec for bleu metric.
  public var bleuInput: Google_Cloud_Aiplatform_V1_BleuInput {
    get {
      if case .bleuInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_BleuInput()
    }
    set {metricInputs = .bleuInput(newValue)}
  }

  /// Instances and metric spec for rouge metric.
  public var rougeInput: Google_Cloud_Aiplatform_V1_RougeInput {
    get {
      if case .rougeInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_RougeInput()
    }
    set {metricInputs = .rougeInput(newValue)}
  }

  /// LLM-based metric instance.
  /// General text generation metrics, applicable to other categories.
  /// Input for fluency metric.
  public var fluencyInput: Google_Cloud_Aiplatform_V1_FluencyInput {
    get {
      if case .fluencyInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_FluencyInput()
    }
    set {metricInputs = .fluencyInput(newValue)}
  }

  /// Input for coherence metric.
  public var coherenceInput: Google_Cloud_Aiplatform_V1_CoherenceInput {
    get {
      if case .coherenceInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_CoherenceInput()
    }
    set {metricInputs = .coherenceInput(newValue)}
  }

  /// Input for safety metric.
  public var safetyInput: Google_Cloud_Aiplatform_V1_SafetyInput {
    get {
      if case .safetyInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_SafetyInput()
    }
    set {metricInputs = .safetyInput(newValue)}
  }

  /// Input for groundedness metric.
  public var groundednessInput: Google_Cloud_Aiplatform_V1_GroundednessInput {
    get {
      if case .groundednessInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_GroundednessInput()
    }
    set {metricInputs = .groundednessInput(newValue)}
  }

  /// Input for fulfillment metric.
  public var fulfillmentInput: Google_Cloud_Aiplatform_V1_FulfillmentInput {
    get {
      if case .fulfillmentInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_FulfillmentInput()
    }
    set {metricInputs = .fulfillmentInput(newValue)}
  }

  /// Input for summarization quality metric.
  public var summarizationQualityInput: Google_Cloud_Aiplatform_V1_SummarizationQualityInput {
    get {
      if case .summarizationQualityInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_SummarizationQualityInput()
    }
    set {metricInputs = .summarizationQualityInput(newValue)}
  }

  /// Input for pairwise summarization quality metric.
  public var pairwiseSummarizationQualityInput: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput {
    get {
      if case .pairwiseSummarizationQualityInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput()
    }
    set {metricInputs = .pairwiseSummarizationQualityInput(newValue)}
  }

  /// Input for summarization helpfulness metric.
  public var summarizationHelpfulnessInput: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput {
    get {
      if case .summarizationHelpfulnessInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput()
    }
    set {metricInputs = .summarizationHelpfulnessInput(newValue)}
  }

  /// Input for summarization verbosity metric.
  public var summarizationVerbosityInput: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput {
    get {
      if case .summarizationVerbosityInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput()
    }
    set {metricInputs = .summarizationVerbosityInput(newValue)}
  }

  /// Input for question answering quality metric.
  public var questionAnsweringQualityInput: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput {
    get {
      if case .questionAnsweringQualityInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput()
    }
    set {metricInputs = .questionAnsweringQualityInput(newValue)}
  }

  /// Input for pairwise question answering quality metric.
  public var pairwiseQuestionAnsweringQualityInput: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput {
    get {
      if case .pairwiseQuestionAnsweringQualityInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput()
    }
    set {metricInputs = .pairwiseQuestionAnsweringQualityInput(newValue)}
  }

  /// Input for question answering relevance metric.
  public var questionAnsweringRelevanceInput: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput {
    get {
      if case .questionAnsweringRelevanceInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput()
    }
    set {metricInputs = .questionAnsweringRelevanceInput(newValue)}
  }

  /// Input for question answering helpfulness
  /// metric.
  public var questionAnsweringHelpfulnessInput: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput {
    get {
      if case .questionAnsweringHelpfulnessInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput()
    }
    set {metricInputs = .questionAnsweringHelpfulnessInput(newValue)}
  }

  /// Input for question answering correctness
  /// metric.
  public var questionAnsweringCorrectnessInput: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput {
    get {
      if case .questionAnsweringCorrectnessInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput()
    }
    set {metricInputs = .questionAnsweringCorrectnessInput(newValue)}
  }

  /// Input for pointwise metric.
  public var pointwiseMetricInput: Google_Cloud_Aiplatform_V1_PointwiseMetricInput {
    get {
      if case .pointwiseMetricInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_PointwiseMetricInput()
    }
    set {metricInputs = .pointwiseMetricInput(newValue)}
  }

  /// Input for pairwise metric.
  public var pairwiseMetricInput: Google_Cloud_Aiplatform_V1_PairwiseMetricInput {
    get {
      if case .pairwiseMetricInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_PairwiseMetricInput()
    }
    set {metricInputs = .pairwiseMetricInput(newValue)}
  }

  /// Tool call metric instances.
  /// Input for tool call valid metric.
  public var toolCallValidInput: Google_Cloud_Aiplatform_V1_ToolCallValidInput {
    get {
      if case .toolCallValidInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_ToolCallValidInput()
    }
    set {metricInputs = .toolCallValidInput(newValue)}
  }

  /// Input for tool name match metric.
  public var toolNameMatchInput: Google_Cloud_Aiplatform_V1_ToolNameMatchInput {
    get {
      if case .toolNameMatchInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_ToolNameMatchInput()
    }
    set {metricInputs = .toolNameMatchInput(newValue)}
  }

  /// Input for tool parameter key match metric.
  public var toolParameterKeyMatchInput: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput {
    get {
      if case .toolParameterKeyMatchInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput()
    }
    set {metricInputs = .toolParameterKeyMatchInput(newValue)}
  }

  /// Input for tool parameter key value match metric.
  public var toolParameterKvMatchInput: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput {
    get {
      if case .toolParameterKvMatchInput(let v)? = metricInputs {return v}
      return Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput()
    }
    set {metricInputs = .toolParameterKvMatchInput(newValue)}
  }

  /// Required. The resource name of the Location to evaluate the instances.
  /// Format: `projects/{project}/locations/{location}`
  public var location: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Instances and specs for evaluation
  public enum OneOf_MetricInputs: Equatable, Sendable {
    /// Auto metric instances.
    /// Instances and metric spec for exact match metric.
    case exactMatchInput(Google_Cloud_Aiplatform_V1_ExactMatchInput)
    /// Instances and metric spec for bleu metric.
    case bleuInput(Google_Cloud_Aiplatform_V1_BleuInput)
    /// Instances and metric spec for rouge metric.
    case rougeInput(Google_Cloud_Aiplatform_V1_RougeInput)
    /// LLM-based metric instance.
    /// General text generation metrics, applicable to other categories.
    /// Input for fluency metric.
    case fluencyInput(Google_Cloud_Aiplatform_V1_FluencyInput)
    /// Input for coherence metric.
    case coherenceInput(Google_Cloud_Aiplatform_V1_CoherenceInput)
    /// Input for safety metric.
    case safetyInput(Google_Cloud_Aiplatform_V1_SafetyInput)
    /// Input for groundedness metric.
    case groundednessInput(Google_Cloud_Aiplatform_V1_GroundednessInput)
    /// Input for fulfillment metric.
    case fulfillmentInput(Google_Cloud_Aiplatform_V1_FulfillmentInput)
    /// Input for summarization quality metric.
    case summarizationQualityInput(Google_Cloud_Aiplatform_V1_SummarizationQualityInput)
    /// Input for pairwise summarization quality metric.
    case pairwiseSummarizationQualityInput(Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput)
    /// Input for summarization helpfulness metric.
    case summarizationHelpfulnessInput(Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput)
    /// Input for summarization verbosity metric.
    case summarizationVerbosityInput(Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput)
    /// Input for question answering quality metric.
    case questionAnsweringQualityInput(Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput)
    /// Input for pairwise question answering quality metric.
    case pairwiseQuestionAnsweringQualityInput(Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput)
    /// Input for question answering relevance metric.
    case questionAnsweringRelevanceInput(Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput)
    /// Input for question answering helpfulness
    /// metric.
    case questionAnsweringHelpfulnessInput(Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput)
    /// Input for question answering correctness
    /// metric.
    case questionAnsweringCorrectnessInput(Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput)
    /// Input for pointwise metric.
    case pointwiseMetricInput(Google_Cloud_Aiplatform_V1_PointwiseMetricInput)
    /// Input for pairwise metric.
    case pairwiseMetricInput(Google_Cloud_Aiplatform_V1_PairwiseMetricInput)
    /// Tool call metric instances.
    /// Input for tool call valid metric.
    case toolCallValidInput(Google_Cloud_Aiplatform_V1_ToolCallValidInput)
    /// Input for tool name match metric.
    case toolNameMatchInput(Google_Cloud_Aiplatform_V1_ToolNameMatchInput)
    /// Input for tool parameter key match metric.
    case toolParameterKeyMatchInput(Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput)
    /// Input for tool parameter key value match metric.
    case toolParameterKvMatchInput(Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput)

  }

  public init() {}
}

/// Response message for EvaluationService.EvaluateInstances.
public struct Google_Cloud_Aiplatform_V1_EvaluateInstancesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Evaluation results will be served in the same order as presented in
  /// EvaluationRequest.instances.
  public var evaluationResults: Google_Cloud_Aiplatform_V1_EvaluateInstancesResponse.OneOf_EvaluationResults? = nil

  /// Auto metric evaluation results.
  /// Results for exact match metric.
  public var exactMatchResults: Google_Cloud_Aiplatform_V1_ExactMatchResults {
    get {
      if case .exactMatchResults(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_ExactMatchResults()
    }
    set {evaluationResults = .exactMatchResults(newValue)}
  }

  /// Results for bleu metric.
  public var bleuResults: Google_Cloud_Aiplatform_V1_BleuResults {
    get {
      if case .bleuResults(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_BleuResults()
    }
    set {evaluationResults = .bleuResults(newValue)}
  }

  /// Results for rouge metric.
  public var rougeResults: Google_Cloud_Aiplatform_V1_RougeResults {
    get {
      if case .rougeResults(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_RougeResults()
    }
    set {evaluationResults = .rougeResults(newValue)}
  }

  /// LLM-based metric evaluation result.
  /// General text generation metrics, applicable to other categories.
  /// Result for fluency metric.
  public var fluencyResult: Google_Cloud_Aiplatform_V1_FluencyResult {
    get {
      if case .fluencyResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_FluencyResult()
    }
    set {evaluationResults = .fluencyResult(newValue)}
  }

  /// Result for coherence metric.
  public var coherenceResult: Google_Cloud_Aiplatform_V1_CoherenceResult {
    get {
      if case .coherenceResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_CoherenceResult()
    }
    set {evaluationResults = .coherenceResult(newValue)}
  }

  /// Result for safety metric.
  public var safetyResult: Google_Cloud_Aiplatform_V1_SafetyResult {
    get {
      if case .safetyResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_SafetyResult()
    }
    set {evaluationResults = .safetyResult(newValue)}
  }

  /// Result for groundedness metric.
  public var groundednessResult: Google_Cloud_Aiplatform_V1_GroundednessResult {
    get {
      if case .groundednessResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_GroundednessResult()
    }
    set {evaluationResults = .groundednessResult(newValue)}
  }

  /// Result for fulfillment metric.
  public var fulfillmentResult: Google_Cloud_Aiplatform_V1_FulfillmentResult {
    get {
      if case .fulfillmentResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_FulfillmentResult()
    }
    set {evaluationResults = .fulfillmentResult(newValue)}
  }

  /// Summarization only metrics.
  /// Result for summarization quality metric.
  public var summarizationQualityResult: Google_Cloud_Aiplatform_V1_SummarizationQualityResult {
    get {
      if case .summarizationQualityResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_SummarizationQualityResult()
    }
    set {evaluationResults = .summarizationQualityResult(newValue)}
  }

  /// Result for pairwise summarization quality metric.
  public var pairwiseSummarizationQualityResult: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult {
    get {
      if case .pairwiseSummarizationQualityResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult()
    }
    set {evaluationResults = .pairwiseSummarizationQualityResult(newValue)}
  }

  /// Result for summarization helpfulness metric.
  public var summarizationHelpfulnessResult: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult {
    get {
      if case .summarizationHelpfulnessResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult()
    }
    set {evaluationResults = .summarizationHelpfulnessResult(newValue)}
  }

  /// Result for summarization verbosity metric.
  public var summarizationVerbosityResult: Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult {
    get {
      if case .summarizationVerbosityResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult()
    }
    set {evaluationResults = .summarizationVerbosityResult(newValue)}
  }

  /// Question answering only metrics.
  /// Result for question answering quality metric.
  public var questionAnsweringQualityResult: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult {
    get {
      if case .questionAnsweringQualityResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult()
    }
    set {evaluationResults = .questionAnsweringQualityResult(newValue)}
  }

  /// Result for pairwise question answering quality metric.
  public var pairwiseQuestionAnsweringQualityResult: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult {
    get {
      if case .pairwiseQuestionAnsweringQualityResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult()
    }
    set {evaluationResults = .pairwiseQuestionAnsweringQualityResult(newValue)}
  }

  /// Result for question answering relevance metric.
  public var questionAnsweringRelevanceResult: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult {
    get {
      if case .questionAnsweringRelevanceResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult()
    }
    set {evaluationResults = .questionAnsweringRelevanceResult(newValue)}
  }

  /// Result for question answering helpfulness metric.
  public var questionAnsweringHelpfulnessResult: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult {
    get {
      if case .questionAnsweringHelpfulnessResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult()
    }
    set {evaluationResults = .questionAnsweringHelpfulnessResult(newValue)}
  }

  /// Result for question answering correctness metric.
  public var questionAnsweringCorrectnessResult: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult {
    get {
      if case .questionAnsweringCorrectnessResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult()
    }
    set {evaluationResults = .questionAnsweringCorrectnessResult(newValue)}
  }

  /// Generic metrics.
  /// Result for pointwise metric.
  public var pointwiseMetricResult: Google_Cloud_Aiplatform_V1_PointwiseMetricResult {
    get {
      if case .pointwiseMetricResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_PointwiseMetricResult()
    }
    set {evaluationResults = .pointwiseMetricResult(newValue)}
  }

  /// Result for pairwise metric.
  public var pairwiseMetricResult: Google_Cloud_Aiplatform_V1_PairwiseMetricResult {
    get {
      if case .pairwiseMetricResult(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_PairwiseMetricResult()
    }
    set {evaluationResults = .pairwiseMetricResult(newValue)}
  }

  /// Tool call metrics.
  ///  Results for tool call valid metric.
  public var toolCallValidResults: Google_Cloud_Aiplatform_V1_ToolCallValidResults {
    get {
      if case .toolCallValidResults(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_ToolCallValidResults()
    }
    set {evaluationResults = .toolCallValidResults(newValue)}
  }

  /// Results for tool name match metric.
  public var toolNameMatchResults: Google_Cloud_Aiplatform_V1_ToolNameMatchResults {
    get {
      if case .toolNameMatchResults(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_ToolNameMatchResults()
    }
    set {evaluationResults = .toolNameMatchResults(newValue)}
  }

  /// Results for tool parameter key match  metric.
  public var toolParameterKeyMatchResults: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults {
    get {
      if case .toolParameterKeyMatchResults(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults()
    }
    set {evaluationResults = .toolParameterKeyMatchResults(newValue)}
  }

  /// Results for tool parameter key value match metric.
  public var toolParameterKvMatchResults: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults {
    get {
      if case .toolParameterKvMatchResults(let v)? = evaluationResults {return v}
      return Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults()
    }
    set {evaluationResults = .toolParameterKvMatchResults(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Evaluation results will be served in the same order as presented in
  /// EvaluationRequest.instances.
  public enum OneOf_EvaluationResults: Equatable, Sendable {
    /// Auto metric evaluation results.
    /// Results for exact match metric.
    case exactMatchResults(Google_Cloud_Aiplatform_V1_ExactMatchResults)
    /// Results for bleu metric.
    case bleuResults(Google_Cloud_Aiplatform_V1_BleuResults)
    /// Results for rouge metric.
    case rougeResults(Google_Cloud_Aiplatform_V1_RougeResults)
    /// LLM-based metric evaluation result.
    /// General text generation metrics, applicable to other categories.
    /// Result for fluency metric.
    case fluencyResult(Google_Cloud_Aiplatform_V1_FluencyResult)
    /// Result for coherence metric.
    case coherenceResult(Google_Cloud_Aiplatform_V1_CoherenceResult)
    /// Result for safety metric.
    case safetyResult(Google_Cloud_Aiplatform_V1_SafetyResult)
    /// Result for groundedness metric.
    case groundednessResult(Google_Cloud_Aiplatform_V1_GroundednessResult)
    /// Result for fulfillment metric.
    case fulfillmentResult(Google_Cloud_Aiplatform_V1_FulfillmentResult)
    /// Summarization only metrics.
    /// Result for summarization quality metric.
    case summarizationQualityResult(Google_Cloud_Aiplatform_V1_SummarizationQualityResult)
    /// Result for pairwise summarization quality metric.
    case pairwiseSummarizationQualityResult(Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult)
    /// Result for summarization helpfulness metric.
    case summarizationHelpfulnessResult(Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult)
    /// Result for summarization verbosity metric.
    case summarizationVerbosityResult(Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult)
    /// Question answering only metrics.
    /// Result for question answering quality metric.
    case questionAnsweringQualityResult(Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult)
    /// Result for pairwise question answering quality metric.
    case pairwiseQuestionAnsweringQualityResult(Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult)
    /// Result for question answering relevance metric.
    case questionAnsweringRelevanceResult(Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult)
    /// Result for question answering helpfulness metric.
    case questionAnsweringHelpfulnessResult(Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult)
    /// Result for question answering correctness metric.
    case questionAnsweringCorrectnessResult(Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult)
    /// Generic metrics.
    /// Result for pointwise metric.
    case pointwiseMetricResult(Google_Cloud_Aiplatform_V1_PointwiseMetricResult)
    /// Result for pairwise metric.
    case pairwiseMetricResult(Google_Cloud_Aiplatform_V1_PairwiseMetricResult)
    /// Tool call metrics.
    ///  Results for tool call valid metric.
    case toolCallValidResults(Google_Cloud_Aiplatform_V1_ToolCallValidResults)
    /// Results for tool name match metric.
    case toolNameMatchResults(Google_Cloud_Aiplatform_V1_ToolNameMatchResults)
    /// Results for tool parameter key match  metric.
    case toolParameterKeyMatchResults(Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults)
    /// Results for tool parameter key value match metric.
    case toolParameterKvMatchResults(Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults)

  }

  public init() {}
}

/// Input for exact match metric.
public struct Google_Cloud_Aiplatform_V1_ExactMatchInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for exact match metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_ExactMatchSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_ExactMatchSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Repeated exact match instances.
  public var instances: [Google_Cloud_Aiplatform_V1_ExactMatchInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_ExactMatchSpec? = nil
}

/// Spec for exact match instance.
public struct Google_Cloud_Aiplatform_V1_ExactMatchInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
}

/// Spec for exact match metric - returns 1 if prediction and reference exactly
/// matches, otherwise 0.
public struct Google_Cloud_Aiplatform_V1_ExactMatchSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results for exact match metric.
public struct Google_Cloud_Aiplatform_V1_ExactMatchResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Exact match metric values.
  public var exactMatchMetricValues: [Google_Cloud_Aiplatform_V1_ExactMatchMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Exact match metric value for an instance.
public struct Google_Cloud_Aiplatform_V1_ExactMatchMetricValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Exact match score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

/// Input for bleu metric.
public struct Google_Cloud_Aiplatform_V1_BleuInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for bleu score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_BleuSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_BleuSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Repeated bleu instances.
  public var instances: [Google_Cloud_Aiplatform_V1_BleuInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_BleuSpec? = nil
}

/// Spec for bleu instance.
public struct Google_Cloud_Aiplatform_V1_BleuInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
}

/// Spec for bleu score metric - calculates the precision of n-grams in the
/// prediction as compared to reference - returns a score ranging between 0 to 1.
public struct Google_Cloud_Aiplatform_V1_BleuSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use_effective_order to compute bleu score.
  public var useEffectiveOrder: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results for bleu metric.
public struct Google_Cloud_Aiplatform_V1_BleuResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Bleu metric values.
  public var bleuMetricValues: [Google_Cloud_Aiplatform_V1_BleuMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Bleu metric value for an instance.
public struct Google_Cloud_Aiplatform_V1_BleuMetricValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Bleu score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

/// Input for rouge metric.
public struct Google_Cloud_Aiplatform_V1_RougeInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for rouge score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_RougeSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_RougeSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Repeated rouge instances.
  public var instances: [Google_Cloud_Aiplatform_V1_RougeInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_RougeSpec? = nil
}

/// Spec for rouge instance.
public struct Google_Cloud_Aiplatform_V1_RougeInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
}

/// Spec for rouge score metric - calculates the recall of n-grams in prediction
/// as compared to reference - returns a score ranging between 0 and 1.
public struct Google_Cloud_Aiplatform_V1_RougeSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Supported rouge types are rougen[1-9], rougeL, and rougeLsum.
  public var rougeType: String = String()

  /// Optional. Whether to use stemmer to compute rouge score.
  public var useStemmer: Bool = false

  /// Optional. Whether to split summaries while using rougeLsum.
  public var splitSummaries: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results for rouge metric.
public struct Google_Cloud_Aiplatform_V1_RougeResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Rouge metric values.
  public var rougeMetricValues: [Google_Cloud_Aiplatform_V1_RougeMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Rouge metric value for an instance.
public struct Google_Cloud_Aiplatform_V1_RougeMetricValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Rouge score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

/// Input for coherence metric.
public struct Google_Cloud_Aiplatform_V1_CoherenceInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for coherence score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_CoherenceSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_CoherenceSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Coherence instance.
  public var instance: Google_Cloud_Aiplatform_V1_CoherenceInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_CoherenceInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_CoherenceSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_CoherenceInstance? = nil
}

/// Spec for coherence instance.
public struct Google_Cloud_Aiplatform_V1_CoherenceInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
}

/// Spec for coherence score metric.
public struct Google_Cloud_Aiplatform_V1_CoherenceSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for coherence result.
public struct Google_Cloud_Aiplatform_V1_CoherenceResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Coherence score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for coherence score.
  public var explanation: String = String()

  /// Output only. Confidence for coherence score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for fluency metric.
public struct Google_Cloud_Aiplatform_V1_FluencyInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for fluency score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_FluencySpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_FluencySpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Fluency instance.
  public var instance: Google_Cloud_Aiplatform_V1_FluencyInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_FluencyInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_FluencySpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_FluencyInstance? = nil
}

/// Spec for fluency instance.
public struct Google_Cloud_Aiplatform_V1_FluencyInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
}

/// Spec for fluency score metric.
public struct Google_Cloud_Aiplatform_V1_FluencySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for fluency result.
public struct Google_Cloud_Aiplatform_V1_FluencyResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Fluency score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for fluency score.
  public var explanation: String = String()

  /// Output only. Confidence for fluency score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for safety metric.
public struct Google_Cloud_Aiplatform_V1_SafetyInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for safety metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_SafetySpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_SafetySpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Safety instance.
  public var instance: Google_Cloud_Aiplatform_V1_SafetyInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_SafetyInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_SafetySpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_SafetyInstance? = nil
}

/// Spec for safety instance.
public struct Google_Cloud_Aiplatform_V1_SafetyInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
}

/// Spec for safety metric.
public struct Google_Cloud_Aiplatform_V1_SafetySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for safety result.
public struct Google_Cloud_Aiplatform_V1_SafetyResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Safety score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for safety score.
  public var explanation: String = String()

  /// Output only. Confidence for safety score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for groundedness metric.
public struct Google_Cloud_Aiplatform_V1_GroundednessInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for groundedness metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_GroundednessSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_GroundednessSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Groundedness instance.
  public var instance: Google_Cloud_Aiplatform_V1_GroundednessInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_GroundednessInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_GroundednessSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_GroundednessInstance? = nil
}

/// Spec for groundedness instance.
public struct Google_Cloud_Aiplatform_V1_GroundednessInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Background information provided in context used to compare
  /// against the prediction.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _context: String? = nil
}

/// Spec for groundedness metric.
public struct Google_Cloud_Aiplatform_V1_GroundednessSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for groundedness result.
public struct Google_Cloud_Aiplatform_V1_GroundednessResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Groundedness score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for groundedness score.
  public var explanation: String = String()

  /// Output only. Confidence for groundedness score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for fulfillment metric.
public struct Google_Cloud_Aiplatform_V1_FulfillmentInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for fulfillment score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_FulfillmentSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_FulfillmentSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Fulfillment instance.
  public var instance: Google_Cloud_Aiplatform_V1_FulfillmentInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_FulfillmentInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_FulfillmentSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_FulfillmentInstance? = nil
}

/// Spec for fulfillment instance.
public struct Google_Cloud_Aiplatform_V1_FulfillmentInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Inference instruction prompt to compare prediction with.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for fulfillment metric.
public struct Google_Cloud_Aiplatform_V1_FulfillmentSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for fulfillment result.
public struct Google_Cloud_Aiplatform_V1_FulfillmentResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Fulfillment score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for fulfillment score.
  public var explanation: String = String()

  /// Output only. Confidence for fulfillment score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for summarization quality metric.
public struct Google_Cloud_Aiplatform_V1_SummarizationQualityInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for summarization quality score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_SummarizationQualitySpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_SummarizationQualitySpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Summarization quality instance.
  public var instance: Google_Cloud_Aiplatform_V1_SummarizationQualityInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_SummarizationQualityInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_SummarizationQualitySpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_SummarizationQualityInstance? = nil
}

/// Spec for summarization quality instance.
public struct Google_Cloud_Aiplatform_V1_SummarizationQualityInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Required. Text to be summarized.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Required. Summarization prompt for LLM.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for summarization quality score metric.
public struct Google_Cloud_Aiplatform_V1_SummarizationQualitySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute summarization
  /// quality.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for summarization quality result.
public struct Google_Cloud_Aiplatform_V1_SummarizationQualityResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Summarization Quality score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for summarization quality score.
  public var explanation: String = String()

  /// Output only. Confidence for summarization quality score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for pairwise summarization quality metric.
public struct Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for pairwise summarization quality score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualitySpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualitySpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Pairwise summarization quality instance.
  public var instance: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualitySpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInstance? = nil
}

/// Spec for pairwise summarization quality instance.
public struct Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the candidate model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Output of the baseline model.
  public var baselinePrediction: String {
    get {return _baselinePrediction ?? String()}
    set {_baselinePrediction = newValue}
  }
  /// Returns true if `baselinePrediction` has been explicitly set.
  public var hasBaselinePrediction: Bool {return self._baselinePrediction != nil}
  /// Clears the value of `baselinePrediction`. Subsequent reads from it will return its default value.
  public mutating func clearBaselinePrediction() {self._baselinePrediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Required. Text to be summarized.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Required. Summarization prompt for LLM.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _baselinePrediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for pairwise summarization quality score metric.
public struct Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualitySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute pairwise
  /// summarization quality.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for pairwise summarization quality result.
public struct Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Pairwise summarization prediction choice.
  public var pairwiseChoice: Google_Cloud_Aiplatform_V1_PairwiseChoice = .unspecified

  /// Output only. Explanation for summarization quality score.
  public var explanation: String = String()

  /// Output only. Confidence for summarization quality score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _confidence: Float? = nil
}

/// Input for summarization helpfulness metric.
public struct Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for summarization helpfulness score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Summarization helpfulness instance.
  public var instance: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInstance? = nil
}

/// Spec for summarization helpfulness instance.
public struct Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Required. Text to be summarized.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Optional. Summarization prompt for LLM.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for summarization helpfulness score metric.
public struct Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute summarization
  /// helpfulness.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for summarization helpfulness result.
public struct Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Summarization Helpfulness score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for summarization helpfulness score.
  public var explanation: String = String()

  /// Output only. Confidence for summarization helpfulness score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for summarization verbosity metric.
public struct Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for summarization verbosity score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_SummarizationVerbositySpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_SummarizationVerbositySpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Summarization verbosity instance.
  public var instance: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_SummarizationVerbosityInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_SummarizationVerbositySpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInstance? = nil
}

/// Spec for summarization verbosity instance.
public struct Google_Cloud_Aiplatform_V1_SummarizationVerbosityInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Required. Text to be summarized.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Optional. Summarization prompt for LLM.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for summarization verbosity score metric.
public struct Google_Cloud_Aiplatform_V1_SummarizationVerbositySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute summarization
  /// verbosity.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for summarization verbosity result.
public struct Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Summarization Verbosity score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for summarization verbosity score.
  public var explanation: String = String()

  /// Output only. Confidence for summarization verbosity score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for question answering quality metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for question answering quality score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualitySpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringQualitySpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Question answering quality instance.
  public var instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualitySpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInstance? = nil
}

/// Spec for question answering quality instance.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Required. Text to answer the question.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Required. Question Answering prompt for LLM.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for question answering quality score metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringQualitySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute question answering
  /// quality.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for question answering quality result.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Question Answering Quality score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for question answering quality score.
  public var explanation: String = String()

  /// Output only. Confidence for question answering quality score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for pairwise question answering quality metric.
public struct Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for pairwise question answering quality score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualitySpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualitySpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Pairwise question answering quality instance.
  public var instance: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualitySpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInstance? = nil
}

/// Spec for pairwise question answering quality instance.
public struct Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the candidate model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Output of the baseline model.
  public var baselinePrediction: String {
    get {return _baselinePrediction ?? String()}
    set {_baselinePrediction = newValue}
  }
  /// Returns true if `baselinePrediction` has been explicitly set.
  public var hasBaselinePrediction: Bool {return self._baselinePrediction != nil}
  /// Clears the value of `baselinePrediction`. Subsequent reads from it will return its default value.
  public mutating func clearBaselinePrediction() {self._baselinePrediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Required. Text to answer the question.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Required. Question Answering prompt for LLM.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _baselinePrediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for pairwise question answering quality score metric.
public struct Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualitySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute question answering
  /// quality.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for pairwise question answering quality result.
public struct Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Pairwise question answering prediction choice.
  public var pairwiseChoice: Google_Cloud_Aiplatform_V1_PairwiseChoice = .unspecified

  /// Output only. Explanation for question answering quality score.
  public var explanation: String = String()

  /// Output only. Confidence for question answering quality score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _confidence: Float? = nil
}

/// Input for question answering relevance metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for question answering relevance score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Question answering relevance instance.
  public var instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInstance? = nil
}

/// Spec for question answering relevance instance.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Optional. Text provided as context to answer the question.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Required. The question asked and other instruction in the inference prompt.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for question answering relevance metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute question answering
  /// relevance.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for question answering relevance result.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Question Answering Relevance score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for question answering relevance score.
  public var explanation: String = String()

  /// Output only. Confidence for question answering relevance score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for question answering helpfulness metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for question answering helpfulness score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Question answering helpfulness instance.
  public var instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInstance? = nil
}

/// Spec for question answering helpfulness instance.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Optional. Text provided as context to answer the question.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Required. The question asked and other instruction in the inference prompt.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for question answering helpfulness metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute question answering
  /// helpfulness.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for question answering helpfulness result.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Question Answering Helpfulness score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for question answering helpfulness score.
  public var explanation: String = String()

  /// Output only. Confidence for question answering helpfulness score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for question answering correctness metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for question answering correctness score metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Question answering correctness instance.
  public var instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInstance? = nil
}

/// Spec for question answering correctness instance.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Optional. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  /// Optional. Text provided as context to answer the question.
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// Required. The question asked and other instruction in the inference prompt.
  public var instruction: String {
    get {return _instruction ?? String()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
  fileprivate var _context: String? = nil
  fileprivate var _instruction: String? = nil
}

/// Spec for question answering correctness metric.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use instance.reference to compute question answering
  /// correctness.
  public var useReference: Bool = false

  /// Optional. Which version to use for evaluation.
  public var version: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for question answering correctness result.
public struct Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Question Answering Correctness score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for question answering correctness score.
  public var explanation: String = String()

  /// Output only. Confidence for question answering correctness score.
  public var confidence: Float {
    get {return _confidence ?? 0}
    set {_confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  public var hasConfidence: Bool {return self._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  public mutating func clearConfidence() {self._confidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
  fileprivate var _confidence: Float? = nil
}

/// Input for pointwise metric.
public struct Google_Cloud_Aiplatform_V1_PointwiseMetricInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for pointwise metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_PointwiseMetricSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_PointwiseMetricSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Pointwise metric instance.
  public var instance: Google_Cloud_Aiplatform_V1_PointwiseMetricInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_PointwiseMetricInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_PointwiseMetricSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_PointwiseMetricInstance? = nil
}

/// Pointwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
public struct Google_Cloud_Aiplatform_V1_PointwiseMetricInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Instance for pointwise metric.
  public var instance: Google_Cloud_Aiplatform_V1_PointwiseMetricInstance.OneOf_Instance? = nil

  /// Instance specified as a json string. String key-value pairs are expected
  /// in the json_instance to render
  /// PointwiseMetricSpec.instance_prompt_template.
  public var jsonInstance: String {
    get {
      if case .jsonInstance(let v)? = instance {return v}
      return String()
    }
    set {instance = .jsonInstance(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Instance for pointwise metric.
  public enum OneOf_Instance: Equatable, Sendable {
    /// Instance specified as a json string. String key-value pairs are expected
    /// in the json_instance to render
    /// PointwiseMetricSpec.instance_prompt_template.
    case jsonInstance(String)

  }

  public init() {}
}

/// Spec for pointwise metric.
public struct Google_Cloud_Aiplatform_V1_PointwiseMetricSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Metric prompt template for pointwise metric.
  public var metricPromptTemplate: String {
    get {return _metricPromptTemplate ?? String()}
    set {_metricPromptTemplate = newValue}
  }
  /// Returns true if `metricPromptTemplate` has been explicitly set.
  public var hasMetricPromptTemplate: Bool {return self._metricPromptTemplate != nil}
  /// Clears the value of `metricPromptTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearMetricPromptTemplate() {self._metricPromptTemplate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricPromptTemplate: String? = nil
}

/// Spec for pointwise metric result.
public struct Google_Cloud_Aiplatform_V1_PointwiseMetricResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Pointwise metric score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  /// Output only. Explanation for pointwise metric score.
  public var explanation: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

/// Input for pairwise metric.
public struct Google_Cloud_Aiplatform_V1_PairwiseMetricInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for pairwise metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_PairwiseMetricSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_PairwiseMetricSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Pairwise metric instance.
  public var instance: Google_Cloud_Aiplatform_V1_PairwiseMetricInstance {
    get {return _instance ?? Google_Cloud_Aiplatform_V1_PairwiseMetricInstance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_PairwiseMetricSpec? = nil
  fileprivate var _instance: Google_Cloud_Aiplatform_V1_PairwiseMetricInstance? = nil
}

/// Pairwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
public struct Google_Cloud_Aiplatform_V1_PairwiseMetricInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Instance for pairwise metric.
  public var instance: Google_Cloud_Aiplatform_V1_PairwiseMetricInstance.OneOf_Instance? = nil

  /// Instance specified as a json string. String key-value pairs are expected
  /// in the json_instance to render
  /// PairwiseMetricSpec.instance_prompt_template.
  public var jsonInstance: String {
    get {
      if case .jsonInstance(let v)? = instance {return v}
      return String()
    }
    set {instance = .jsonInstance(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Instance for pairwise metric.
  public enum OneOf_Instance: Equatable, Sendable {
    /// Instance specified as a json string. String key-value pairs are expected
    /// in the json_instance to render
    /// PairwiseMetricSpec.instance_prompt_template.
    case jsonInstance(String)

  }

  public init() {}
}

/// Spec for pairwise metric.
public struct Google_Cloud_Aiplatform_V1_PairwiseMetricSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Metric prompt template for pairwise metric.
  public var metricPromptTemplate: String {
    get {return _metricPromptTemplate ?? String()}
    set {_metricPromptTemplate = newValue}
  }
  /// Returns true if `metricPromptTemplate` has been explicitly set.
  public var hasMetricPromptTemplate: Bool {return self._metricPromptTemplate != nil}
  /// Clears the value of `metricPromptTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearMetricPromptTemplate() {self._metricPromptTemplate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricPromptTemplate: String? = nil
}

/// Spec for pairwise metric result.
public struct Google_Cloud_Aiplatform_V1_PairwiseMetricResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Pairwise metric choice.
  public var pairwiseChoice: Google_Cloud_Aiplatform_V1_PairwiseChoice = .unspecified

  /// Output only. Explanation for pairwise metric score.
  public var explanation: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Input for tool call valid metric.
public struct Google_Cloud_Aiplatform_V1_ToolCallValidInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for tool call valid metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_ToolCallValidSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_ToolCallValidSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Repeated tool call valid instances.
  public var instances: [Google_Cloud_Aiplatform_V1_ToolCallValidInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_ToolCallValidSpec? = nil
}

/// Spec for tool call valid metric.
public struct Google_Cloud_Aiplatform_V1_ToolCallValidSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for tool call valid instance.
public struct Google_Cloud_Aiplatform_V1_ToolCallValidInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
}

/// Results for tool call valid metric.
public struct Google_Cloud_Aiplatform_V1_ToolCallValidResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool call valid metric values.
  public var toolCallValidMetricValues: [Google_Cloud_Aiplatform_V1_ToolCallValidMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tool call valid metric value for an instance.
public struct Google_Cloud_Aiplatform_V1_ToolCallValidMetricValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool call valid score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

/// Input for tool name match metric.
public struct Google_Cloud_Aiplatform_V1_ToolNameMatchInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for tool name match metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_ToolNameMatchSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_ToolNameMatchSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Repeated tool name match instances.
  public var instances: [Google_Cloud_Aiplatform_V1_ToolNameMatchInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_ToolNameMatchSpec? = nil
}

/// Spec for tool name match metric.
public struct Google_Cloud_Aiplatform_V1_ToolNameMatchSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for tool name match instance.
public struct Google_Cloud_Aiplatform_V1_ToolNameMatchInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
}

/// Results for tool name match metric.
public struct Google_Cloud_Aiplatform_V1_ToolNameMatchResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool name match metric values.
  public var toolNameMatchMetricValues: [Google_Cloud_Aiplatform_V1_ToolNameMatchMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tool name match metric value for an instance.
public struct Google_Cloud_Aiplatform_V1_ToolNameMatchMetricValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool name match score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

/// Input for tool parameter key match metric.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for tool parameter key match metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Repeated tool parameter key match instances.
  public var instances: [Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchSpec? = nil
}

/// Spec for tool parameter key match metric.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for tool parameter key match instance.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
}

/// Results for tool parameter key match metric.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool parameter key match metric values.
  public var toolParameterKeyMatchMetricValues: [Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tool parameter key match metric value for an instance.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchMetricValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool parameter key match score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

/// Input for tool parameter key value match metric.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Spec for tool parameter key value match metric.
  public var metricSpec: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchSpec {
    get {return _metricSpec ?? Google_Cloud_Aiplatform_V1_ToolParameterKVMatchSpec()}
    set {_metricSpec = newValue}
  }
  /// Returns true if `metricSpec` has been explicitly set.
  public var hasMetricSpec: Bool {return self._metricSpec != nil}
  /// Clears the value of `metricSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMetricSpec() {self._metricSpec = nil}

  /// Required. Repeated tool parameter key value match instances.
  public var instances: [Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricSpec: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchSpec? = nil
}

/// Spec for tool parameter key value match metric.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKVMatchSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use STRCIT string match on parameter values.
  public var useStrictStringMatch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Spec for tool parameter key value match instance.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output of the evaluated model.
  public var prediction: String {
    get {return _prediction ?? String()}
    set {_prediction = newValue}
  }
  /// Returns true if `prediction` has been explicitly set.
  public var hasPrediction: Bool {return self._prediction != nil}
  /// Clears the value of `prediction`. Subsequent reads from it will return its default value.
  public mutating func clearPrediction() {self._prediction = nil}

  /// Required. Ground truth used to compare against the prediction.
  public var reference: String {
    get {return _reference ?? String()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prediction: String? = nil
  fileprivate var _reference: String? = nil
}

/// Results for tool parameter key value match metric.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool parameter key value match metric values.
  public var toolParameterKvMatchMetricValues: [Google_Cloud_Aiplatform_V1_ToolParameterKVMatchMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tool parameter key value match metric value for an instance.
public struct Google_Cloud_Aiplatform_V1_ToolParameterKVMatchMetricValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Tool parameter key value match score.
  public var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _score: Float? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_PairwiseChoice: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAIRWISE_CHOICE_UNSPECIFIED"),
    1: .same(proto: "BASELINE"),
    2: .same(proto: "CANDIDATE"),
    3: .same(proto: "TIE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_EvaluateInstancesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvaluateInstancesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "exact_match_input"),
    3: .standard(proto: "bleu_input"),
    4: .standard(proto: "rouge_input"),
    5: .standard(proto: "fluency_input"),
    6: .standard(proto: "coherence_input"),
    8: .standard(proto: "safety_input"),
    9: .standard(proto: "groundedness_input"),
    12: .standard(proto: "fulfillment_input"),
    7: .standard(proto: "summarization_quality_input"),
    23: .standard(proto: "pairwise_summarization_quality_input"),
    14: .standard(proto: "summarization_helpfulness_input"),
    15: .standard(proto: "summarization_verbosity_input"),
    10: .standard(proto: "question_answering_quality_input"),
    24: .standard(proto: "pairwise_question_answering_quality_input"),
    16: .standard(proto: "question_answering_relevance_input"),
    17: .standard(proto: "question_answering_helpfulness_input"),
    18: .standard(proto: "question_answering_correctness_input"),
    28: .standard(proto: "pointwise_metric_input"),
    29: .standard(proto: "pairwise_metric_input"),
    19: .standard(proto: "tool_call_valid_input"),
    20: .standard(proto: "tool_name_match_input"),
    21: .standard(proto: "tool_parameter_key_match_input"),
    22: .standard(proto: "tool_parameter_kv_match_input"),
    1: .same(proto: "location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_ExactMatchInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .exactMatchInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .exactMatchInput(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_BleuInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .bleuInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .bleuInput(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_RougeInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .rougeInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .rougeInput(v)
        }
      }()
      case 5: try {
        var v: Google_Cloud_Aiplatform_V1_FluencyInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .fluencyInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .fluencyInput(v)
        }
      }()
      case 6: try {
        var v: Google_Cloud_Aiplatform_V1_CoherenceInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .coherenceInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .coherenceInput(v)
        }
      }()
      case 7: try {
        var v: Google_Cloud_Aiplatform_V1_SummarizationQualityInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .summarizationQualityInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .summarizationQualityInput(v)
        }
      }()
      case 8: try {
        var v: Google_Cloud_Aiplatform_V1_SafetyInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .safetyInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .safetyInput(v)
        }
      }()
      case 9: try {
        var v: Google_Cloud_Aiplatform_V1_GroundednessInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .groundednessInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .groundednessInput(v)
        }
      }()
      case 10: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .questionAnsweringQualityInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .questionAnsweringQualityInput(v)
        }
      }()
      case 12: try {
        var v: Google_Cloud_Aiplatform_V1_FulfillmentInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .fulfillmentInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .fulfillmentInput(v)
        }
      }()
      case 14: try {
        var v: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .summarizationHelpfulnessInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .summarizationHelpfulnessInput(v)
        }
      }()
      case 15: try {
        var v: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .summarizationVerbosityInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .summarizationVerbosityInput(v)
        }
      }()
      case 16: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .questionAnsweringRelevanceInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .questionAnsweringRelevanceInput(v)
        }
      }()
      case 17: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .questionAnsweringHelpfulnessInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .questionAnsweringHelpfulnessInput(v)
        }
      }()
      case 18: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .questionAnsweringCorrectnessInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .questionAnsweringCorrectnessInput(v)
        }
      }()
      case 19: try {
        var v: Google_Cloud_Aiplatform_V1_ToolCallValidInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .toolCallValidInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .toolCallValidInput(v)
        }
      }()
      case 20: try {
        var v: Google_Cloud_Aiplatform_V1_ToolNameMatchInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .toolNameMatchInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .toolNameMatchInput(v)
        }
      }()
      case 21: try {
        var v: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .toolParameterKeyMatchInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .toolParameterKeyMatchInput(v)
        }
      }()
      case 22: try {
        var v: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .toolParameterKvMatchInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .toolParameterKvMatchInput(v)
        }
      }()
      case 23: try {
        var v: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .pairwiseSummarizationQualityInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .pairwiseSummarizationQualityInput(v)
        }
      }()
      case 24: try {
        var v: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .pairwiseQuestionAnsweringQualityInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .pairwiseQuestionAnsweringQualityInput(v)
        }
      }()
      case 28: try {
        var v: Google_Cloud_Aiplatform_V1_PointwiseMetricInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .pointwiseMetricInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .pointwiseMetricInput(v)
        }
      }()
      case 29: try {
        var v: Google_Cloud_Aiplatform_V1_PairwiseMetricInput?
        var hadOneofValue = false
        if let current = self.metricInputs {
          hadOneofValue = true
          if case .pairwiseMetricInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metricInputs = .pairwiseMetricInput(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    switch self.metricInputs {
    case .exactMatchInput?: try {
      guard case .exactMatchInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bleuInput?: try {
      guard case .bleuInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .rougeInput?: try {
      guard case .rougeInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .fluencyInput?: try {
      guard case .fluencyInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .coherenceInput?: try {
      guard case .coherenceInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .summarizationQualityInput?: try {
      guard case .summarizationQualityInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .safetyInput?: try {
      guard case .safetyInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .groundednessInput?: try {
      guard case .groundednessInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .questionAnsweringQualityInput?: try {
      guard case .questionAnsweringQualityInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .fulfillmentInput?: try {
      guard case .fulfillmentInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .summarizationHelpfulnessInput?: try {
      guard case .summarizationHelpfulnessInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .summarizationVerbosityInput?: try {
      guard case .summarizationVerbosityInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .questionAnsweringRelevanceInput?: try {
      guard case .questionAnsweringRelevanceInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .questionAnsweringHelpfulnessInput?: try {
      guard case .questionAnsweringHelpfulnessInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .questionAnsweringCorrectnessInput?: try {
      guard case .questionAnsweringCorrectnessInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .toolCallValidInput?: try {
      guard case .toolCallValidInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .toolNameMatchInput?: try {
      guard case .toolNameMatchInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .toolParameterKeyMatchInput?: try {
      guard case .toolParameterKeyMatchInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .toolParameterKvMatchInput?: try {
      guard case .toolParameterKvMatchInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .pairwiseSummarizationQualityInput?: try {
      guard case .pairwiseSummarizationQualityInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .pairwiseQuestionAnsweringQualityInput?: try {
      guard case .pairwiseQuestionAnsweringQualityInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .pointwiseMetricInput?: try {
      guard case .pointwiseMetricInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .pairwiseMetricInput?: try {
      guard case .pairwiseMetricInput(let v)? = self.metricInputs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_EvaluateInstancesRequest, rhs: Google_Cloud_Aiplatform_V1_EvaluateInstancesRequest) -> Bool {
    if lhs.metricInputs != rhs.metricInputs {return false}
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_EvaluateInstancesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvaluateInstancesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exact_match_results"),
    2: .standard(proto: "bleu_results"),
    3: .standard(proto: "rouge_results"),
    4: .standard(proto: "fluency_result"),
    5: .standard(proto: "coherence_result"),
    7: .standard(proto: "safety_result"),
    8: .standard(proto: "groundedness_result"),
    11: .standard(proto: "fulfillment_result"),
    6: .standard(proto: "summarization_quality_result"),
    22: .standard(proto: "pairwise_summarization_quality_result"),
    13: .standard(proto: "summarization_helpfulness_result"),
    14: .standard(proto: "summarization_verbosity_result"),
    9: .standard(proto: "question_answering_quality_result"),
    23: .standard(proto: "pairwise_question_answering_quality_result"),
    15: .standard(proto: "question_answering_relevance_result"),
    16: .standard(proto: "question_answering_helpfulness_result"),
    17: .standard(proto: "question_answering_correctness_result"),
    27: .standard(proto: "pointwise_metric_result"),
    28: .standard(proto: "pairwise_metric_result"),
    18: .standard(proto: "tool_call_valid_results"),
    19: .standard(proto: "tool_name_match_results"),
    20: .standard(proto: "tool_parameter_key_match_results"),
    21: .standard(proto: "tool_parameter_kv_match_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_ExactMatchResults?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .exactMatchResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .exactMatchResults(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_BleuResults?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .bleuResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .bleuResults(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_RougeResults?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .rougeResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .rougeResults(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_FluencyResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .fluencyResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .fluencyResult(v)
        }
      }()
      case 5: try {
        var v: Google_Cloud_Aiplatform_V1_CoherenceResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .coherenceResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .coherenceResult(v)
        }
      }()
      case 6: try {
        var v: Google_Cloud_Aiplatform_V1_SummarizationQualityResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .summarizationQualityResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .summarizationQualityResult(v)
        }
      }()
      case 7: try {
        var v: Google_Cloud_Aiplatform_V1_SafetyResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .safetyResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .safetyResult(v)
        }
      }()
      case 8: try {
        var v: Google_Cloud_Aiplatform_V1_GroundednessResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .groundednessResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .groundednessResult(v)
        }
      }()
      case 9: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .questionAnsweringQualityResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .questionAnsweringQualityResult(v)
        }
      }()
      case 11: try {
        var v: Google_Cloud_Aiplatform_V1_FulfillmentResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .fulfillmentResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .fulfillmentResult(v)
        }
      }()
      case 13: try {
        var v: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .summarizationHelpfulnessResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .summarizationHelpfulnessResult(v)
        }
      }()
      case 14: try {
        var v: Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .summarizationVerbosityResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .summarizationVerbosityResult(v)
        }
      }()
      case 15: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .questionAnsweringRelevanceResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .questionAnsweringRelevanceResult(v)
        }
      }()
      case 16: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .questionAnsweringHelpfulnessResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .questionAnsweringHelpfulnessResult(v)
        }
      }()
      case 17: try {
        var v: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .questionAnsweringCorrectnessResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .questionAnsweringCorrectnessResult(v)
        }
      }()
      case 18: try {
        var v: Google_Cloud_Aiplatform_V1_ToolCallValidResults?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .toolCallValidResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .toolCallValidResults(v)
        }
      }()
      case 19: try {
        var v: Google_Cloud_Aiplatform_V1_ToolNameMatchResults?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .toolNameMatchResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .toolNameMatchResults(v)
        }
      }()
      case 20: try {
        var v: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .toolParameterKeyMatchResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .toolParameterKeyMatchResults(v)
        }
      }()
      case 21: try {
        var v: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .toolParameterKvMatchResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .toolParameterKvMatchResults(v)
        }
      }()
      case 22: try {
        var v: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .pairwiseSummarizationQualityResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .pairwiseSummarizationQualityResult(v)
        }
      }()
      case 23: try {
        var v: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .pairwiseQuestionAnsweringQualityResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .pairwiseQuestionAnsweringQualityResult(v)
        }
      }()
      case 27: try {
        var v: Google_Cloud_Aiplatform_V1_PointwiseMetricResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .pointwiseMetricResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .pointwiseMetricResult(v)
        }
      }()
      case 28: try {
        var v: Google_Cloud_Aiplatform_V1_PairwiseMetricResult?
        var hadOneofValue = false
        if let current = self.evaluationResults {
          hadOneofValue = true
          if case .pairwiseMetricResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.evaluationResults = .pairwiseMetricResult(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.evaluationResults {
    case .exactMatchResults?: try {
      guard case .exactMatchResults(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .bleuResults?: try {
      guard case .bleuResults(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rougeResults?: try {
      guard case .rougeResults(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .fluencyResult?: try {
      guard case .fluencyResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .coherenceResult?: try {
      guard case .coherenceResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .summarizationQualityResult?: try {
      guard case .summarizationQualityResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .safetyResult?: try {
      guard case .safetyResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .groundednessResult?: try {
      guard case .groundednessResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .questionAnsweringQualityResult?: try {
      guard case .questionAnsweringQualityResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .fulfillmentResult?: try {
      guard case .fulfillmentResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .summarizationHelpfulnessResult?: try {
      guard case .summarizationHelpfulnessResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .summarizationVerbosityResult?: try {
      guard case .summarizationVerbosityResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .questionAnsweringRelevanceResult?: try {
      guard case .questionAnsweringRelevanceResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .questionAnsweringHelpfulnessResult?: try {
      guard case .questionAnsweringHelpfulnessResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .questionAnsweringCorrectnessResult?: try {
      guard case .questionAnsweringCorrectnessResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .toolCallValidResults?: try {
      guard case .toolCallValidResults(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .toolNameMatchResults?: try {
      guard case .toolNameMatchResults(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .toolParameterKeyMatchResults?: try {
      guard case .toolParameterKeyMatchResults(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .toolParameterKvMatchResults?: try {
      guard case .toolParameterKvMatchResults(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .pairwiseSummarizationQualityResult?: try {
      guard case .pairwiseSummarizationQualityResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .pairwiseQuestionAnsweringQualityResult?: try {
      guard case .pairwiseQuestionAnsweringQualityResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .pointwiseMetricResult?: try {
      guard case .pointwiseMetricResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .pairwiseMetricResult?: try {
      guard case .pairwiseMetricResult(let v)? = self.evaluationResults else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_EvaluateInstancesResponse, rhs: Google_Cloud_Aiplatform_V1_EvaluateInstancesResponse) -> Bool {
    if lhs.evaluationResults != rhs.evaluationResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExactMatchInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExactMatchInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExactMatchInput, rhs: Google_Cloud_Aiplatform_V1_ExactMatchInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExactMatchInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExactMatchInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExactMatchInstance, rhs: Google_Cloud_Aiplatform_V1_ExactMatchInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExactMatchSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExactMatchSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExactMatchSpec, rhs: Google_Cloud_Aiplatform_V1_ExactMatchSpec) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExactMatchResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExactMatchResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exact_match_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exactMatchMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exactMatchMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exactMatchMetricValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExactMatchResults, rhs: Google_Cloud_Aiplatform_V1_ExactMatchResults) -> Bool {
    if lhs.exactMatchMetricValues != rhs.exactMatchMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExactMatchMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExactMatchMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExactMatchMetricValue, rhs: Google_Cloud_Aiplatform_V1_ExactMatchMetricValue) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BleuInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BleuInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BleuInput, rhs: Google_Cloud_Aiplatform_V1_BleuInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BleuInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BleuInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BleuInstance, rhs: Google_Cloud_Aiplatform_V1_BleuInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BleuSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BleuSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_effective_order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useEffectiveOrder) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useEffectiveOrder != false {
      try visitor.visitSingularBoolField(value: self.useEffectiveOrder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BleuSpec, rhs: Google_Cloud_Aiplatform_V1_BleuSpec) -> Bool {
    if lhs.useEffectiveOrder != rhs.useEffectiveOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BleuResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BleuResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bleu_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bleuMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bleuMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bleuMetricValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BleuResults, rhs: Google_Cloud_Aiplatform_V1_BleuResults) -> Bool {
    if lhs.bleuMetricValues != rhs.bleuMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BleuMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BleuMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BleuMetricValue, rhs: Google_Cloud_Aiplatform_V1_BleuMetricValue) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RougeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RougeInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RougeInput, rhs: Google_Cloud_Aiplatform_V1_RougeInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RougeInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RougeInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RougeInstance, rhs: Google_Cloud_Aiplatform_V1_RougeInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RougeSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RougeSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rouge_type"),
    2: .standard(proto: "use_stemmer"),
    3: .standard(proto: "split_summaries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rougeType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.useStemmer) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.splitSummaries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rougeType.isEmpty {
      try visitor.visitSingularStringField(value: self.rougeType, fieldNumber: 1)
    }
    if self.useStemmer != false {
      try visitor.visitSingularBoolField(value: self.useStemmer, fieldNumber: 2)
    }
    if self.splitSummaries != false {
      try visitor.visitSingularBoolField(value: self.splitSummaries, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RougeSpec, rhs: Google_Cloud_Aiplatform_V1_RougeSpec) -> Bool {
    if lhs.rougeType != rhs.rougeType {return false}
    if lhs.useStemmer != rhs.useStemmer {return false}
    if lhs.splitSummaries != rhs.splitSummaries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RougeResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RougeResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rouge_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rougeMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rougeMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rougeMetricValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RougeResults, rhs: Google_Cloud_Aiplatform_V1_RougeResults) -> Bool {
    if lhs.rougeMetricValues != rhs.rougeMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_RougeMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RougeMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_RougeMetricValue, rhs: Google_Cloud_Aiplatform_V1_RougeMetricValue) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CoherenceInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoherenceInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CoherenceInput, rhs: Google_Cloud_Aiplatform_V1_CoherenceInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CoherenceInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoherenceInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CoherenceInstance, rhs: Google_Cloud_Aiplatform_V1_CoherenceInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CoherenceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoherenceSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CoherenceSpec, rhs: Google_Cloud_Aiplatform_V1_CoherenceSpec) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CoherenceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoherenceResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CoherenceResult, rhs: Google_Cloud_Aiplatform_V1_CoherenceResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FluencyInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FluencyInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FluencyInput, rhs: Google_Cloud_Aiplatform_V1_FluencyInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FluencyInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FluencyInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FluencyInstance, rhs: Google_Cloud_Aiplatform_V1_FluencyInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FluencySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FluencySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FluencySpec, rhs: Google_Cloud_Aiplatform_V1_FluencySpec) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FluencyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FluencyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FluencyResult, rhs: Google_Cloud_Aiplatform_V1_FluencyResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SafetyInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafetyInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SafetyInput, rhs: Google_Cloud_Aiplatform_V1_SafetyInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SafetyInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafetyInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SafetyInstance, rhs: Google_Cloud_Aiplatform_V1_SafetyInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SafetySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafetySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SafetySpec, rhs: Google_Cloud_Aiplatform_V1_SafetySpec) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SafetyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafetyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SafetyResult, rhs: Google_Cloud_Aiplatform_V1_SafetyResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundednessInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroundednessInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundednessInput, rhs: Google_Cloud_Aiplatform_V1_GroundednessInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundednessInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroundednessInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundednessInstance, rhs: Google_Cloud_Aiplatform_V1_GroundednessInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundednessSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroundednessSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundednessSpec, rhs: Google_Cloud_Aiplatform_V1_GroundednessSpec) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GroundednessResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroundednessResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GroundednessResult, rhs: Google_Cloud_Aiplatform_V1_GroundednessResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FulfillmentInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FulfillmentInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FulfillmentInput, rhs: Google_Cloud_Aiplatform_V1_FulfillmentInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FulfillmentInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FulfillmentInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FulfillmentInstance, rhs: Google_Cloud_Aiplatform_V1_FulfillmentInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FulfillmentSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FulfillmentSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FulfillmentSpec, rhs: Google_Cloud_Aiplatform_V1_FulfillmentSpec) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FulfillmentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FulfillmentResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FulfillmentResult, rhs: Google_Cloud_Aiplatform_V1_FulfillmentResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationQualityInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationQualityInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationQualityInput, rhs: Google_Cloud_Aiplatform_V1_SummarizationQualityInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationQualityInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationQualityInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
    3: .same(proto: "context"),
    4: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationQualityInstance, rhs: Google_Cloud_Aiplatform_V1_SummarizationQualityInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationQualitySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationQualitySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationQualitySpec, rhs: Google_Cloud_Aiplatform_V1_SummarizationQualitySpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationQualityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationQualityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationQualityResult, rhs: Google_Cloud_Aiplatform_V1_SummarizationQualityResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseSummarizationQualityInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput, rhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseSummarizationQualityInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .standard(proto: "baseline_prediction"),
    3: .same(proto: "reference"),
    4: .same(proto: "context"),
    5: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._baselinePrediction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baselinePrediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInstance, rhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._baselinePrediction != rhs._baselinePrediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualitySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseSummarizationQualitySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualitySpec, rhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualitySpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseSummarizationQualityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pairwise_choice"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.pairwiseChoice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pairwiseChoice != .unspecified {
      try visitor.visitSingularEnumField(value: self.pairwiseChoice, fieldNumber: 1)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult, rhs: Google_Cloud_Aiplatform_V1_PairwiseSummarizationQualityResult) -> Bool {
    if lhs.pairwiseChoice != rhs.pairwiseChoice {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationHelpfulnessInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput, rhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationHelpfulnessInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
    3: .same(proto: "context"),
    4: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInstance, rhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationHelpfulnessSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessSpec, rhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessSpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationHelpfulnessResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult, rhs: Google_Cloud_Aiplatform_V1_SummarizationHelpfulnessResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationVerbosityInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput, rhs: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationVerbosityInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationVerbosityInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
    3: .same(proto: "context"),
    4: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInstance, rhs: Google_Cloud_Aiplatform_V1_SummarizationVerbosityInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationVerbositySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationVerbositySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationVerbositySpec, rhs: Google_Cloud_Aiplatform_V1_SummarizationVerbositySpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummarizationVerbosityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult, rhs: Google_Cloud_Aiplatform_V1_SummarizationVerbosityResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringQualityInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringQualityInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
    3: .same(proto: "context"),
    4: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInstance, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringQualitySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringQualitySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualitySpec, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualitySpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringQualityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringQualityResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseQuestionAnsweringQualityInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput, rhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseQuestionAnsweringQualityInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .standard(proto: "baseline_prediction"),
    3: .same(proto: "reference"),
    4: .same(proto: "context"),
    5: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._baselinePrediction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baselinePrediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInstance, rhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._baselinePrediction != rhs._baselinePrediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualitySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseQuestionAnsweringQualitySpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualitySpec, rhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualitySpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseQuestionAnsweringQualityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pairwise_choice"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.pairwiseChoice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pairwiseChoice != .unspecified {
      try visitor.visitSingularEnumField(value: self.pairwiseChoice, fieldNumber: 1)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult, rhs: Google_Cloud_Aiplatform_V1_PairwiseQuestionAnsweringQualityResult) -> Bool {
    if lhs.pairwiseChoice != rhs.pairwiseChoice {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringRelevanceInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringRelevanceInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
    3: .same(proto: "context"),
    4: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInstance, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringRelevanceSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceSpec, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceSpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringRelevanceResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringRelevanceResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringHelpfulnessInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringHelpfulnessInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
    3: .same(proto: "context"),
    4: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInstance, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringHelpfulnessSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessSpec, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessSpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringHelpfulnessResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringHelpfulnessResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringCorrectnessInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringCorrectnessInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
    3: .same(proto: "context"),
    4: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instruction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInstance, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs._context != rhs._context {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringCorrectnessSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_reference"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useReference) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useReference != false {
      try visitor.visitSingularBoolField(value: self.useReference, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessSpec, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessSpec) -> Bool {
    if lhs.useReference != rhs.useReference {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestionAnsweringCorrectnessResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try { if let v = self._confidence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult, rhs: Google_Cloud_Aiplatform_V1_QuestionAnsweringCorrectnessResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs._confidence != rhs._confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PointwiseMetricInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointwiseMetricInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PointwiseMetricInput, rhs: Google_Cloud_Aiplatform_V1_PointwiseMetricInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PointwiseMetricInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointwiseMetricInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.instance != nil {try decoder.handleConflictingOneOf()}
          self.instance = .jsonInstance(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .jsonInstance(let v)? = self.instance {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PointwiseMetricInstance, rhs: Google_Cloud_Aiplatform_V1_PointwiseMetricInstance) -> Bool {
    if lhs.instance != rhs.instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PointwiseMetricSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointwiseMetricSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_prompt_template"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._metricPromptTemplate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricPromptTemplate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PointwiseMetricSpec, rhs: Google_Cloud_Aiplatform_V1_PointwiseMetricSpec) -> Bool {
    if lhs._metricPromptTemplate != rhs._metricPromptTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PointwiseMetricResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointwiseMetricResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PointwiseMetricResult, rhs: Google_Cloud_Aiplatform_V1_PointwiseMetricResult) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseMetricInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseMetricInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseMetricInput, rhs: Google_Cloud_Aiplatform_V1_PairwiseMetricInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseMetricInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseMetricInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.instance != nil {try decoder.handleConflictingOneOf()}
          self.instance = .jsonInstance(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .jsonInstance(let v)? = self.instance {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseMetricInstance, rhs: Google_Cloud_Aiplatform_V1_PairwiseMetricInstance) -> Bool {
    if lhs.instance != rhs.instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseMetricSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseMetricSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_prompt_template"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._metricPromptTemplate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricPromptTemplate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseMetricSpec, rhs: Google_Cloud_Aiplatform_V1_PairwiseMetricSpec) -> Bool {
    if lhs._metricPromptTemplate != rhs._metricPromptTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PairwiseMetricResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairwiseMetricResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pairwise_choice"),
    2: .same(proto: "explanation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.pairwiseChoice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pairwiseChoice != .unspecified {
      try visitor.visitSingularEnumField(value: self.pairwiseChoice, fieldNumber: 1)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PairwiseMetricResult, rhs: Google_Cloud_Aiplatform_V1_PairwiseMetricResult) -> Bool {
    if lhs.pairwiseChoice != rhs.pairwiseChoice {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolCallValidInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolCallValidInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolCallValidInput, rhs: Google_Cloud_Aiplatform_V1_ToolCallValidInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolCallValidSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolCallValidSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolCallValidSpec, rhs: Google_Cloud_Aiplatform_V1_ToolCallValidSpec) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolCallValidInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolCallValidInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolCallValidInstance, rhs: Google_Cloud_Aiplatform_V1_ToolCallValidInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolCallValidResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolCallValidResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tool_call_valid_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.toolCallValidMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toolCallValidMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toolCallValidMetricValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolCallValidResults, rhs: Google_Cloud_Aiplatform_V1_ToolCallValidResults) -> Bool {
    if lhs.toolCallValidMetricValues != rhs.toolCallValidMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolCallValidMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolCallValidMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolCallValidMetricValue, rhs: Google_Cloud_Aiplatform_V1_ToolCallValidMetricValue) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolNameMatchInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolNameMatchInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolNameMatchInput, rhs: Google_Cloud_Aiplatform_V1_ToolNameMatchInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolNameMatchSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolNameMatchSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolNameMatchSpec, rhs: Google_Cloud_Aiplatform_V1_ToolNameMatchSpec) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolNameMatchInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolNameMatchInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolNameMatchInstance, rhs: Google_Cloud_Aiplatform_V1_ToolNameMatchInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolNameMatchResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolNameMatchResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tool_name_match_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.toolNameMatchMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toolNameMatchMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toolNameMatchMetricValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolNameMatchResults, rhs: Google_Cloud_Aiplatform_V1_ToolNameMatchResults) -> Bool {
    if lhs.toolNameMatchMetricValues != rhs.toolNameMatchMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolNameMatchMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolNameMatchMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolNameMatchMetricValue, rhs: Google_Cloud_Aiplatform_V1_ToolNameMatchMetricValue) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKeyMatchInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKeyMatchSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchSpec, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchSpec) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKeyMatchInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInstance, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKeyMatchResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tool_parameter_key_match_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.toolParameterKeyMatchMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toolParameterKeyMatchMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toolParameterKeyMatchMetricValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchResults) -> Bool {
    if lhs.toolParameterKeyMatchMetricValues != rhs.toolParameterKeyMatchMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKeyMatchMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchMetricValue, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKeyMatchMetricValue) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKVMatchInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_spec"),
    2: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metricSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metricSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInput) -> Bool {
    if lhs._metricSpec != rhs._metricSpec {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKVMatchSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKVMatchSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_strict_string_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useStrictStringMatch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useStrictStringMatch != false {
      try visitor.visitSingularBoolField(value: self.useStrictStringMatch, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchSpec, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchSpec) -> Bool {
    if lhs.useStrictStringMatch != rhs.useStrictStringMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKVMatchInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prediction"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prediction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prediction {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInstance, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchInstance) -> Bool {
    if lhs._prediction != rhs._prediction {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKVMatchResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tool_parameter_kv_match_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.toolParameterKvMatchMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toolParameterKvMatchMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toolParameterKvMatchMetricValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchResults) -> Bool {
    if lhs.toolParameterKvMatchMetricValues != rhs.toolParameterKvMatchMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ToolParameterKVMatchMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolParameterKVMatchMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchMetricValue, rhs: Google_Cloud_Aiplatform_V1_ToolParameterKVMatchMetricValue) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
