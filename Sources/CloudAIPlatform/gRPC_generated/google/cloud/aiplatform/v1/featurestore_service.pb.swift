// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/featurestore_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for
/// [FeaturestoreService.CreateFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.CreateFeaturestore].
public struct Google_Cloud_Aiplatform_V1_CreateFeaturestoreRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Location to create Featurestores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// Required. The Featurestore to create.
  public var featurestore: Google_Cloud_Aiplatform_V1_Featurestore {
    get {return _storage._featurestore ?? Google_Cloud_Aiplatform_V1_Featurestore()}
    set {_uniqueStorage()._featurestore = newValue}
  }
  /// Returns true if `featurestore` has been explicitly set.
  public var hasFeaturestore: Bool {return _storage._featurestore != nil}
  /// Clears the value of `featurestore`. Subsequent reads from it will return its default value.
  public mutating func clearFeaturestore() {_uniqueStorage()._featurestore = nil}

  /// Required. The ID to use for this Featurestore, which will become the final
  /// component of the Featurestore's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the project and location.
  public var featurestoreID: String {
    get {return _storage._featurestoreID}
    set {_uniqueStorage()._featurestoreID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request message for
/// [FeaturestoreService.GetFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.GetFeaturestore].
public struct Google_Cloud_Aiplatform_V1_GetFeaturestoreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Featurestore resource.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores].
public struct Google_Cloud_Aiplatform_V1_ListFeaturestoresRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Location to list Featurestores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  public var parent: String = String()

  /// Lists the featurestores that match the filter expression. The following
  /// fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
  /// `<=`, and `>=` comparisons.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    Featurestores created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    Featurestores with label "env" set to "prod".
  public var filter: String = String()

  /// The maximum number of Featurestores to return. The service may return fewer
  /// than this value. If unspecified, at most 100 Featurestores will be
  /// returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  public var pageSize: Int32 = 0

  /// A page token, received from a previous
  /// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores]
  /// must match the call that provided the page token.
  public var pageToken: String = String()

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  ///   * `online_serving_config.fixed_node_count`
  public var orderBy: String = String()

  /// Mask specifying which fields to read.
  public var readMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _readMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_readMask = newValue}
  }
  /// Returns true if `readMask` has been explicitly set.
  public var hasReadMask: Bool {return self._readMask != nil}
  /// Clears the value of `readMask`. Subsequent reads from it will return its default value.
  public mutating func clearReadMask() {self._readMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Response message for
/// [FeaturestoreService.ListFeaturestores][google.cloud.aiplatform.v1.FeaturestoreService.ListFeaturestores].
public struct Google_Cloud_Aiplatform_V1_ListFeaturestoresResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Featurestores matching the request.
  public var featurestores: [Google_Cloud_Aiplatform_V1_Featurestore] = []

  /// A token, which can be sent as
  /// [ListFeaturestoresRequest.page_token][google.cloud.aiplatform.v1.ListFeaturestoresRequest.page_token]
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.UpdateFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeaturestore].
public struct Google_Cloud_Aiplatform_V1_UpdateFeaturestoreRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Featurestore's `name` field is used to identify the
  /// Featurestore to be updated. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  public var featurestore: Google_Cloud_Aiplatform_V1_Featurestore {
    get {return _storage._featurestore ?? Google_Cloud_Aiplatform_V1_Featurestore()}
    set {_uniqueStorage()._featurestore = newValue}
  }
  /// Returns true if `featurestore` has been explicitly set.
  public var hasFeaturestore: Bool {return _storage._featurestore != nil}
  /// Clears the value of `featurestore`. Subsequent reads from it will return its default value.
  public mutating func clearFeaturestore() {_uniqueStorage()._featurestore = nil}

  /// Field mask is used to specify the fields to be overwritten in the
  /// Featurestore resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `online_serving_config.fixed_node_count`
  ///   * `online_serving_config.scaling`
  ///   * `online_storage_ttl_days`
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request message for
/// [FeaturestoreService.DeleteFeaturestore][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeaturestore].
public struct Google_Cloud_Aiplatform_V1_DeleteFeaturestoreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Featurestore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  public var name: String = String()

  /// If set to true, any EntityTypes and Features for this Featurestore will
  /// also be deleted. (Otherwise, the request will only work if the Featurestore
  /// has no EntityTypes.)
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues].
public struct Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details about the source data, including the location of the storage and
  /// the format.
  public var source: Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest.OneOf_Source? = nil

  public var avroSource: Google_Cloud_Aiplatform_V1_AvroSource {
    get {
      if case .avroSource(let v)? = source {return v}
      return Google_Cloud_Aiplatform_V1_AvroSource()
    }
    set {source = .avroSource(newValue)}
  }

  public var bigquerySource: Google_Cloud_Aiplatform_V1_BigQuerySource {
    get {
      if case .bigquerySource(let v)? = source {return v}
      return Google_Cloud_Aiplatform_V1_BigQuerySource()
    }
    set {source = .bigquerySource(newValue)}
  }

  public var csvSource: Google_Cloud_Aiplatform_V1_CsvSource {
    get {
      if case .csvSource(let v)? = source {return v}
      return Google_Cloud_Aiplatform_V1_CsvSource()
    }
    set {source = .csvSource(newValue)}
  }

  /// Source of Feature timestamp for all Feature values of each entity.
  /// Timestamps must be millisecond-aligned.
  public var featureTimeSource: Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest.OneOf_FeatureTimeSource? = nil

  /// Source column that holds the Feature timestamp for all Feature
  /// values in each entity.
  public var featureTimeField: String {
    get {
      if case .featureTimeField(let v)? = featureTimeSource {return v}
      return String()
    }
    set {featureTimeSource = .featureTimeField(newValue)}
  }

  /// Single Feature timestamp for all entities being imported. The
  /// timestamp must not have higher than millisecond precision.
  public var featureTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .featureTime(let v)? = featureTimeSource {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {featureTimeSource = .featureTime(newValue)}
  }

  /// Required. The resource name of the EntityType grouping the Features for
  /// which values are being imported. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  public var entityType: String = String()

  /// Source column that holds entity IDs. If not provided, entity IDs are
  /// extracted from the column named entity_id.
  public var entityIDField: String = String()

  /// Required. Specifications defining which Feature values to import from the
  /// entity. The request fails if no feature_specs are provided, and having
  /// multiple feature_specs for one Feature is not allowed.
  public var featureSpecs: [Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest.FeatureSpec] = []

  /// If set, data will not be imported for online serving. This
  /// is typically used for backfilling, where Feature generation timestamps are
  /// not in the timestamp range needed for online serving.
  public var disableOnlineServing: Bool = false

  /// Specifies the number of workers that are used to write data to the
  /// Featurestore. Consider the online serving capacity that you require to
  /// achieve the desired import throughput without interfering with online
  /// serving. The value must be positive, and less than or equal to 100.
  /// If not set, defaults to using 1 worker. The low count ensures minimal
  /// impact on online serving performance.
  public var workerCount: Int32 = 0

  /// If true, API doesn't start ingestion analysis pipeline.
  public var disableIngestionAnalysis: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Details about the source data, including the location of the storage and
  /// the format.
  public enum OneOf_Source: Equatable, Sendable {
    case avroSource(Google_Cloud_Aiplatform_V1_AvroSource)
    case bigquerySource(Google_Cloud_Aiplatform_V1_BigQuerySource)
    case csvSource(Google_Cloud_Aiplatform_V1_CsvSource)

  }

  /// Source of Feature timestamp for all Feature values of each entity.
  /// Timestamps must be millisecond-aligned.
  public enum OneOf_FeatureTimeSource: Equatable, Sendable {
    /// Source column that holds the Feature timestamp for all Feature
    /// values in each entity.
    case featureTimeField(String)
    /// Single Feature timestamp for all entities being imported. The
    /// timestamp must not have higher than millisecond precision.
    case featureTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  }

  /// Defines the Feature value(s) to import.
  public struct FeatureSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. ID of the Feature to import values of. This Feature must exist
    /// in the target EntityType, or the request will fail.
    public var id: String = String()

    /// Source column to get the Feature values from. If not set, uses the column
    /// with the same name as the Feature ID.
    public var sourceField: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Response message for
/// [FeaturestoreService.ImportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ImportFeatureValues].
public struct Google_Cloud_Aiplatform_V1_ImportFeatureValuesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of entities that have been imported by the operation.
  public var importedEntityCount: Int64 = 0

  /// Number of Feature values that have been imported by the operation.
  public var importedFeatureValueCount: Int64 = 0

  /// The number of rows in input source that weren't imported due to either
  /// * Not having any featureValues.
  /// * Having a null entityId.
  /// * Having a null timestamp.
  /// * Not being parsable (applicable for CSV sources).
  public var invalidRowCount: Int64 = 0

  /// The number rows that weren't ingested due to having feature timestamps
  /// outside the retention boundary.
  public var timestampOutsideRetentionRowsCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.BatchReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues].
public struct Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var readOption: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.OneOf_ReadOption? = nil

  /// Each read instance consists of exactly one read timestamp and one or more
  /// entity IDs identifying entities of the corresponding EntityTypes whose
  /// Features are requested.
  ///
  /// Each output instance contains Feature values of requested entities
  /// concatenated together as of the read time.
  ///
  /// An example read instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z`.
  ///
  /// An example output instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
  /// bar_entity_feature2_value`.
  ///
  /// Timestamp in each read instance must be millisecond-aligned.
  ///
  /// `csv_read_instances` are read instances stored in a plain-text CSV file.
  /// The header should be:
  ///     [ENTITY_TYPE_ID1], [ENTITY_TYPE_ID2], ..., timestamp
  ///
  /// The columns can be in any order.
  ///
  /// Values in the timestamp column must use the RFC 3339 format, e.g.
  /// `2012-07-30T10:43:17.123Z`.
  public var csvReadInstances: Google_Cloud_Aiplatform_V1_CsvSource {
    get {
      if case .csvReadInstances(let v)? = readOption {return v}
      return Google_Cloud_Aiplatform_V1_CsvSource()
    }
    set {readOption = .csvReadInstances(newValue)}
  }

  /// Similar to csv_read_instances, but from BigQuery source.
  public var bigqueryReadInstances: Google_Cloud_Aiplatform_V1_BigQuerySource {
    get {
      if case .bigqueryReadInstances(let v)? = readOption {return v}
      return Google_Cloud_Aiplatform_V1_BigQuerySource()
    }
    set {readOption = .bigqueryReadInstances(newValue)}
  }

  /// Required. The resource name of the Featurestore from which to query Feature
  /// values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  public var featurestore: String = String()

  /// Required. Specifies output location and format.
  public var destination: Google_Cloud_Aiplatform_V1_FeatureValueDestination {
    get {return _destination ?? Google_Cloud_Aiplatform_V1_FeatureValueDestination()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// When not empty, the specified fields in the *_read_instances source will be
  /// joined as-is in the output, in addition to those fields from the
  /// Featurestore Entity.
  ///
  /// For BigQuery source, the type of the pass-through values will be
  /// automatically inferred. For CSV source, the pass-through values will be
  /// passed as opaque bytes.
  public var passThroughFields: [Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.PassThroughField] = []

  /// Required. Specifies EntityType grouping Features to read values of and
  /// settings.
  public var entityTypeSpecs: [Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.EntityTypeSpec] = []

  /// Optional. Excludes Feature values with feature generation timestamp before
  /// this timestamp. If not set, retrieve oldest values kept in Feature Store.
  /// Timestamp, if present, must not have higher than millisecond precision.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ReadOption: Equatable, Sendable {
    /// Each read instance consists of exactly one read timestamp and one or more
    /// entity IDs identifying entities of the corresponding EntityTypes whose
    /// Features are requested.
    ///
    /// Each output instance contains Feature values of requested entities
    /// concatenated together as of the read time.
    ///
    /// An example read instance may be `foo_entity_id, bar_entity_id,
    /// 2020-01-01T10:00:00.123Z`.
    ///
    /// An example output instance may be `foo_entity_id, bar_entity_id,
    /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
    /// bar_entity_feature2_value`.
    ///
    /// Timestamp in each read instance must be millisecond-aligned.
    ///
    /// `csv_read_instances` are read instances stored in a plain-text CSV file.
    /// The header should be:
    ///     [ENTITY_TYPE_ID1], [ENTITY_TYPE_ID2], ..., timestamp
    ///
    /// The columns can be in any order.
    ///
    /// Values in the timestamp column must use the RFC 3339 format, e.g.
    /// `2012-07-30T10:43:17.123Z`.
    case csvReadInstances(Google_Cloud_Aiplatform_V1_CsvSource)
    /// Similar to csv_read_instances, but from BigQuery source.
    case bigqueryReadInstances(Google_Cloud_Aiplatform_V1_BigQuerySource)

  }

  /// Describe pass-through fields in read_instance source.
  public struct PassThroughField: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The name of the field in the CSV header or the name of the
    /// column in BigQuery table. The naming restriction is the same as
    /// [Feature.name][google.cloud.aiplatform.v1.Feature.name].
    public var fieldName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Selects Features of an EntityType to read values of and specifies read
  /// settings.
  public struct EntityTypeSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. ID of the EntityType to select Features. The EntityType id is
    /// the
    /// [entity_type_id][google.cloud.aiplatform.v1.CreateEntityTypeRequest.entity_type_id]
    /// specified during EntityType creation.
    public var entityTypeID: String = String()

    /// Required. Selectors choosing which Feature values to read from the
    /// EntityType.
    public var featureSelector: Google_Cloud_Aiplatform_V1_FeatureSelector {
      get {return _featureSelector ?? Google_Cloud_Aiplatform_V1_FeatureSelector()}
      set {_featureSelector = newValue}
    }
    /// Returns true if `featureSelector` has been explicitly set.
    public var hasFeatureSelector: Bool {return self._featureSelector != nil}
    /// Clears the value of `featureSelector`. Subsequent reads from it will return its default value.
    public mutating func clearFeatureSelector() {self._featureSelector = nil}

    /// Per-Feature settings for the batch read.
    public var settings: [Google_Cloud_Aiplatform_V1_DestinationFeatureSetting] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _featureSelector: Google_Cloud_Aiplatform_V1_FeatureSelector? = nil
  }

  public init() {}

  fileprivate var _destination: Google_Cloud_Aiplatform_V1_FeatureValueDestination? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request message for
/// [FeaturestoreService.ExportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues].
public struct Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The mode in which Feature values are exported.
  public var mode: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.OneOf_Mode? = nil

  /// Exports the latest Feature values of all entities of the EntityType
  /// within a time range.
  public var snapshotExport: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.SnapshotExport {
    get {
      if case .snapshotExport(let v)? = mode {return v}
      return Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.SnapshotExport()
    }
    set {mode = .snapshotExport(newValue)}
  }

  /// Exports all historical values of all entities of the EntityType within a
  /// time range
  public var fullExport: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.FullExport {
    get {
      if case .fullExport(let v)? = mode {return v}
      return Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.FullExport()
    }
    set {mode = .fullExport(newValue)}
  }

  /// Required. The resource name of the EntityType from which to export Feature
  /// values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  public var entityType: String = String()

  /// Required. Specifies destination location and format.
  public var destination: Google_Cloud_Aiplatform_V1_FeatureValueDestination {
    get {return _destination ?? Google_Cloud_Aiplatform_V1_FeatureValueDestination()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  /// Required. Selects Features to export values of.
  public var featureSelector: Google_Cloud_Aiplatform_V1_FeatureSelector {
    get {return _featureSelector ?? Google_Cloud_Aiplatform_V1_FeatureSelector()}
    set {_featureSelector = newValue}
  }
  /// Returns true if `featureSelector` has been explicitly set.
  public var hasFeatureSelector: Bool {return self._featureSelector != nil}
  /// Clears the value of `featureSelector`. Subsequent reads from it will return its default value.
  public mutating func clearFeatureSelector() {self._featureSelector = nil}

  /// Per-Feature export settings.
  public var settings: [Google_Cloud_Aiplatform_V1_DestinationFeatureSetting] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The mode in which Feature values are exported.
  public enum OneOf_Mode: Equatable, Sendable {
    /// Exports the latest Feature values of all entities of the EntityType
    /// within a time range.
    case snapshotExport(Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.SnapshotExport)
    /// Exports all historical values of all entities of the EntityType within a
    /// time range
    case fullExport(Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.FullExport)

  }

  /// Describes exporting the latest Feature values of all entities of the
  /// EntityType between [start_time, snapshot_time].
  public struct SnapshotExport: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Exports Feature values as of this timestamp. If not set,
    /// retrieve values as of now. Timestamp, if present, must not have higher
    /// than millisecond precision.
    public var snapshotTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _snapshotTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_snapshotTime = newValue}
    }
    /// Returns true if `snapshotTime` has been explicitly set.
    public var hasSnapshotTime: Bool {return self._snapshotTime != nil}
    /// Clears the value of `snapshotTime`. Subsequent reads from it will return its default value.
    public mutating func clearSnapshotTime() {self._snapshotTime = nil}

    /// Excludes Feature values with feature generation timestamp before this
    /// timestamp. If not set, retrieve oldest values kept in Feature Store.
    /// Timestamp, if present, must not have higher than millisecond precision.
    public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {return self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _snapshotTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  /// Describes exporting all historical Feature values of all entities of the
  /// EntityType between [start_time, end_time].
  public struct FullExport: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Excludes Feature values with feature generation timestamp before this
    /// timestamp. If not set, retrieve oldest values kept in Feature Store.
    /// Timestamp, if present, must not have higher than millisecond precision.
    public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {return self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    /// Exports Feature values as of this timestamp. If not set,
    /// retrieve values as of now. Timestamp, if present, must not have higher
    /// than millisecond precision.
    public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTime = newValue}
    }
    /// Returns true if `endTime` has been explicitly set.
    public var hasEndTime: Bool {return self._endTime != nil}
    /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
    public mutating func clearEndTime() {self._endTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _destination: Google_Cloud_Aiplatform_V1_FeatureValueDestination? = nil
  fileprivate var _featureSelector: Google_Cloud_Aiplatform_V1_FeatureSelector? = nil
}

public struct Google_Cloud_Aiplatform_V1_DestinationFeatureSetting: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the Feature to apply the setting to.
  public var featureID: String = String()

  /// Specify the field name in the export destination. If not specified,
  /// Feature ID is used.
  public var destinationField: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A destination location for Feature values and format.
public struct Google_Cloud_Aiplatform_V1_FeatureValueDestination: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var destination: Google_Cloud_Aiplatform_V1_FeatureValueDestination.OneOf_Destination? = nil

  /// Output in BigQuery format.
  /// [BigQueryDestination.output_uri][google.cloud.aiplatform.v1.BigQueryDestination.output_uri]
  /// in
  /// [FeatureValueDestination.bigquery_destination][google.cloud.aiplatform.v1.FeatureValueDestination.bigquery_destination]
  /// must refer to a table.
  public var bigqueryDestination: Google_Cloud_Aiplatform_V1_BigQueryDestination {
    get {
      if case .bigqueryDestination(let v)? = destination {return v}
      return Google_Cloud_Aiplatform_V1_BigQueryDestination()
    }
    set {destination = .bigqueryDestination(newValue)}
  }

  /// Output in TFRecord format.
  ///
  /// Below are the mapping from Feature value type
  /// in Featurestore to Feature value type in TFRecord:
  ///
  ///     Value type in Featurestore                 | Value type in TFRecord
  ///     DOUBLE, DOUBLE_ARRAY                       | FLOAT_LIST
  ///     INT64, INT64_ARRAY                         | INT64_LIST
  ///     STRING, STRING_ARRAY, BYTES                | BYTES_LIST
  ///     true -> byte_string("true"), false -> byte_string("false")
  ///     BOOL, BOOL_ARRAY (true, false)             | BYTES_LIST
  public var tfrecordDestination: Google_Cloud_Aiplatform_V1_TFRecordDestination {
    get {
      if case .tfrecordDestination(let v)? = destination {return v}
      return Google_Cloud_Aiplatform_V1_TFRecordDestination()
    }
    set {destination = .tfrecordDestination(newValue)}
  }

  /// Output in CSV format. Array Feature value types are not allowed in CSV
  /// format.
  public var csvDestination: Google_Cloud_Aiplatform_V1_CsvDestination {
    get {
      if case .csvDestination(let v)? = destination {return v}
      return Google_Cloud_Aiplatform_V1_CsvDestination()
    }
    set {destination = .csvDestination(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Destination: Equatable, Sendable {
    /// Output in BigQuery format.
    /// [BigQueryDestination.output_uri][google.cloud.aiplatform.v1.BigQueryDestination.output_uri]
    /// in
    /// [FeatureValueDestination.bigquery_destination][google.cloud.aiplatform.v1.FeatureValueDestination.bigquery_destination]
    /// must refer to a table.
    case bigqueryDestination(Google_Cloud_Aiplatform_V1_BigQueryDestination)
    /// Output in TFRecord format.
    ///
    /// Below are the mapping from Feature value type
    /// in Featurestore to Feature value type in TFRecord:
    ///
    ///     Value type in Featurestore                 | Value type in TFRecord
    ///     DOUBLE, DOUBLE_ARRAY                       | FLOAT_LIST
    ///     INT64, INT64_ARRAY                         | INT64_LIST
    ///     STRING, STRING_ARRAY, BYTES                | BYTES_LIST
    ///     true -> byte_string("true"), false -> byte_string("false")
    ///     BOOL, BOOL_ARRAY (true, false)             | BYTES_LIST
    case tfrecordDestination(Google_Cloud_Aiplatform_V1_TFRecordDestination)
    /// Output in CSV format. Array Feature value types are not allowed in CSV
    /// format.
    case csvDestination(Google_Cloud_Aiplatform_V1_CsvDestination)

  }

  public init() {}
}

/// Response message for
/// [FeaturestoreService.ExportFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.ExportFeatureValues].
public struct Google_Cloud_Aiplatform_V1_ExportFeatureValuesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [FeaturestoreService.BatchReadFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.BatchReadFeatureValues].
public struct Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.CreateEntityType][google.cloud.aiplatform.v1.FeaturestoreService.CreateEntityType].
public struct Google_Cloud_Aiplatform_V1_CreateEntityTypeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Featurestore to create EntityTypes.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  public var parent: String = String()

  /// The EntityType to create.
  public var entityType: Google_Cloud_Aiplatform_V1_EntityType {
    get {return _entityType ?? Google_Cloud_Aiplatform_V1_EntityType()}
    set {_entityType = newValue}
  }
  /// Returns true if `entityType` has been explicitly set.
  public var hasEntityType: Bool {return self._entityType != nil}
  /// Clears the value of `entityType`. Subsequent reads from it will return its default value.
  public mutating func clearEntityType() {self._entityType = nil}

  /// Required. The ID to use for the EntityType, which will become the final
  /// component of the EntityType's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within a featurestore.
  public var entityTypeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entityType: Google_Cloud_Aiplatform_V1_EntityType? = nil
}

/// Request message for
/// [FeaturestoreService.GetEntityType][google.cloud.aiplatform.v1.FeaturestoreService.GetEntityType].
public struct Google_Cloud_Aiplatform_V1_GetEntityTypeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the EntityType resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes].
public struct Google_Cloud_Aiplatform_V1_ListEntityTypesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Featurestore to list EntityTypes.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  public var parent: String = String()

  /// Lists the EntityTypes that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
  ///      or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any EntityType which has a label with 'env' as the
  ///   key.
  public var filter: String = String()

  /// The maximum number of EntityTypes to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 EntityTypes will be returned.
  /// The maximum value is 1000; any value greater than 1000 will be coerced to
  /// 1000.
  public var pageSize: Int32 = 0

  /// A page token, received from a previous
  /// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes]
  /// must match the call that provided the page token.
  public var pageToken: String = String()

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  ///
  /// Supported fields:
  ///
  ///   * `entity_type_id`
  ///   * `create_time`
  ///   * `update_time`
  public var orderBy: String = String()

  /// Mask specifying which fields to read.
  public var readMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _readMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_readMask = newValue}
  }
  /// Returns true if `readMask` has been explicitly set.
  public var hasReadMask: Bool {return self._readMask != nil}
  /// Clears the value of `readMask`. Subsequent reads from it will return its default value.
  public mutating func clearReadMask() {self._readMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Response message for
/// [FeaturestoreService.ListEntityTypes][google.cloud.aiplatform.v1.FeaturestoreService.ListEntityTypes].
public struct Google_Cloud_Aiplatform_V1_ListEntityTypesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The EntityTypes matching the request.
  public var entityTypes: [Google_Cloud_Aiplatform_V1_EntityType] = []

  /// A token, which can be sent as
  /// [ListEntityTypesRequest.page_token][google.cloud.aiplatform.v1.ListEntityTypesRequest.page_token]
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.UpdateEntityType][google.cloud.aiplatform.v1.FeaturestoreService.UpdateEntityType].
public struct Google_Cloud_Aiplatform_V1_UpdateEntityTypeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The EntityType's `name` field is used to identify the EntityType
  /// to be updated. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  public var entityType: Google_Cloud_Aiplatform_V1_EntityType {
    get {return _entityType ?? Google_Cloud_Aiplatform_V1_EntityType()}
    set {_entityType = newValue}
  }
  /// Returns true if `entityType` has been explicitly set.
  public var hasEntityType: Bool {return self._entityType != nil}
  /// Clears the value of `entityType`. Subsequent reads from it will return its default value.
  public mutating func clearEntityType() {self._entityType = nil}

  /// Field mask is used to specify the fields to be overwritten in the
  /// EntityType resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `description`
  ///   * `labels`
  ///   * `monitoring_config.snapshot_analysis.disabled`
  ///   * `monitoring_config.snapshot_analysis.monitoring_interval_days`
  ///   * `monitoring_config.snapshot_analysis.staleness_days`
  ///   * `monitoring_config.import_features_analysis.state`
  ///   * `monitoring_config.import_features_analysis.anomaly_detection_baseline`
  ///   * `monitoring_config.numerical_threshold_config.value`
  ///   * `monitoring_config.categorical_threshold_config.value`
  ///   * `offline_storage_ttl_days`
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entityType: Google_Cloud_Aiplatform_V1_EntityType? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for [FeaturestoreService.DeleteEntityTypes][].
public struct Google_Cloud_Aiplatform_V1_DeleteEntityTypeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the EntityType to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  public var name: String = String()

  /// If set to true, any Features for this EntityType will also be deleted.
  /// (Otherwise, the request will only work if the EntityType has no Features.)
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.CreateFeature][google.cloud.aiplatform.v1.FeaturestoreService.CreateFeature].
/// Request message for
/// [FeatureRegistryService.CreateFeature][google.cloud.aiplatform.v1.FeatureRegistryService.CreateFeature].
public struct Google_Cloud_Aiplatform_V1_CreateFeatureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the EntityType or FeatureGroup to create a
  /// Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  public var parent: String = String()

  /// Required. The Feature to create.
  public var feature: Google_Cloud_Aiplatform_V1_Feature {
    get {return _feature ?? Google_Cloud_Aiplatform_V1_Feature()}
    set {_feature = newValue}
  }
  /// Returns true if `feature` has been explicitly set.
  public var hasFeature: Bool {return self._feature != nil}
  /// Clears the value of `feature`. Subsequent reads from it will return its default value.
  public mutating func clearFeature() {self._feature = nil}

  /// Required. The ID to use for the Feature, which will become the final
  /// component of the Feature's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within an EntityType/FeatureGroup.
  public var featureID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feature: Google_Cloud_Aiplatform_V1_Feature? = nil
}

/// Request message for
/// [FeaturestoreService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures].
public struct Google_Cloud_Aiplatform_V1_BatchCreateFeaturesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the EntityType to create the batch of
  /// Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  public var parent: String = String()

  /// Required. The request message specifying the Features to create. All
  /// Features must be created under the same parent EntityType. The `parent`
  /// field in each child request message can be omitted. If `parent` is set in a
  /// child request, then the value must match the `parent` value in this request
  /// message.
  public var requests: [Google_Cloud_Aiplatform_V1_CreateFeatureRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [FeaturestoreService.BatchCreateFeatures][google.cloud.aiplatform.v1.FeaturestoreService.BatchCreateFeatures].
public struct Google_Cloud_Aiplatform_V1_BatchCreateFeaturesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Features created.
  public var features: [Google_Cloud_Aiplatform_V1_Feature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.GetFeature][google.cloud.aiplatform.v1.FeaturestoreService.GetFeature].
/// Request message for
/// [FeatureRegistryService.GetFeature][google.cloud.aiplatform.v1.FeatureRegistryService.GetFeature].
public struct Google_Cloud_Aiplatform_V1_GetFeatureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Feature resource.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures].
/// Request message for
/// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures].
public struct Google_Cloud_Aiplatform_V1_ListFeaturesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  public var parent: String = String()

  /// Lists the Features that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `value_type`: Supports = and != comparisons.
  /// * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
  /// be in RFC 3339 format.
  /// * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
  /// be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
  ///      or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> Features having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any Feature which has a label with 'env' as the
  ///   key.
  public var filter: String = String()

  /// The maximum number of Features to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 Features will be returned.
  /// The maximum value is 1000; any value greater than 1000 will be coerced to
  /// 1000.
  public var pageSize: Int32 = 0

  /// A page token, received from a previous
  /// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]
  /// call or
  /// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures]
  /// or
  /// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures]
  /// must match the call that provided the page token.
  public var pageToken: String = String()

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported fields:
  ///
  ///   * `feature_id`
  ///   * `value_type` (Not supported for FeatureRegistry Feature)
  ///   * `create_time`
  ///   * `update_time`
  public var orderBy: String = String()

  /// Mask specifying which fields to read.
  public var readMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _readMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_readMask = newValue}
  }
  /// Returns true if `readMask` has been explicitly set.
  public var hasReadMask: Bool {return self._readMask != nil}
  /// Clears the value of `readMask`. Subsequent reads from it will return its default value.
  public mutating func clearReadMask() {self._readMask = nil}

  /// Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent
  /// [ListFeaturesRequest.latest_stats_count][google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count]
  /// of stats for each Feature in response. Valid value is [0, 10]. If number of
  /// stats exists <
  /// [ListFeaturesRequest.latest_stats_count][google.cloud.aiplatform.v1.ListFeaturesRequest.latest_stats_count],
  /// return all existing stats.
  public var latestStatsCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Response message for
/// [FeaturestoreService.ListFeatures][google.cloud.aiplatform.v1.FeaturestoreService.ListFeatures].
/// Response message for
/// [FeatureRegistryService.ListFeatures][google.cloud.aiplatform.v1.FeatureRegistryService.ListFeatures].
public struct Google_Cloud_Aiplatform_V1_ListFeaturesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Features matching the request.
  public var features: [Google_Cloud_Aiplatform_V1_Feature] = []

  /// A token, which can be sent as
  /// [ListFeaturesRequest.page_token][google.cloud.aiplatform.v1.ListFeaturesRequest.page_token]
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures].
public struct Google_Cloud_Aiplatform_V1_SearchFeaturesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Location to search Features.
  /// Format:
  /// `projects/{project}/locations/{location}`
  public var location: String = String()

  /// Query string that is a conjunction of field-restricted queries and/or
  /// field-restricted filters.  Field-restricted queries and filters can be
  /// combined using `AND` to form a conjunction.
  ///
  /// A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
  /// exists as a substring within Feature's FIELD. The QUERY
  /// and the FIELD are converted to a sequence of words (i.e. tokens) for
  /// comparison. This is done by:
  ///
  ///   * Removing leading/trailing whitespace and tokenizing the search value.
  ///   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
  ///   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
  ///   as a wildcard that matches characters within a token.
  ///   * Ignoring case.
  ///   * Prepending an asterisk to the first and appending an asterisk to the
  ///   last token in QUERY.
  ///
  /// A QUERY must be either a singular token or a phrase. A phrase is one or
  /// multiple words enclosed in double quotation marks ("). With phrases, the
  /// order of the words is important. Words in the phrase must be matching in
  /// order and consecutively.
  ///
  /// Supported FIELDs for field-restricted queries:
  ///
  /// * `feature_id`
  /// * `description`
  /// * `entity_type_id`
  ///
  /// Examples:
  ///
  /// * `feature_id: foo` --> Matches a Feature with ID containing the substring
  /// `foo` (eg. `foo`, `foofeature`, `barfoo`).
  /// * `feature_id: foo*feature` --> Matches a Feature with ID containing the
  /// substring `foo*feature` (eg. `foobarfeature`).
  /// * `feature_id: foo AND description: bar` --> Matches a Feature with ID
  /// containing the substring `foo` and description containing the substring
  /// `bar`.
  ///
  ///
  /// Besides field queries, the following exact-match filters are
  /// supported. The exact-match filters do not support wildcards. Unlike
  /// field-restricted queries, exact-match filters are case-sensitive.
  ///
  /// * `feature_id`: Supports = comparisons.
  /// * `description`: Supports = comparisons. Multi-token filters should be
  /// enclosed in quotes.
  /// * `entity_type_id`: Supports = comparisons.
  /// * `value_type`: Supports = and != comparisons.
  /// * `labels`: Supports key-value equality as well as key presence.
  /// * `featurestore_id`: Supports = comparisons.
  ///
  /// Examples:
  ///
  /// * `description = "foo bar"` --> Any Feature with description exactly equal
  /// to `foo bar`
  /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
  /// * `labels.active = yes AND labels.env = prod` --> Features having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any Feature which has a label with `env` as the
  ///   key.
  public var query: String = String()

  /// The maximum number of Features to return. The service may return fewer
  /// than this value. If unspecified, at most 100 Features will be returned.
  /// The maximum value is 100; any value greater than 100 will be coerced to
  /// 100.
  public var pageSize: Int32 = 0

  /// A page token, received from a previous
  /// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures]
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures],
  /// except `page_size`, must match the call that provided the page token.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [FeaturestoreService.SearchFeatures][google.cloud.aiplatform.v1.FeaturestoreService.SearchFeatures].
public struct Google_Cloud_Aiplatform_V1_SearchFeaturesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Features matching the request.
  ///
  /// Fields returned:
  ///
  ///  * `name`
  ///  * `description`
  ///  * `labels`
  ///  * `create_time`
  ///  * `update_time`
  public var features: [Google_Cloud_Aiplatform_V1_Feature] = []

  /// A token, which can be sent as
  /// [SearchFeaturesRequest.page_token][google.cloud.aiplatform.v1.SearchFeaturesRequest.page_token]
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [FeaturestoreService.UpdateFeature][google.cloud.aiplatform.v1.FeaturestoreService.UpdateFeature].
/// Request message for
/// [FeatureRegistryService.UpdateFeature][google.cloud.aiplatform.v1.FeatureRegistryService.UpdateFeature].
public struct Google_Cloud_Aiplatform_V1_UpdateFeatureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Feature's `name` field is used to identify the Feature to be
  /// updated.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  public var feature: Google_Cloud_Aiplatform_V1_Feature {
    get {return _feature ?? Google_Cloud_Aiplatform_V1_Feature()}
    set {_feature = newValue}
  }
  /// Returns true if `feature` has been explicitly set.
  public var hasFeature: Bool {return self._feature != nil}
  /// Clears the value of `feature`. Subsequent reads from it will return its default value.
  public mutating func clearFeature() {self._feature = nil}

  /// Field mask is used to specify the fields to be overwritten in the
  /// Features resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `description`
  ///   * `labels`
  ///   * `disable_monitoring` (Not supported for FeatureRegistryService Feature)
  ///   * `point_of_contact` (Not supported for FeaturestoreService FeatureStore)
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feature: Google_Cloud_Aiplatform_V1_Feature? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for
/// [FeaturestoreService.DeleteFeature][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeature].
/// Request message for
/// [FeatureRegistryService.DeleteFeature][google.cloud.aiplatform.v1.FeatureRegistryService.DeleteFeature].
public struct Google_Cloud_Aiplatform_V1_DeleteFeatureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Features to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Details of operations that perform create Featurestore.
public struct Google_Cloud_Aiplatform_V1_CreateFeaturestoreOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Featurestore.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that perform update Featurestore.
public struct Google_Cloud_Aiplatform_V1_UpdateFeaturestoreOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Featurestore.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that perform import Feature values.
public struct Google_Cloud_Aiplatform_V1_ImportFeatureValuesOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Featurestore import Feature values.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  /// Number of entities that have been imported by the operation.
  public var importedEntityCount: Int64 = 0

  /// Number of Feature values that have been imported by the operation.
  public var importedFeatureValueCount: Int64 = 0

  /// The source URI from where Feature values are imported.
  public var sourceUris: [String] = []

  /// The number of rows in input source that weren't imported due to either
  /// * Not having any featureValues.
  /// * Having a null entityId.
  /// * Having a null timestamp.
  /// * Not being parsable (applicable for CSV sources).
  public var invalidRowCount: Int64 = 0

  /// The number rows that weren't ingested due to having timestamps outside the
  /// retention boundary.
  public var timestampOutsideRetentionRowsCount: Int64 = 0

  /// List of ImportFeatureValues operations running under a single EntityType
  /// that are blocking this operation.
  public var blockingOperationIds: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that exports Features values.
public struct Google_Cloud_Aiplatform_V1_ExportFeatureValuesOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Featurestore export Feature values.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that batch reads Feature values.
public struct Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Featurestore batch read Features values.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that delete Feature values.
public struct Google_Cloud_Aiplatform_V1_DeleteFeatureValuesOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Featurestore delete Features values.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that perform create EntityType.
public struct Google_Cloud_Aiplatform_V1_CreateEntityTypeOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for EntityType.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that perform create Feature.
public struct Google_Cloud_Aiplatform_V1_CreateFeatureOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Feature.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Details of operations that perform batch create Features.
public struct Google_Cloud_Aiplatform_V1_BatchCreateFeaturesOperationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation metadata for Feature.
  public var genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata {
    get {return _genericMetadata ?? Google_Cloud_Aiplatform_V1_GenericOperationMetadata()}
    set {_genericMetadata = newValue}
  }
  /// Returns true if `genericMetadata` has been explicitly set.
  public var hasGenericMetadata: Bool {return self._genericMetadata != nil}
  /// Clears the value of `genericMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearGenericMetadata() {self._genericMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericMetadata: Google_Cloud_Aiplatform_V1_GenericOperationMetadata? = nil
}

/// Request message for
/// [FeaturestoreService.DeleteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues].
public struct Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Defines options to select feature values to be deleted.
  public var deleteOption: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.OneOf_DeleteOption? = nil

  /// Select feature values to be deleted by specifying entities.
  public var selectEntity: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectEntity {
    get {
      if case .selectEntity(let v)? = deleteOption {return v}
      return Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectEntity()
    }
    set {deleteOption = .selectEntity(newValue)}
  }

  /// Select feature values to be deleted by specifying time range and
  /// features.
  public var selectTimeRangeAndFeature: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectTimeRangeAndFeature {
    get {
      if case .selectTimeRangeAndFeature(let v)? = deleteOption {return v}
      return Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectTimeRangeAndFeature()
    }
    set {deleteOption = .selectTimeRangeAndFeature(newValue)}
  }

  /// Required. The resource name of the EntityType grouping the Features for
  /// which values are being deleted from. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  public var entityType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defines options to select feature values to be deleted.
  public enum OneOf_DeleteOption: Equatable, Sendable {
    /// Select feature values to be deleted by specifying entities.
    case selectEntity(Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectEntity)
    /// Select feature values to be deleted by specifying time range and
    /// features.
    case selectTimeRangeAndFeature(Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectTimeRangeAndFeature)

  }

  /// Message to select entity.
  /// If an entity id is selected, all the feature values corresponding to the
  /// entity id will be deleted, including the entityId.
  public struct SelectEntity: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Selectors choosing feature values of which entity id to be
    /// deleted from the EntityType.
    public var entityIDSelector: Google_Cloud_Aiplatform_V1_EntityIdSelector {
      get {return _entityIDSelector ?? Google_Cloud_Aiplatform_V1_EntityIdSelector()}
      set {_entityIDSelector = newValue}
    }
    /// Returns true if `entityIDSelector` has been explicitly set.
    public var hasEntityIDSelector: Bool {return self._entityIDSelector != nil}
    /// Clears the value of `entityIDSelector`. Subsequent reads from it will return its default value.
    public mutating func clearEntityIDSelector() {self._entityIDSelector = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityIDSelector: Google_Cloud_Aiplatform_V1_EntityIdSelector? = nil
  }

  /// Message to select time range and feature.
  /// Values of the selected feature generated within an inclusive time range
  /// will be deleted. Using this option permanently deletes the feature values
  /// from the specified feature IDs within the specified time range.
  /// This might include data from the online storage. If you want to retain
  /// any deleted historical data in the online storage, you must re-ingest it.
  public struct SelectTimeRangeAndFeature: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Select feature generated within a half-inclusive time range.
    /// The time range is lower inclusive and upper exclusive.
    public var timeRange: Google_Type_Interval {
      get {return _timeRange ?? Google_Type_Interval()}
      set {_timeRange = newValue}
    }
    /// Returns true if `timeRange` has been explicitly set.
    public var hasTimeRange: Bool {return self._timeRange != nil}
    /// Clears the value of `timeRange`. Subsequent reads from it will return its default value.
    public mutating func clearTimeRange() {self._timeRange = nil}

    /// Required. Selectors choosing which feature values to be deleted from the
    /// EntityType.
    public var featureSelector: Google_Cloud_Aiplatform_V1_FeatureSelector {
      get {return _featureSelector ?? Google_Cloud_Aiplatform_V1_FeatureSelector()}
      set {_featureSelector = newValue}
    }
    /// Returns true if `featureSelector` has been explicitly set.
    public var hasFeatureSelector: Bool {return self._featureSelector != nil}
    /// Clears the value of `featureSelector`. Subsequent reads from it will return its default value.
    public mutating func clearFeatureSelector() {self._featureSelector = nil}

    /// If set, data will not be deleted from online storage.
    /// When time range is older than the data in online storage, setting this to
    /// be true will make the deletion have no impact on online serving.
    public var skipOnlineStorageDelete: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timeRange: Google_Type_Interval? = nil
    fileprivate var _featureSelector: Google_Cloud_Aiplatform_V1_FeatureSelector? = nil
  }

  public init() {}
}

/// Response message for
/// [FeaturestoreService.DeleteFeatureValues][google.cloud.aiplatform.v1.FeaturestoreService.DeleteFeatureValues].
public struct Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Response based on which delete option is specified in the
  /// request
  public var response: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.OneOf_Response? = nil

  /// Response for request specifying the entities to delete
  public var selectEntity: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectEntity {
    get {
      if case .selectEntity(let v)? = response {return v}
      return Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectEntity()
    }
    set {response = .selectEntity(newValue)}
  }

  /// Response for request specifying time range and feature
  public var selectTimeRangeAndFeature: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectTimeRangeAndFeature {
    get {
      if case .selectTimeRangeAndFeature(let v)? = response {return v}
      return Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectTimeRangeAndFeature()
    }
    set {response = .selectTimeRangeAndFeature(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Response based on which delete option is specified in the
  /// request
  public enum OneOf_Response: Equatable, Sendable {
    /// Response for request specifying the entities to delete
    case selectEntity(Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectEntity)
    /// Response for request specifying time range and feature
    case selectTimeRangeAndFeature(Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectTimeRangeAndFeature)

  }

  /// Response message if the request uses the SelectEntity option.
  public struct SelectEntity: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The count of deleted entity rows in the offline storage.
    /// Each row corresponds to the combination of an entity ID and a timestamp.
    /// One entity ID can have multiple rows in the offline storage.
    public var offlineStorageDeletedEntityRowCount: Int64 = 0

    /// The count of deleted entities in the online storage.
    /// Each entity ID corresponds to one entity.
    public var onlineStorageDeletedEntityCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response message if the request uses the SelectTimeRangeAndFeature option.
  public struct SelectTimeRangeAndFeature: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The count of the features or columns impacted.
    /// This is the same as the feature count in the request.
    public var impactedFeatureCount: Int64 = 0

    /// The count of modified entity rows in the offline storage.
    /// Each row corresponds to the combination of an entity ID and a timestamp.
    /// One entity ID can have multiple rows in the offline storage.
    /// Within each row, only the features specified in the request are
    /// deleted.
    public var offlineStorageModifiedEntityRowCount: Int64 = 0

    /// The count of modified entities in the online storage.
    /// Each entity ID corresponds to one entity.
    /// Within each entity, only the features specified in the request are
    /// deleted.
    public var onlineStorageModifiedEntityCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Selector for entityId. Getting ids from the given source.
public struct Google_Cloud_Aiplatform_V1_EntityIdSelector: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details about the source data, including the location of the storage and
  /// the format.
  public var entityIdsSource: Google_Cloud_Aiplatform_V1_EntityIdSelector.OneOf_EntityIdsSource? = nil

  /// Source of Csv
  public var csvSource: Google_Cloud_Aiplatform_V1_CsvSource {
    get {
      if case .csvSource(let v)? = entityIdsSource {return v}
      return Google_Cloud_Aiplatform_V1_CsvSource()
    }
    set {entityIdsSource = .csvSource(newValue)}
  }

  /// Source column that holds entity IDs. If not provided, entity IDs are
  /// extracted from the column named entity_id.
  public var entityIDField: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Details about the source data, including the location of the storage and
  /// the format.
  public enum OneOf_EntityIdsSource: Equatable, Sendable {
    /// Source of Csv
    case csvSource(Google_Cloud_Aiplatform_V1_CsvSource)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_CreateFeaturestoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFeaturestoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "featurestore"),
    3: .standard(proto: "featurestore_id"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _featurestore: Google_Cloud_Aiplatform_V1_Featurestore? = nil
    var _featurestoreID: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _featurestore = source._featurestore
      _featurestoreID = source._featurestoreID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._featurestore) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._featurestoreID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      try { if let v = _storage._featurestore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._featurestoreID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._featurestoreID, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CreateFeaturestoreRequest, rhs: Google_Cloud_Aiplatform_V1_CreateFeaturestoreRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._featurestore != rhs_storage._featurestore {return false}
        if _storage._featurestoreID != rhs_storage._featurestoreID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GetFeaturestoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeaturestoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GetFeaturestoreRequest, rhs: Google_Cloud_Aiplatform_V1_GetFeaturestoreRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ListFeaturestoresRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeaturestoresRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "order_by"),
    6: .standard(proto: "read_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._readMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try { if let v = self._readMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ListFeaturestoresRequest, rhs: Google_Cloud_Aiplatform_V1_ListFeaturestoresRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._readMask != rhs._readMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ListFeaturestoresResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeaturestoresResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featurestores"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.featurestores) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.featurestores.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.featurestores, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ListFeaturestoresResponse, rhs: Google_Cloud_Aiplatform_V1_ListFeaturestoresResponse) -> Bool {
    if lhs.featurestores != rhs.featurestores {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_UpdateFeaturestoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFeaturestoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featurestore"),
    2: .standard(proto: "update_mask"),
  ]

  fileprivate class _StorageClass {
    var _featurestore: Google_Cloud_Aiplatform_V1_Featurestore? = nil
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _featurestore = source._featurestore
      _updateMask = source._updateMask
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._featurestore) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._featurestore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_UpdateFeaturestoreRequest, rhs: Google_Cloud_Aiplatform_V1_UpdateFeaturestoreRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._featurestore != rhs_storage._featurestore {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeaturestoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFeaturestoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeaturestoreRequest, rhs: Google_Cloud_Aiplatform_V1_DeleteFeaturestoreRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportFeatureValuesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "avro_source"),
    3: .standard(proto: "bigquery_source"),
    4: .standard(proto: "csv_source"),
    6: .standard(proto: "feature_time_field"),
    7: .standard(proto: "feature_time"),
    1: .standard(proto: "entity_type"),
    5: .standard(proto: "entity_id_field"),
    8: .standard(proto: "feature_specs"),
    9: .standard(proto: "disable_online_serving"),
    11: .standard(proto: "worker_count"),
    12: .standard(proto: "disable_ingestion_analysis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityType) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_AvroSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .avroSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .avroSource(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_BigQuerySource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .bigquerySource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .bigquerySource(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_CsvSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .csvSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .csvSource(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.entityIDField) }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.featureTimeSource != nil {try decoder.handleConflictingOneOf()}
          self.featureTimeSource = .featureTimeField(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.featureTimeSource {
          hadOneofValue = true
          if case .featureTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.featureTimeSource = .featureTime(v)
        }
      }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.featureSpecs) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.disableOnlineServing) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.workerCount) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.disableIngestionAnalysis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entityType.isEmpty {
      try visitor.visitSingularStringField(value: self.entityType, fieldNumber: 1)
    }
    switch self.source {
    case .avroSource?: try {
      guard case .avroSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bigquerySource?: try {
      guard case .bigquerySource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .csvSource?: try {
      guard case .csvSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.entityIDField.isEmpty {
      try visitor.visitSingularStringField(value: self.entityIDField, fieldNumber: 5)
    }
    switch self.featureTimeSource {
    case .featureTimeField?: try {
      guard case .featureTimeField(let v)? = self.featureTimeSource else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .featureTime?: try {
      guard case .featureTime(let v)? = self.featureTimeSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    if !self.featureSpecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.featureSpecs, fieldNumber: 8)
    }
    if self.disableOnlineServing != false {
      try visitor.visitSingularBoolField(value: self.disableOnlineServing, fieldNumber: 9)
    }
    if self.workerCount != 0 {
      try visitor.visitSingularInt32Field(value: self.workerCount, fieldNumber: 11)
    }
    if self.disableIngestionAnalysis != false {
      try visitor.visitSingularBoolField(value: self.disableIngestionAnalysis, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest, rhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.featureTimeSource != rhs.featureTimeSource {return false}
    if lhs.entityType != rhs.entityType {return false}
    if lhs.entityIDField != rhs.entityIDField {return false}
    if lhs.featureSpecs != rhs.featureSpecs {return false}
    if lhs.disableOnlineServing != rhs.disableOnlineServing {return false}
    if lhs.workerCount != rhs.workerCount {return false}
    if lhs.disableIngestionAnalysis != rhs.disableIngestionAnalysis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest.FeatureSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest.protoMessageName + ".FeatureSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "source_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.sourceField.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceField, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest.FeatureSpec, rhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesRequest.FeatureSpec) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.sourceField != rhs.sourceField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ImportFeatureValuesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportFeatureValuesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "imported_entity_count"),
    2: .standard(proto: "imported_feature_value_count"),
    6: .standard(proto: "invalid_row_count"),
    4: .standard(proto: "timestamp_outside_retention_rows_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.importedEntityCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.importedFeatureValueCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestampOutsideRetentionRowsCount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.invalidRowCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.importedEntityCount != 0 {
      try visitor.visitSingularInt64Field(value: self.importedEntityCount, fieldNumber: 1)
    }
    if self.importedFeatureValueCount != 0 {
      try visitor.visitSingularInt64Field(value: self.importedFeatureValueCount, fieldNumber: 2)
    }
    if self.timestampOutsideRetentionRowsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampOutsideRetentionRowsCount, fieldNumber: 4)
    }
    if self.invalidRowCount != 0 {
      try visitor.visitSingularInt64Field(value: self.invalidRowCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesResponse, rhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesResponse) -> Bool {
    if lhs.importedEntityCount != rhs.importedEntityCount {return false}
    if lhs.importedFeatureValueCount != rhs.importedFeatureValueCount {return false}
    if lhs.invalidRowCount != rhs.invalidRowCount {return false}
    if lhs.timestampOutsideRetentionRowsCount != rhs.timestampOutsideRetentionRowsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchReadFeatureValuesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "csv_read_instances"),
    5: .standard(proto: "bigquery_read_instances"),
    1: .same(proto: "featurestore"),
    4: .same(proto: "destination"),
    8: .standard(proto: "pass_through_fields"),
    7: .standard(proto: "entity_type_specs"),
    11: .standard(proto: "start_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.featurestore) }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_CsvSource?
        var hadOneofValue = false
        if let current = self.readOption {
          hadOneofValue = true
          if case .csvReadInstances(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.readOption = .csvReadInstances(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 5: try {
        var v: Google_Cloud_Aiplatform_V1_BigQuerySource?
        var hadOneofValue = false
        if let current = self.readOption {
          hadOneofValue = true
          if case .bigqueryReadInstances(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.readOption = .bigqueryReadInstances(v)
        }
      }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.entityTypeSpecs) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.passThroughFields) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.featurestore.isEmpty {
      try visitor.visitSingularStringField(value: self.featurestore, fieldNumber: 1)
    }
    try { if case .csvReadInstances(let v)? = self.readOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if case .bigqueryReadInstances(let v)? = self.readOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.entityTypeSpecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entityTypeSpecs, fieldNumber: 7)
    }
    if !self.passThroughFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.passThroughFields, fieldNumber: 8)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest, rhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest) -> Bool {
    if lhs.readOption != rhs.readOption {return false}
    if lhs.featurestore != rhs.featurestore {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.passThroughFields != rhs.passThroughFields {return false}
    if lhs.entityTypeSpecs != rhs.entityTypeSpecs {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.PassThroughField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.protoMessageName + ".PassThroughField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.PassThroughField, rhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.PassThroughField) -> Bool {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.EntityTypeSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.protoMessageName + ".EntityTypeSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_type_id"),
    2: .standard(proto: "feature_selector"),
    3: .same(proto: "settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityTypeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._featureSelector) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.settings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entityTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityTypeID, fieldNumber: 1)
    }
    try { if let v = self._featureSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.settings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.settings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.EntityTypeSpec, rhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesRequest.EntityTypeSpec) -> Bool {
    if lhs.entityTypeID != rhs.entityTypeID {return false}
    if lhs._featureSelector != rhs._featureSelector {return false}
    if lhs.settings != rhs.settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportFeatureValuesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "snapshot_export"),
    7: .standard(proto: "full_export"),
    1: .standard(proto: "entity_type"),
    4: .same(proto: "destination"),
    5: .standard(proto: "feature_selector"),
    6: .same(proto: "settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityType) }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.SnapshotExport?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .snapshotExport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .snapshotExport(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._featureSelector) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.settings) }()
      case 7: try {
        var v: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.FullExport?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .fullExport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .fullExport(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entityType.isEmpty {
      try visitor.visitSingularStringField(value: self.entityType, fieldNumber: 1)
    }
    try { if case .snapshotExport(let v)? = self.mode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._featureSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.settings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.settings, fieldNumber: 6)
    }
    try { if case .fullExport(let v)? = self.mode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest, rhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.entityType != rhs.entityType {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs._featureSelector != rhs._featureSelector {return false}
    if lhs.settings != rhs.settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.SnapshotExport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.protoMessageName + ".SnapshotExport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "snapshot_time"),
    2: .standard(proto: "start_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._snapshotTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._snapshotTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.SnapshotExport, rhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.SnapshotExport) -> Bool {
    if lhs._snapshotTime != rhs._snapshotTime {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.FullExport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.protoMessageName + ".FullExport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "start_time"),
    1: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.FullExport, rhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesRequest.FullExport) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DestinationFeatureSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DestinationFeatureSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_id"),
    2: .standard(proto: "destination_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.featureID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destinationField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.featureID.isEmpty {
      try visitor.visitSingularStringField(value: self.featureID, fieldNumber: 1)
    }
    if !self.destinationField.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationField, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DestinationFeatureSetting, rhs: Google_Cloud_Aiplatform_V1_DestinationFeatureSetting) -> Bool {
    if lhs.featureID != rhs.featureID {return false}
    if lhs.destinationField != rhs.destinationField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureValueDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureValueDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bigquery_destination"),
    2: .standard(proto: "tfrecord_destination"),
    3: .standard(proto: "csv_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_BigQueryDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .bigqueryDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .bigqueryDestination(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_TFRecordDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .tfrecordDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .tfrecordDestination(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_CsvDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .csvDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .csvDestination(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.destination {
    case .bigqueryDestination?: try {
      guard case .bigqueryDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .tfrecordDestination?: try {
      guard case .tfrecordDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .csvDestination?: try {
      guard case .csvDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureValueDestination, rhs: Google_Cloud_Aiplatform_V1_FeatureValueDestination) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExportFeatureValuesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportFeatureValuesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesResponse, rhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchReadFeatureValuesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesResponse, rhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CreateEntityTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEntityTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "entity_type"),
    3: .standard(proto: "entity_type_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entityType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.entityTypeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._entityType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.entityTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityTypeID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CreateEntityTypeRequest, rhs: Google_Cloud_Aiplatform_V1_CreateEntityTypeRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._entityType != rhs._entityType {return false}
    if lhs.entityTypeID != rhs.entityTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GetEntityTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEntityTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GetEntityTypeRequest, rhs: Google_Cloud_Aiplatform_V1_GetEntityTypeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ListEntityTypesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEntityTypesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "order_by"),
    6: .standard(proto: "read_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._readMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try { if let v = self._readMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ListEntityTypesRequest, rhs: Google_Cloud_Aiplatform_V1_ListEntityTypesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._readMask != rhs._readMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ListEntityTypesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEntityTypesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_types"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entityTypes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entityTypes, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ListEntityTypesResponse, rhs: Google_Cloud_Aiplatform_V1_ListEntityTypesResponse) -> Bool {
    if lhs.entityTypes != rhs.entityTypes {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_UpdateEntityTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateEntityTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_type"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entityType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_UpdateEntityTypeRequest, rhs: Google_Cloud_Aiplatform_V1_UpdateEntityTypeRequest) -> Bool {
    if lhs._entityType != rhs._entityType {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteEntityTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteEntityTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteEntityTypeRequest, rhs: Google_Cloud_Aiplatform_V1_DeleteEntityTypeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CreateFeatureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFeatureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "feature"),
    3: .standard(proto: "feature_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feature) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.featureID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._feature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.featureID.isEmpty {
      try visitor.visitSingularStringField(value: self.featureID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CreateFeatureRequest, rhs: Google_Cloud_Aiplatform_V1_CreateFeatureRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._feature != rhs._feature {return false}
    if lhs.featureID != rhs.featureID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchCreateFeaturesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateFeaturesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchCreateFeaturesRequest, rhs: Google_Cloud_Aiplatform_V1_BatchCreateFeaturesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchCreateFeaturesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateFeaturesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.features) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchCreateFeaturesResponse, rhs: Google_Cloud_Aiplatform_V1_BatchCreateFeaturesResponse) -> Bool {
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GetFeatureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeatureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GetFeatureRequest, rhs: Google_Cloud_Aiplatform_V1_GetFeatureRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ListFeaturesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeaturesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "order_by"),
    6: .standard(proto: "read_mask"),
    7: .standard(proto: "latest_stats_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._readMask) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.latestStatsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try { if let v = self._readMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.latestStatsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.latestStatsCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ListFeaturesRequest, rhs: Google_Cloud_Aiplatform_V1_ListFeaturesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._readMask != rhs._readMask {return false}
    if lhs.latestStatsCount != rhs.latestStatsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ListFeaturesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeaturesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.features) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ListFeaturesResponse, rhs: Google_Cloud_Aiplatform_V1_ListFeaturesResponse) -> Bool {
    if lhs.features != rhs.features {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SearchFeaturesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchFeaturesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    3: .same(proto: "query"),
    4: .standard(proto: "page_size"),
    5: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SearchFeaturesRequest, rhs: Google_Cloud_Aiplatform_V1_SearchFeaturesRequest) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.query != rhs.query {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SearchFeaturesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchFeaturesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.features) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SearchFeaturesResponse, rhs: Google_Cloud_Aiplatform_V1_SearchFeaturesResponse) -> Bool {
    if lhs.features != rhs.features {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_UpdateFeatureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFeatureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feature"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._feature) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._feature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_UpdateFeatureRequest, rhs: Google_Cloud_Aiplatform_V1_UpdateFeatureRequest) -> Bool {
    if lhs._feature != rhs._feature {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFeatureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureRequest, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CreateFeaturestoreOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFeaturestoreOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CreateFeaturestoreOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_CreateFeaturestoreOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_UpdateFeaturestoreOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFeaturestoreOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_UpdateFeaturestoreOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_UpdateFeaturestoreOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ImportFeatureValuesOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportFeatureValuesOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
    2: .standard(proto: "imported_entity_count"),
    3: .standard(proto: "imported_feature_value_count"),
    4: .standard(proto: "source_uris"),
    6: .standard(proto: "invalid_row_count"),
    7: .standard(proto: "timestamp_outside_retention_rows_count"),
    8: .standard(proto: "blocking_operation_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.importedEntityCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.importedFeatureValueCount) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.sourceUris) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.invalidRowCount) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.timestampOutsideRetentionRowsCount) }()
      case 8: try { try decoder.decodeRepeatedInt64Field(value: &self.blockingOperationIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.importedEntityCount != 0 {
      try visitor.visitSingularInt64Field(value: self.importedEntityCount, fieldNumber: 2)
    }
    if self.importedFeatureValueCount != 0 {
      try visitor.visitSingularInt64Field(value: self.importedFeatureValueCount, fieldNumber: 3)
    }
    if !self.sourceUris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceUris, fieldNumber: 4)
    }
    if self.invalidRowCount != 0 {
      try visitor.visitSingularInt64Field(value: self.invalidRowCount, fieldNumber: 6)
    }
    if self.timestampOutsideRetentionRowsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampOutsideRetentionRowsCount, fieldNumber: 7)
    }
    if !self.blockingOperationIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.blockingOperationIds, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_ImportFeatureValuesOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.importedEntityCount != rhs.importedEntityCount {return false}
    if lhs.importedFeatureValueCount != rhs.importedFeatureValueCount {return false}
    if lhs.sourceUris != rhs.sourceUris {return false}
    if lhs.invalidRowCount != rhs.invalidRowCount {return false}
    if lhs.timestampOutsideRetentionRowsCount != rhs.timestampOutsideRetentionRowsCount {return false}
    if lhs.blockingOperationIds != rhs.blockingOperationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExportFeatureValuesOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportFeatureValuesOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_ExportFeatureValuesOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchReadFeatureValuesOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_BatchReadFeatureValuesOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureValuesOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFeatureValuesOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CreateEntityTypeOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEntityTypeOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CreateEntityTypeOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_CreateEntityTypeOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_CreateFeatureOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFeatureOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_CreateFeatureOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_CreateFeatureOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BatchCreateFeaturesOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateFeaturesOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genericMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BatchCreateFeaturesOperationMetadata, rhs: Google_Cloud_Aiplatform_V1_BatchCreateFeaturesOperationMetadata) -> Bool {
    if lhs._genericMetadata != rhs._genericMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFeatureValuesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "select_entity"),
    3: .standard(proto: "select_time_range_and_feature"),
    1: .standard(proto: "entity_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityType) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectEntity?
        var hadOneofValue = false
        if let current = self.deleteOption {
          hadOneofValue = true
          if case .selectEntity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deleteOption = .selectEntity(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectTimeRangeAndFeature?
        var hadOneofValue = false
        if let current = self.deleteOption {
          hadOneofValue = true
          if case .selectTimeRangeAndFeature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deleteOption = .selectTimeRangeAndFeature(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entityType.isEmpty {
      try visitor.visitSingularStringField(value: self.entityType, fieldNumber: 1)
    }
    switch self.deleteOption {
    case .selectEntity?: try {
      guard case .selectEntity(let v)? = self.deleteOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .selectTimeRangeAndFeature?: try {
      guard case .selectTimeRangeAndFeature(let v)? = self.deleteOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest) -> Bool {
    if lhs.deleteOption != rhs.deleteOption {return false}
    if lhs.entityType != rhs.entityType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.protoMessageName + ".SelectEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id_selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityIDSelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entityIDSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectEntity, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectEntity) -> Bool {
    if lhs._entityIDSelector != rhs._entityIDSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectTimeRangeAndFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.protoMessageName + ".SelectTimeRangeAndFeature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_range"),
    2: .standard(proto: "feature_selector"),
    3: .standard(proto: "skip_online_storage_delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._featureSelector) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.skipOnlineStorageDelete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._featureSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.skipOnlineStorageDelete != false {
      try visitor.visitSingularBoolField(value: self.skipOnlineStorageDelete, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectTimeRangeAndFeature, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesRequest.SelectTimeRangeAndFeature) -> Bool {
    if lhs._timeRange != rhs._timeRange {return false}
    if lhs._featureSelector != rhs._featureSelector {return false}
    if lhs.skipOnlineStorageDelete != rhs.skipOnlineStorageDelete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFeatureValuesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "select_entity"),
    2: .standard(proto: "select_time_range_and_feature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectEntity?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .selectEntity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .selectEntity(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectTimeRangeAndFeature?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .selectTimeRangeAndFeature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .selectTimeRangeAndFeature(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .selectEntity?: try {
      guard case .selectEntity(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .selectTimeRangeAndFeature?: try {
      guard case .selectTimeRangeAndFeature(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.protoMessageName + ".SelectEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offline_storage_deleted_entity_row_count"),
    2: .standard(proto: "online_storage_deleted_entity_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.offlineStorageDeletedEntityRowCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.onlineStorageDeletedEntityCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offlineStorageDeletedEntityRowCount != 0 {
      try visitor.visitSingularInt64Field(value: self.offlineStorageDeletedEntityRowCount, fieldNumber: 1)
    }
    if self.onlineStorageDeletedEntityCount != 0 {
      try visitor.visitSingularInt64Field(value: self.onlineStorageDeletedEntityCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectEntity, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectEntity) -> Bool {
    if lhs.offlineStorageDeletedEntityRowCount != rhs.offlineStorageDeletedEntityRowCount {return false}
    if lhs.onlineStorageDeletedEntityCount != rhs.onlineStorageDeletedEntityCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectTimeRangeAndFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.protoMessageName + ".SelectTimeRangeAndFeature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "impacted_feature_count"),
    2: .standard(proto: "offline_storage_modified_entity_row_count"),
    3: .standard(proto: "online_storage_modified_entity_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.impactedFeatureCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offlineStorageModifiedEntityRowCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.onlineStorageModifiedEntityCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.impactedFeatureCount != 0 {
      try visitor.visitSingularInt64Field(value: self.impactedFeatureCount, fieldNumber: 1)
    }
    if self.offlineStorageModifiedEntityRowCount != 0 {
      try visitor.visitSingularInt64Field(value: self.offlineStorageModifiedEntityRowCount, fieldNumber: 2)
    }
    if self.onlineStorageModifiedEntityCount != 0 {
      try visitor.visitSingularInt64Field(value: self.onlineStorageModifiedEntityCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectTimeRangeAndFeature, rhs: Google_Cloud_Aiplatform_V1_DeleteFeatureValuesResponse.SelectTimeRangeAndFeature) -> Bool {
    if lhs.impactedFeatureCount != rhs.impactedFeatureCount {return false}
    if lhs.offlineStorageModifiedEntityRowCount != rhs.offlineStorageModifiedEntityRowCount {return false}
    if lhs.onlineStorageModifiedEntityCount != rhs.onlineStorageModifiedEntityCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_EntityIdSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityIdSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "csv_source"),
    5: .standard(proto: "entity_id_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_CsvSource?
        var hadOneofValue = false
        if let current = self.entityIdsSource {
          hadOneofValue = true
          if case .csvSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entityIdsSource = .csvSource(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.entityIDField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .csvSource(let v)? = self.entityIdsSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.entityIDField.isEmpty {
      try visitor.visitSingularStringField(value: self.entityIDField, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_EntityIdSelector, rhs: Google_Cloud_Aiplatform_V1_EntityIdSelector) -> Bool {
    if lhs.entityIdsSource != rhs.entityIdsSource {return false}
    if lhs.entityIDField != rhs.entityIDField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
