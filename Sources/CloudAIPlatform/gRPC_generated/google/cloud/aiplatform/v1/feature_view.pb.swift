// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/feature_view.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// FeatureView is representation of values that the FeatureOnlineStore will
/// serve based on its syncConfig.
public struct Google_Cloud_Aiplatform_V1_FeatureView: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: OneOf_Source? {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  /// Optional. Configures how data is supposed to be extracted from a BigQuery
  /// source to be loaded onto the FeatureOnlineStore.
  public var bigQuerySource: Google_Cloud_Aiplatform_V1_FeatureView.BigQuerySource {
    get {
      if case .bigQuerySource(let v)? = _storage._source {return v}
      return Google_Cloud_Aiplatform_V1_FeatureView.BigQuerySource()
    }
    set {_uniqueStorage()._source = .bigQuerySource(newValue)}
  }

  /// Optional. Configures the features from a Feature Registry source that
  /// need to be loaded onto the FeatureOnlineStore.
  public var featureRegistrySource: Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource {
    get {
      if case .featureRegistrySource(let v)? = _storage._source {return v}
      return Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource()
    }
    set {_uniqueStorage()._source = .featureRegistrySource(newValue)}
  }

  /// Identifier. Name of the FeatureView. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Output only. Timestamp when this FeatureView was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Timestamp when this FeatureView was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  public var etag: String {
    get {return _storage._etag}
    set {_uniqueStorage()._etag = newValue}
  }

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureViews.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Configures when data is to be synced/updated for this FeatureView. At the
  /// end of the sync the latest featureValues for each entityId of this
  /// FeatureView are made ready for online serving.
  public var syncConfig: Google_Cloud_Aiplatform_V1_FeatureView.SyncConfig {
    get {return _storage._syncConfig ?? Google_Cloud_Aiplatform_V1_FeatureView.SyncConfig()}
    set {_uniqueStorage()._syncConfig = newValue}
  }
  /// Returns true if `syncConfig` has been explicitly set.
  public var hasSyncConfig: Bool {return _storage._syncConfig != nil}
  /// Clears the value of `syncConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSyncConfig() {_uniqueStorage()._syncConfig = nil}

  /// Optional. Configuration for index preparation for vector search. It
  /// contains the required configurations to create an index from source data,
  /// so that approximate nearest neighbor (a.k.a ANN) algorithms search can be
  /// performed during online serving.
  public var indexConfig: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig {
    get {return _storage._indexConfig ?? Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig()}
    set {_uniqueStorage()._indexConfig = newValue}
  }
  /// Returns true if `indexConfig` has been explicitly set.
  public var hasIndexConfig: Bool {return _storage._indexConfig != nil}
  /// Clears the value of `indexConfig`. Subsequent reads from it will return its default value.
  public mutating func clearIndexConfig() {_uniqueStorage()._indexConfig = nil}

  /// Output only. Reserved for future use.
  public var satisfiesPzs: Bool {
    get {return _storage._satisfiesPzs}
    set {_uniqueStorage()._satisfiesPzs = newValue}
  }

  /// Output only. Reserved for future use.
  public var satisfiesPzi: Bool {
    get {return _storage._satisfiesPzi}
    set {_uniqueStorage()._satisfiesPzi = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Source: Equatable, Sendable {
    /// Optional. Configures how data is supposed to be extracted from a BigQuery
    /// source to be loaded onto the FeatureOnlineStore.
    case bigQuerySource(Google_Cloud_Aiplatform_V1_FeatureView.BigQuerySource)
    /// Optional. Configures the features from a Feature Registry source that
    /// need to be loaded onto the FeatureOnlineStore.
    case featureRegistrySource(Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource)

  }

  public struct BigQuerySource: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The BigQuery view URI that will be materialized on each sync
    /// trigger based on FeatureView.SyncConfig.
    public var uri: String = String()

    /// Required. Columns to construct entity_id / row keys.
    public var entityIDColumns: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Configuration for Sync. Only one option is set.
  public struct SyncConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
    /// runs. To explicitly set a timezone to the cron tab, apply a prefix in
    /// the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
    /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
    /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
    /// "TZ=America/New_York 1 * * * *".
    public var cron: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Configuration for vector indexing.
  public struct IndexConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The configuration with regard to the algorithms used for efficient
    /// search.
    public var algorithmConfig: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.OneOf_AlgorithmConfig? = nil

    /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
    /// + Asymmetric Hashing). Please refer to this paper for more details:
    /// https://arxiv.org/abs/1908.10396
    public var treeAhConfig: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.TreeAHConfig {
      get {
        if case .treeAhConfig(let v)? = algorithmConfig {return v}
        return Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.TreeAHConfig()
      }
      set {algorithmConfig = .treeAhConfig(newValue)}
    }

    /// Optional. Configuration options for using brute force search, which
    /// simply implements the standard linear search in the database for each
    /// query. It is primarily meant for benchmarking and to generate the
    /// ground truth for approximate search.
    public var bruteForceConfig: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.BruteForceConfig {
      get {
        if case .bruteForceConfig(let v)? = algorithmConfig {return v}
        return Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.BruteForceConfig()
      }
      set {algorithmConfig = .bruteForceConfig(newValue)}
    }

    /// Optional. Column of embedding. This column contains the source data to
    /// create index for vector search. embedding_column must be set when using
    /// vector search.
    public var embeddingColumn: String = String()

    /// Optional. Columns of features that're used to filter vector search
    /// results.
    public var filterColumns: [String] = []

    /// Optional. Column of crowding. This column contains crowding attribute
    /// which is a constraint on a neighbor list produced by
    /// [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]
    /// to diversify search results. If
    /// [NearestNeighborQuery.per_crowding_attribute_neighbor_count][google.cloud.aiplatform.v1.NearestNeighborQuery.per_crowding_attribute_neighbor_count]
    /// is set to K in
    /// [SearchNearestEntitiesRequest][google.cloud.aiplatform.v1.SearchNearestEntitiesRequest],
    /// it's guaranteed that no more than K entities of the same crowding
    /// attribute are returned in the response.
    public var crowdingColumn: String = String()

    /// Optional. The number of dimensions of the input embedding.
    public var embeddingDimension: Int32 {
      get {return _embeddingDimension ?? 0}
      set {_embeddingDimension = newValue}
    }
    /// Returns true if `embeddingDimension` has been explicitly set.
    public var hasEmbeddingDimension: Bool {return self._embeddingDimension != nil}
    /// Clears the value of `embeddingDimension`. Subsequent reads from it will return its default value.
    public mutating func clearEmbeddingDimension() {self._embeddingDimension = nil}

    /// Optional. The distance measure used in nearest neighbor search.
    public var distanceMeasureType: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.DistanceMeasureType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The configuration with regard to the algorithms used for efficient
    /// search.
    public enum OneOf_AlgorithmConfig: Equatable, Sendable {
      /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
      /// + Asymmetric Hashing). Please refer to this paper for more details:
      /// https://arxiv.org/abs/1908.10396
      case treeAhConfig(Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.TreeAHConfig)
      /// Optional. Configuration options for using brute force search, which
      /// simply implements the standard linear search in the database for each
      /// query. It is primarily meant for benchmarking and to generate the
      /// ground truth for approximate search.
      case bruteForceConfig(Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.BruteForceConfig)

    }

    /// The distance measure used in nearest neighbor search.
    public enum DistanceMeasureType: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Should not be set.
      case unspecified // = 0

      /// Euclidean (L_2) Distance.
      case squaredL2Distance // = 1

      /// Cosine Distance. Defined as 1 - cosine similarity.
      ///
      /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
      /// of COSINE distance. Our algorithms have been more optimized for
      /// DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
      /// mathematically equivalent to COSINE distance and results in the same
      /// ranking.
      case cosineDistance // = 2

      /// Dot Product Distance. Defined as a negative of the dot product.
      case dotProductDistance // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .squaredL2Distance
        case 2: self = .cosineDistance
        case 3: self = .dotProductDistance
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .squaredL2Distance: return 1
        case .cosineDistance: return 2
        case .dotProductDistance: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.DistanceMeasureType] = [
        .unspecified,
        .squaredL2Distance,
        .cosineDistance,
        .dotProductDistance,
      ]

    }

    /// Configuration options for using brute force search.
    public struct BruteForceConfig: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Configuration options for the tree-AH algorithm.
    public struct TreeAHConfig: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Optional. Number of embeddings on each leaf node. The default value is
      /// 1000 if not set.
      public var leafNodeEmbeddingCount: Int64 {
        get {return _leafNodeEmbeddingCount ?? 0}
        set {_leafNodeEmbeddingCount = newValue}
      }
      /// Returns true if `leafNodeEmbeddingCount` has been explicitly set.
      public var hasLeafNodeEmbeddingCount: Bool {return self._leafNodeEmbeddingCount != nil}
      /// Clears the value of `leafNodeEmbeddingCount`. Subsequent reads from it will return its default value.
      public mutating func clearLeafNodeEmbeddingCount() {self._leafNodeEmbeddingCount = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _leafNodeEmbeddingCount: Int64? = nil
    }

    public init() {}

    fileprivate var _embeddingDimension: Int32? = nil
  }

  /// A Feature Registry source for features that need to be synced to Online
  /// Store.
  public struct FeatureRegistrySource: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. List of features that need to be synced to Online Store.
    public var featureGroups: [Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource.FeatureGroup] = []

    /// Optional. The project number of the parent project of the Feature Groups.
    public var projectNumber: Int64 {
      get {return _projectNumber ?? 0}
      set {_projectNumber = newValue}
    }
    /// Returns true if `projectNumber` has been explicitly set.
    public var hasProjectNumber: Bool {return self._projectNumber != nil}
    /// Clears the value of `projectNumber`. Subsequent reads from it will return its default value.
    public mutating func clearProjectNumber() {self._projectNumber = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Features belonging to a single feature group that will be
    /// synced to Online Store.
    public struct FeatureGroup: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. Identifier of the feature group.
      public var featureGroupID: String = String()

      /// Required. Identifiers of features under the feature group.
      public var featureIds: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _projectNumber: Int64? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_FeatureView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "big_query_source"),
    9: .standard(proto: "feature_registry_source"),
    1: .same(proto: "name"),
    2: .standard(proto: "create_time"),
    3: .standard(proto: "update_time"),
    4: .same(proto: "etag"),
    5: .same(proto: "labels"),
    7: .standard(proto: "sync_config"),
    15: .standard(proto: "index_config"),
    19: .standard(proto: "satisfies_pzs"),
    20: .standard(proto: "satisfies_pzi"),
  ]

  fileprivate class _StorageClass {
    var _source: Google_Cloud_Aiplatform_V1_FeatureView.OneOf_Source?
    var _name: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _etag: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _syncConfig: Google_Cloud_Aiplatform_V1_FeatureView.SyncConfig? = nil
    var _indexConfig: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig? = nil
    var _satisfiesPzs: Bool = false
    var _satisfiesPzi: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _source = source._source
      _name = source._name
      _createTime = source._createTime
      _updateTime = source._updateTime
      _etag = source._etag
      _labels = source._labels
      _syncConfig = source._syncConfig
      _indexConfig = source._indexConfig
      _satisfiesPzs = source._satisfiesPzs
      _satisfiesPzi = source._satisfiesPzi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._etag) }()
        case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 6: try {
          var v: Google_Cloud_Aiplatform_V1_FeatureView.BigQuerySource?
          var hadOneofValue = false
          if let current = _storage._source {
            hadOneofValue = true
            if case .bigQuerySource(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._source = .bigQuerySource(v)
          }
        }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._syncConfig) }()
        case 9: try {
          var v: Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource?
          var hadOneofValue = false
          if let current = _storage._source {
            hadOneofValue = true
            if case .featureRegistrySource(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._source = .featureRegistrySource(v)
          }
        }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._indexConfig) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzs) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzi) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._etag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._etag, fieldNumber: 4)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 5)
      }
      try { if case .bigQuerySource(let v)? = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._syncConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if case .featureRegistrySource(let v)? = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._indexConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._satisfiesPzs != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzs, fieldNumber: 19)
      }
      if _storage._satisfiesPzi != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzi, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView, rhs: Google_Cloud_Aiplatform_V1_FeatureView) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._source != rhs_storage._source {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._etag != rhs_storage._etag {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._syncConfig != rhs_storage._syncConfig {return false}
        if _storage._indexConfig != rhs_storage._indexConfig {return false}
        if _storage._satisfiesPzs != rhs_storage._satisfiesPzs {return false}
        if _storage._satisfiesPzi != rhs_storage._satisfiesPzi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureView.BigQuerySource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureView.protoMessageName + ".BigQuerySource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .standard(proto: "entity_id_columns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.entityIDColumns) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.entityIDColumns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.entityIDColumns, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView.BigQuerySource, rhs: Google_Cloud_Aiplatform_V1_FeatureView.BigQuerySource) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.entityIDColumns != rhs.entityIDColumns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureView.SyncConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureView.protoMessageName + ".SyncConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cron"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cron) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cron.isEmpty {
      try visitor.visitSingularStringField(value: self.cron, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView.SyncConfig, rhs: Google_Cloud_Aiplatform_V1_FeatureView.SyncConfig) -> Bool {
    if lhs.cron != rhs.cron {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureView.protoMessageName + ".IndexConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "tree_ah_config"),
    7: .standard(proto: "brute_force_config"),
    1: .standard(proto: "embedding_column"),
    2: .standard(proto: "filter_columns"),
    3: .standard(proto: "crowding_column"),
    4: .standard(proto: "embedding_dimension"),
    5: .standard(proto: "distance_measure_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.embeddingColumn) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.filterColumns) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.crowdingColumn) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._embeddingDimension) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.distanceMeasureType) }()
      case 6: try {
        var v: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.TreeAHConfig?
        var hadOneofValue = false
        if let current = self.algorithmConfig {
          hadOneofValue = true
          if case .treeAhConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.algorithmConfig = .treeAhConfig(v)
        }
      }()
      case 7: try {
        var v: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.BruteForceConfig?
        var hadOneofValue = false
        if let current = self.algorithmConfig {
          hadOneofValue = true
          if case .bruteForceConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.algorithmConfig = .bruteForceConfig(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.embeddingColumn.isEmpty {
      try visitor.visitSingularStringField(value: self.embeddingColumn, fieldNumber: 1)
    }
    if !self.filterColumns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filterColumns, fieldNumber: 2)
    }
    if !self.crowdingColumn.isEmpty {
      try visitor.visitSingularStringField(value: self.crowdingColumn, fieldNumber: 3)
    }
    try { if let v = self._embeddingDimension {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    if self.distanceMeasureType != .unspecified {
      try visitor.visitSingularEnumField(value: self.distanceMeasureType, fieldNumber: 5)
    }
    switch self.algorithmConfig {
    case .treeAhConfig?: try {
      guard case .treeAhConfig(let v)? = self.algorithmConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bruteForceConfig?: try {
      guard case .bruteForceConfig(let v)? = self.algorithmConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig, rhs: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig) -> Bool {
    if lhs.algorithmConfig != rhs.algorithmConfig {return false}
    if lhs.embeddingColumn != rhs.embeddingColumn {return false}
    if lhs.filterColumns != rhs.filterColumns {return false}
    if lhs.crowdingColumn != rhs.crowdingColumn {return false}
    if lhs._embeddingDimension != rhs._embeddingDimension {return false}
    if lhs.distanceMeasureType != rhs.distanceMeasureType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.DistanceMeasureType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISTANCE_MEASURE_TYPE_UNSPECIFIED"),
    1: .same(proto: "SQUARED_L2_DISTANCE"),
    2: .same(proto: "COSINE_DISTANCE"),
    3: .same(proto: "DOT_PRODUCT_DISTANCE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.BruteForceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.protoMessageName + ".BruteForceConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.BruteForceConfig, rhs: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.BruteForceConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.TreeAHConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.protoMessageName + ".TreeAHConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaf_node_embedding_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._leafNodeEmbeddingCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._leafNodeEmbeddingCount {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.TreeAHConfig, rhs: Google_Cloud_Aiplatform_V1_FeatureView.IndexConfig.TreeAHConfig) -> Bool {
    if lhs._leafNodeEmbeddingCount != rhs._leafNodeEmbeddingCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureView.protoMessageName + ".FeatureRegistrySource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_groups"),
    2: .standard(proto: "project_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.featureGroups) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._projectNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.featureGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.featureGroups, fieldNumber: 1)
    }
    try { if let v = self._projectNumber {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource, rhs: Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource) -> Bool {
    if lhs.featureGroups != rhs.featureGroups {return false}
    if lhs._projectNumber != rhs._projectNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource.FeatureGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource.protoMessageName + ".FeatureGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_group_id"),
    2: .standard(proto: "feature_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.featureGroupID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.featureIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.featureGroupID.isEmpty {
      try visitor.visitSingularStringField(value: self.featureGroupID, fieldNumber: 1)
    }
    if !self.featureIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.featureIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource.FeatureGroup, rhs: Google_Cloud_Aiplatform_V1_FeatureView.FeatureRegistrySource.FeatureGroup) -> Bool {
    if lhs.featureGroupID != rhs.featureGroupID {return false}
    if lhs.featureIds != rhs.featureIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
