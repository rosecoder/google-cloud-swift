// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A trained machine learning Model.
public struct Google_Cloud_Aiplatform_V1_Model: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the Model.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Output only. Immutable. The version ID of the model.
  /// A new version is committed when a new model version is uploaded or
  /// trained under an existing model id. It is an auto-incrementing decimal
  /// number in string representation.
  public var versionID: String {
    get {return _storage._versionID}
    set {_uniqueStorage()._versionID = newValue}
  }

  /// User provided version aliases so that a model version can be referenced via
  /// alias (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
  /// instead of auto-generated version id (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
  /// The format is [a-z][a-zA-Z0-9-]{0,126}[a-z0-9] to distinguish from
  /// version_id. A default version alias will be created for the first version
  /// of the model, and there must be exactly one default version alias for a
  /// model.
  public var versionAliases: [String] {
    get {return _storage._versionAliases}
    set {_uniqueStorage()._versionAliases = newValue}
  }

  /// Output only. Timestamp when this version was created.
  public var versionCreateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._versionCreateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._versionCreateTime = newValue}
  }
  /// Returns true if `versionCreateTime` has been explicitly set.
  public var hasVersionCreateTime: Bool {return _storage._versionCreateTime != nil}
  /// Clears the value of `versionCreateTime`. Subsequent reads from it will return its default value.
  public mutating func clearVersionCreateTime() {_uniqueStorage()._versionCreateTime = nil}

  /// Output only. Timestamp when this version was most recently updated.
  public var versionUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._versionUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._versionUpdateTime = newValue}
  }
  /// Returns true if `versionUpdateTime` has been explicitly set.
  public var hasVersionUpdateTime: Bool {return _storage._versionUpdateTime != nil}
  /// Clears the value of `versionUpdateTime`. Subsequent reads from it will return its default value.
  public mutating func clearVersionUpdateTime() {_uniqueStorage()._versionUpdateTime = nil}

  /// Required. The display name of the Model.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// The description of the Model.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The description of this version.
  public var versionDescription: String {
    get {return _storage._versionDescription}
    set {_uniqueStorage()._versionDescription = newValue}
  }

  /// The schemata that describe formats of the Model's predictions and
  /// explanations as given and returned via
  /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
  /// and
  /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
  public var predictSchemata: Google_Cloud_Aiplatform_V1_PredictSchemata {
    get {return _storage._predictSchemata ?? Google_Cloud_Aiplatform_V1_PredictSchemata()}
    set {_uniqueStorage()._predictSchemata = newValue}
  }
  /// Returns true if `predictSchemata` has been explicitly set.
  public var hasPredictSchemata: Bool {return _storage._predictSchemata != nil}
  /// Clears the value of `predictSchemata`. Subsequent reads from it will return its default value.
  public mutating func clearPredictSchemata() {_uniqueStorage()._predictSchemata = nil}

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Model, that is specific to it. Unset if
  /// the Model does not have any additional information. The schema is defined
  /// as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// additional metadata is needed, this field is set to an empty string.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  public var metadataSchemaUri: String {
    get {return _storage._metadataSchemaUri}
    set {_uniqueStorage()._metadataSchemaUri = newValue}
  }

  /// Immutable. An additional information about the Model; the schema of the
  /// metadata can be found in
  /// [metadata_schema][google.cloud.aiplatform.v1.Model.metadata_schema_uri].
  /// Unset if the Model does not have any additional information.
  public var metadata: SwiftProtobuf.Google_Protobuf_Value {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Output only. The formats in which this Model may be exported. If empty,
  /// this Model is not available for export.
  public var supportedExportFormats: [Google_Cloud_Aiplatform_V1_Model.ExportFormat] {
    get {return _storage._supportedExportFormats}
    set {_uniqueStorage()._supportedExportFormats = newValue}
  }

  /// Output only. The resource name of the TrainingPipeline that uploaded this
  /// Model, if any.
  public var trainingPipeline: String {
    get {return _storage._trainingPipeline}
    set {_uniqueStorage()._trainingPipeline = newValue}
  }

  /// Optional. This field is populated if the model is produced by a pipeline
  /// job.
  public var pipelineJob: String {
    get {return _storage._pipelineJob}
    set {_uniqueStorage()._pipelineJob = newValue}
  }

  /// Input only. The specification of the container that is to be used when
  /// deploying this Model. The specification is ingested upon
  /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel],
  /// and all binaries it contains are copied and stored internally by Vertex AI.
  /// Not required for AutoML Models.
  public var containerSpec: Google_Cloud_Aiplatform_V1_ModelContainerSpec {
    get {return _storage._containerSpec ?? Google_Cloud_Aiplatform_V1_ModelContainerSpec()}
    set {_uniqueStorage()._containerSpec = newValue}
  }
  /// Returns true if `containerSpec` has been explicitly set.
  public var hasContainerSpec: Bool {return _storage._containerSpec != nil}
  /// Clears the value of `containerSpec`. Subsequent reads from it will return its default value.
  public mutating func clearContainerSpec() {_uniqueStorage()._containerSpec = nil}

  /// Immutable. The path to the directory containing the Model artifact and any
  /// of its supporting files. Not required for AutoML Models.
  public var artifactUri: String {
    get {return _storage._artifactUri}
    set {_uniqueStorage()._artifactUri = newValue}
  }

  /// Output only. When this Model is deployed, its prediction resources are
  /// described by the `prediction_resources` field of the
  /// [Endpoint.deployed_models][google.cloud.aiplatform.v1.Endpoint.deployed_models]
  /// object. Because not all Models support all resource configuration types,
  /// the configuration types this Model supports are listed here. If no
  /// configuration types are listed, the Model cannot be deployed to an
  /// [Endpoint][google.cloud.aiplatform.v1.Endpoint] and does not support
  /// online predictions
  /// ([PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
  /// or
  /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain]).
  /// Such a Model can serve predictions by using a
  /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob], if it
  /// has at least one entry each in
  /// [supported_input_storage_formats][google.cloud.aiplatform.v1.Model.supported_input_storage_formats]
  /// and
  /// [supported_output_storage_formats][google.cloud.aiplatform.v1.Model.supported_output_storage_formats].
  public var supportedDeploymentResourcesTypes: [Google_Cloud_Aiplatform_V1_Model.DeploymentResourcesType] {
    get {return _storage._supportedDeploymentResourcesTypes}
    set {_uniqueStorage()._supportedDeploymentResourcesTypes = newValue}
  }

  /// Output only. The formats this Model supports in
  /// [BatchPredictionJob.input_config][google.cloud.aiplatform.v1.BatchPredictionJob.input_config].
  /// If
  /// [PredictSchemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
  /// exists, the instances should be given as per that schema.
  ///
  /// The possible formats are:
  ///
  /// * `jsonl`
  /// The JSON Lines format, where each instance is a single line. Uses
  /// [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
  ///
  /// * `csv`
  /// The CSV format, where each instance is a single comma-separated line.
  /// The first line in the file is the header, containing comma-separated field
  /// names. Uses
  /// [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
  ///
  /// * `tf-record`
  /// The TFRecord format, where each instance is a single record in tfrecord
  /// syntax. Uses
  /// [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
  ///
  /// * `tf-record-gzip`
  /// Similar to `tf-record`, but the file is gzipped. Uses
  /// [GcsSource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.gcs_source].
  ///
  /// * `bigquery`
  /// Each instance is a single row in BigQuery. Uses
  /// [BigQuerySource][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig.bigquery_source].
  ///
  /// * `file-list`
  /// Each line of the file is the location of an instance to process, uses
  /// `gcs_source` field of the
  /// [InputConfig][google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig]
  /// object.
  ///
  ///
  /// If this Model doesn't support any of these formats it means it cannot be
  /// used with a
  /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
  /// However, if it has
  /// [supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types],
  /// it could serve online predictions by using
  /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
  /// or
  /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
  public var supportedInputStorageFormats: [String] {
    get {return _storage._supportedInputStorageFormats}
    set {_uniqueStorage()._supportedInputStorageFormats = newValue}
  }

  /// Output only. The formats this Model supports in
  /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
  /// If both
  /// [PredictSchemata.instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri]
  /// and
  /// [PredictSchemata.prediction_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.prediction_schema_uri]
  /// exist, the predictions are returned together with their instances. In other
  /// words, the prediction has the original instance data first, followed by the
  /// actual prediction content (as per the schema).
  ///
  /// The possible formats are:
  ///
  /// * `jsonl`
  /// The JSON Lines format, where each prediction is a single line. Uses
  /// [GcsDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination].
  ///
  /// * `csv`
  /// The CSV format, where each prediction is a single comma-separated line.
  /// The first line in the file is the header, containing comma-separated field
  /// names. Uses
  /// [GcsDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.gcs_destination].
  ///
  /// * `bigquery`
  /// Each prediction is a single row in a BigQuery table, uses
  /// [BigQueryDestination][google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig.bigquery_destination]
  /// .
  ///
  ///
  /// If this Model doesn't support any of these formats it means it cannot be
  /// used with a
  /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
  /// However, if it has
  /// [supported_deployment_resources_types][google.cloud.aiplatform.v1.Model.supported_deployment_resources_types],
  /// it could serve online predictions by using
  /// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict]
  /// or
  /// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain].
  public var supportedOutputStorageFormats: [String] {
    get {return _storage._supportedOutputStorageFormats}
    set {_uniqueStorage()._supportedOutputStorageFormats = newValue}
  }

  /// Output only. Timestamp when this Model was uploaded into Vertex AI.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Timestamp when this Model was most recently updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. The pointers to DeployedModels created from this Model. Note
  /// that Model could have been deployed to Endpoints in different Locations.
  public var deployedModels: [Google_Cloud_Aiplatform_V1_DeployedModelRef] {
    get {return _storage._deployedModels}
    set {_uniqueStorage()._deployedModels = newValue}
  }

  /// The default explanation specification for this Model.
  ///
  /// The Model can be used for
  /// [requesting
  /// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] after
  /// being [deployed][google.cloud.aiplatform.v1.EndpointService.DeployModel] if
  /// it is populated. The Model can be used for [batch
  /// explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
  /// if it is populated.
  ///
  /// All fields of the explanation_spec can be overridden by
  /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
  /// of
  /// [DeployModelRequest.deployed_model][google.cloud.aiplatform.v1.DeployModelRequest.deployed_model],
  /// or
  /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
  /// of [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
  ///
  /// If the default explanation specification is not set for this Model, this
  /// Model can still be used for
  /// [requesting
  /// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] by
  /// setting
  /// [explanation_spec][google.cloud.aiplatform.v1.DeployedModel.explanation_spec]
  /// of
  /// [DeployModelRequest.deployed_model][google.cloud.aiplatform.v1.DeployModelRequest.deployed_model]
  /// and for [batch
  /// explanation][google.cloud.aiplatform.v1.BatchPredictionJob.generate_explanation]
  /// by setting
  /// [explanation_spec][google.cloud.aiplatform.v1.BatchPredictionJob.explanation_spec]
  /// of [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
  public var explanationSpec: Google_Cloud_Aiplatform_V1_ExplanationSpec {
    get {return _storage._explanationSpec ?? Google_Cloud_Aiplatform_V1_ExplanationSpec()}
    set {_uniqueStorage()._explanationSpec = newValue}
  }
  /// Returns true if `explanationSpec` has been explicitly set.
  public var hasExplanationSpec: Bool {return _storage._explanationSpec != nil}
  /// Clears the value of `explanationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearExplanationSpec() {_uniqueStorage()._explanationSpec = nil}

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  public var etag: String {
    get {return _storage._etag}
    set {_uniqueStorage()._etag = newValue}
  }

  /// The labels with user-defined metadata to organize your Models.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Stats of data used for training or evaluating the Model.
  ///
  /// Only populated when the Model is trained by a TrainingPipeline with
  /// [data_input_config][TrainingPipeline.data_input_config].
  public var dataStats: Google_Cloud_Aiplatform_V1_Model.DataStats {
    get {return _storage._dataStats ?? Google_Cloud_Aiplatform_V1_Model.DataStats()}
    set {_uniqueStorage()._dataStats = newValue}
  }
  /// Returns true if `dataStats` has been explicitly set.
  public var hasDataStats: Bool {return _storage._dataStats != nil}
  /// Clears the value of `dataStats`. Subsequent reads from it will return its default value.
  public mutating func clearDataStats() {_uniqueStorage()._dataStats = nil}

  /// Customer-managed encryption key spec for a Model. If set, this
  /// Model and all sub-resources of this Model will be secured by this key.
  public var encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec {
    get {return _storage._encryptionSpec ?? Google_Cloud_Aiplatform_V1_EncryptionSpec()}
    set {_uniqueStorage()._encryptionSpec = newValue}
  }
  /// Returns true if `encryptionSpec` has been explicitly set.
  public var hasEncryptionSpec: Bool {return _storage._encryptionSpec != nil}
  /// Clears the value of `encryptionSpec`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptionSpec() {_uniqueStorage()._encryptionSpec = nil}

  /// Output only. Source of a model. It can either be automl training pipeline,
  /// custom training pipeline, BigQuery ML, or saved and tuned from Genie or
  /// Model Garden.
  public var modelSourceInfo: Google_Cloud_Aiplatform_V1_ModelSourceInfo {
    get {return _storage._modelSourceInfo ?? Google_Cloud_Aiplatform_V1_ModelSourceInfo()}
    set {_uniqueStorage()._modelSourceInfo = newValue}
  }
  /// Returns true if `modelSourceInfo` has been explicitly set.
  public var hasModelSourceInfo: Bool {return _storage._modelSourceInfo != nil}
  /// Clears the value of `modelSourceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearModelSourceInfo() {_uniqueStorage()._modelSourceInfo = nil}

  /// Output only. If this Model is a copy of another Model, this contains info
  /// about the original.
  public var originalModelInfo: Google_Cloud_Aiplatform_V1_Model.OriginalModelInfo {
    get {return _storage._originalModelInfo ?? Google_Cloud_Aiplatform_V1_Model.OriginalModelInfo()}
    set {_uniqueStorage()._originalModelInfo = newValue}
  }
  /// Returns true if `originalModelInfo` has been explicitly set.
  public var hasOriginalModelInfo: Bool {return _storage._originalModelInfo != nil}
  /// Clears the value of `originalModelInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalModelInfo() {_uniqueStorage()._originalModelInfo = nil}

  /// Output only. The resource name of the Artifact that was created in
  /// MetadataStore when creating the Model. The Artifact resource name pattern
  /// is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  public var metadataArtifact: String {
    get {return _storage._metadataArtifact}
    set {_uniqueStorage()._metadataArtifact = newValue}
  }

  /// Optional. User input field to specify the base model source. Currently it
  /// only supports specifing the Model Garden models and Genie models.
  public var baseModelSource: Google_Cloud_Aiplatform_V1_Model.BaseModelSource {
    get {return _storage._baseModelSource ?? Google_Cloud_Aiplatform_V1_Model.BaseModelSource()}
    set {_uniqueStorage()._baseModelSource = newValue}
  }
  /// Returns true if `baseModelSource` has been explicitly set.
  public var hasBaseModelSource: Bool {return _storage._baseModelSource != nil}
  /// Clears the value of `baseModelSource`. Subsequent reads from it will return its default value.
  public mutating func clearBaseModelSource() {_uniqueStorage()._baseModelSource = nil}

  /// Output only. Reserved for future use.
  public var satisfiesPzs: Bool {
    get {return _storage._satisfiesPzs}
    set {_uniqueStorage()._satisfiesPzs = newValue}
  }

  /// Output only. Reserved for future use.
  public var satisfiesPzi: Bool {
    get {return _storage._satisfiesPzi}
    set {_uniqueStorage()._satisfiesPzi = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Identifies a type of Model's prediction resources.
  public enum DeploymentResourcesType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Should not be used.
    case unspecified // = 0

    /// Resources that are dedicated to the
    /// [DeployedModel][google.cloud.aiplatform.v1.DeployedModel], and that need
    /// a higher degree of manual configuration.
    case dedicatedResources // = 1

    /// Resources that to large degree are decided by Vertex AI, and require
    /// only a modest additional configuration.
    case automaticResources // = 2

    /// Resources that can be shared by multiple
    /// [DeployedModels][google.cloud.aiplatform.v1.DeployedModel]. A
    /// pre-configured
    /// [DeploymentResourcePool][google.cloud.aiplatform.v1.DeploymentResourcePool]
    /// is required.
    case sharedResources // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .dedicatedResources
      case 2: self = .automaticResources
      case 3: self = .sharedResources
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .dedicatedResources: return 1
      case .automaticResources: return 2
      case .sharedResources: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Model.DeploymentResourcesType] = [
      .unspecified,
      .dedicatedResources,
      .automaticResources,
      .sharedResources,
    ]

  }

  /// Represents export format supported by the Model.
  /// All formats export to Google Cloud Storage.
  public struct ExportFormat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. The ID of the export format.
    /// The possible format IDs are:
    ///
    /// * `tflite`
    /// Used for Android mobile devices.
    ///
    /// * `edgetpu-tflite`
    /// Used for [Edge TPU](https://cloud.google.com/edge-tpu/) devices.
    ///
    /// * `tf-saved-model`
    /// A tensorflow model in SavedModel format.
    ///
    /// * `tf-js`
    /// A [TensorFlow.js](https://www.tensorflow.org/js) model that can be used
    /// in the browser and in Node.js using JavaScript.
    ///
    /// * `core-ml`
    /// Used for iOS mobile devices.
    ///
    /// * `custom-trained`
    /// A Model that was uploaded or trained by custom code.
    public var id: String = String()

    /// Output only. The content of this Model that may be exported.
    public var exportableContents: [Google_Cloud_Aiplatform_V1_Model.ExportFormat.ExportableContent] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The Model content that can be exported.
    public enum ExportableContent: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Should not be used.
      case unspecified // = 0

      /// Model artifact and any of its supported files. Will be exported to the
      /// location specified by the `artifactDestination` field of the
      /// [ExportModelRequest.output_config][google.cloud.aiplatform.v1.ExportModelRequest.output_config]
      /// object.
      case artifact // = 1

      /// The container image that is to be used when deploying this Model. Will
      /// be exported to the location specified by the `imageDestination` field
      /// of the
      /// [ExportModelRequest.output_config][google.cloud.aiplatform.v1.ExportModelRequest.output_config]
      /// object.
      case image // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .artifact
        case 2: self = .image
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .artifact: return 1
        case .image: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_Model.ExportFormat.ExportableContent] = [
        .unspecified,
        .artifact,
        .image,
      ]

    }

    public init() {}
  }

  /// Stats of data used for train or evaluate the Model.
  public struct DataStats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of DataItems that were used for training this Model.
    public var trainingDataItemsCount: Int64 = 0

    /// Number of DataItems that were used for validating this Model during
    /// training.
    public var validationDataItemsCount: Int64 = 0

    /// Number of DataItems that were used for evaluating this Model. If the
    /// Model is evaluated multiple times, this will be the number of test
    /// DataItems used by the first evaluation. If the Model is not evaluated,
    /// the number is 0.
    public var testDataItemsCount: Int64 = 0

    /// Number of Annotations that are used for training this Model.
    public var trainingAnnotationsCount: Int64 = 0

    /// Number of Annotations that are used for validating this Model during
    /// training.
    public var validationAnnotationsCount: Int64 = 0

    /// Number of Annotations that are used for evaluating this Model. If the
    /// Model is evaluated multiple times, this will be the number of test
    /// Annotations used by the first evaluation. If the Model is not evaluated,
    /// the number is 0.
    public var testAnnotationsCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Contains information about the original Model if this Model is a copy.
  public struct OriginalModelInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. The resource name of the Model this Model is a copy of,
    /// including the revision. Format:
    /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
    public var model: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// User input field to specify the base model source. Currently it only
  /// supports specifing the Model Garden models and Genie models.
  public struct BaseModelSource: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var source: Google_Cloud_Aiplatform_V1_Model.BaseModelSource.OneOf_Source? = nil

    /// Source information of Model Garden models.
    public var modelGardenSource: Google_Cloud_Aiplatform_V1_ModelGardenSource {
      get {
        if case .modelGardenSource(let v)? = source {return v}
        return Google_Cloud_Aiplatform_V1_ModelGardenSource()
      }
      set {source = .modelGardenSource(newValue)}
    }

    /// Information about the base model of Genie models.
    public var genieSource: Google_Cloud_Aiplatform_V1_GenieSource {
      get {
        if case .genieSource(let v)? = source {return v}
        return Google_Cloud_Aiplatform_V1_GenieSource()
      }
      set {source = .genieSource(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Source: Equatable, Sendable {
      /// Source information of Model Garden models.
      case modelGardenSource(Google_Cloud_Aiplatform_V1_ModelGardenSource)
      /// Information about the base model of Genie models.
      case genieSource(Google_Cloud_Aiplatform_V1_GenieSource)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Contains information about the Large Model.
public struct Google_Cloud_Aiplatform_V1_LargeModelReference: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the large Foundation or pre-built model. Like
  /// "chat-bison", "text-bison". Or model name with version ID, like
  /// "chat-bison@001", "text-bison@005", etc.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains information about the source of the models generated from Model
/// Garden.
public struct Google_Cloud_Aiplatform_V1_ModelGardenSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The model garden source model resource name.
  public var publicModelName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains information about the source of the models generated from Generative
/// AI Studio.
public struct Google_Cloud_Aiplatform_V1_GenieSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The public base model URI.
  public var baseModelUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains the schemata used in Model's predictions and explanations via
/// [PredictionService.Predict][google.cloud.aiplatform.v1.PredictionService.Predict],
/// [PredictionService.Explain][google.cloud.aiplatform.v1.PredictionService.Explain]
/// and [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob].
public struct Google_Cloud_Aiplatform_V1_PredictSchemata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the format of a single instance, which are used in
  /// [PredictRequest.instances][google.cloud.aiplatform.v1.PredictRequest.instances],
  /// [ExplainRequest.instances][google.cloud.aiplatform.v1.ExplainRequest.instances]
  /// and
  /// [BatchPredictionJob.input_config][google.cloud.aiplatform.v1.BatchPredictionJob.input_config].
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  public var instanceSchemaUri: String = String()

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the parameters of prediction and explanation via
  /// [PredictRequest.parameters][google.cloud.aiplatform.v1.PredictRequest.parameters],
  /// [ExplainRequest.parameters][google.cloud.aiplatform.v1.ExplainRequest.parameters]
  /// and
  /// [BatchPredictionJob.model_parameters][google.cloud.aiplatform.v1.BatchPredictionJob.model_parameters].
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// parameters are supported, then it is set to an empty string.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  public var parametersSchemaUri: String = String()

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the format of a single prediction produced by this Model, which are
  /// returned via
  /// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions],
  /// [ExplainResponse.explanations][google.cloud.aiplatform.v1.ExplainResponse.explanations],
  /// and
  /// [BatchPredictionJob.output_config][google.cloud.aiplatform.v1.BatchPredictionJob.output_config].
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  public var predictionSchemaUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specification of a container for serving predictions. Some fields in this
/// message correspond to fields in the [Kubernetes Container v1 core
/// specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
public struct Google_Cloud_Aiplatform_V1_ModelContainerSpec: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Immutable. URI of the Docker image to be used as the custom
  /// container for serving predictions. This URI must identify an image in
  /// Artifact Registry or Container Registry. Learn more about the [container
  /// publishing
  /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
  /// including permissions requirements for the Vertex AI Service Agent.
  ///
  /// The container image is ingested upon
  /// [ModelService.UploadModel][google.cloud.aiplatform.v1.ModelService.UploadModel],
  /// stored internally, and this original path is afterwards not used.
  ///
  /// To learn about the requirements for the Docker image itself, see
  /// [Custom container
  /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
  ///
  /// You can use the URI to one of Vertex AI's [pre-built container images for
  /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
  /// in this field.
  public var imageUri: String {
    get {return _storage._imageUri}
    set {_uniqueStorage()._imageUri = newValue}
  }

  /// Immutable. Specifies the command that runs when the container starts. This
  /// overrides the container's
  /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
  /// Specify this field as an array of executable and arguments, similar to a
  /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form.
  ///
  /// If you do not specify this field, then the container's `ENTRYPOINT` runs,
  /// in conjunction with the
  /// [args][google.cloud.aiplatform.v1.ModelContainerSpec.args] field or the
  /// container's [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd),
  /// if either exists. If this field is not specified and the container does not
  /// have an `ENTRYPOINT`, then refer to the Docker documentation about [how
  /// `CMD` and `ENTRYPOINT`
  /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  ///
  /// If you specify this field, then you can also specify the `args` field to
  /// provide additional arguments for this command. However, if you specify this
  /// field, then the container's `CMD` is ignored. See the
  /// [Kubernetes documentation about how the
  /// `command` and `args` fields interact with a container's `ENTRYPOINT` and
  /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  ///
  /// In this field, you can reference [environment variables set by Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the
  /// [env][google.cloud.aiplatform.v1.ModelContainerSpec.env] field. You cannot
  /// reference environment variables set in the Docker image. In order for
  /// environment variables to be expanded, reference them by using the following
  /// syntax: <code>$(<var>VARIABLE_NAME</var>)</code> Note that this differs
  /// from Bash variable expansion, which does not use parentheses. If a variable
  /// cannot be resolved, the reference in the input string is used unchanged. To
  /// avoid variable expansion, you can escape this syntax with `$$`; for
  /// example: <code>$$(<var>VARIABLE_NAME</var>)</code> This field corresponds
  /// to the `command` field of the Kubernetes Containers [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  public var command: [String] {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  /// Immutable. Specifies arguments for the command that runs when the container
  /// starts. This overrides the container's
  /// [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
  /// this field as an array of executable and arguments, similar to a Docker
  /// `CMD`'s "default parameters" form.
  ///
  /// If you don't specify this field but do specify the
  /// [command][google.cloud.aiplatform.v1.ModelContainerSpec.command] field,
  /// then the command from the `command` field runs without any additional
  /// arguments. See the [Kubernetes documentation about how the `command` and
  /// `args` fields interact with a container's `ENTRYPOINT` and
  /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  ///
  /// If you don't specify this field and don't specify the `command` field,
  /// then the container's
  /// [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
  /// `CMD` determine what runs based on their default behavior. See the Docker
  /// documentation about [how `CMD` and `ENTRYPOINT`
  /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  ///
  /// In this field, you can reference [environment variables
  /// set by Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the
  /// [env][google.cloud.aiplatform.v1.ModelContainerSpec.env] field. You cannot
  /// reference environment variables set in the Docker image. In order for
  /// environment variables to be expanded, reference them by using the following
  /// syntax: <code>$(<var>VARIABLE_NAME</var>)</code> Note that this differs
  /// from Bash variable expansion, which does not use parentheses. If a variable
  /// cannot be resolved, the reference in the input string is used unchanged. To
  /// avoid variable expansion, you can escape this syntax with `$$`; for
  /// example: <code>$$(<var>VARIABLE_NAME</var>)</code> This field corresponds
  /// to the `args` field of the Kubernetes Containers [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  public var args: [String] {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  /// Immutable. List of environment variables to set in the container. After the
  /// container starts running, code running in the container can read these
  /// environment variables.
  ///
  /// Additionally, the
  /// [command][google.cloud.aiplatform.v1.ModelContainerSpec.command] and
  /// [args][google.cloud.aiplatform.v1.ModelContainerSpec.args] fields can
  /// reference these variables. Later entries in this list can also reference
  /// earlier entries. For example, the following example sets the variable
  /// `VAR_2` to have the value `foo bar`:
  ///
  /// ```json
  /// [
  ///   {
  ///     "name": "VAR_1",
  ///     "value": "foo"
  ///   },
  ///   {
  ///     "name": "VAR_2",
  ///     "value": "$(VAR_1) bar"
  ///   }
  /// ]
  /// ```
  ///
  /// If you switch the order of the variables in the example, then the expansion
  /// does not occur.
  ///
  /// This field corresponds to the `env` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  public var env: [Google_Cloud_Aiplatform_V1_EnvVar] {
    get {return _storage._env}
    set {_uniqueStorage()._env = newValue}
  }

  /// Immutable. List of ports to expose from the container. Vertex AI sends any
  /// prediction requests that it receives to the first port on this list. Vertex
  /// AI also sends
  /// [liveness and health
  /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
  /// to this port.
  ///
  /// If you do not specify this field, it defaults to following value:
  ///
  /// ```json
  /// [
  ///   {
  ///     "containerPort": 8080
  ///   }
  /// ]
  /// ```
  ///
  /// Vertex AI does not use ports other than the first one listed. This field
  /// corresponds to the `ports` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  public var ports: [Google_Cloud_Aiplatform_V1_Port] {
    get {return _storage._ports}
    set {_uniqueStorage()._ports = newValue}
  }

  /// Immutable. HTTP path on the container to send prediction requests to.
  /// Vertex AI forwards requests sent using
  /// [projects.locations.endpoints.predict][google.cloud.aiplatform.v1.PredictionService.Predict]
  /// to this path on the container's IP address and port. Vertex AI then returns
  /// the container's response in the API response.
  ///
  /// For example, if you set this field to `/foo`, then when Vertex AI
  /// receives a prediction request, it forwards the request body in a POST
  /// request to the `/foo` path on the port of your container specified by the
  /// first value of this `ModelContainerSpec`'s
  /// [ports][google.cloud.aiplatform.v1.ModelContainerSpec.ports] field.
  ///
  /// If you don't specify this field, it defaults to the following value when
  /// you [deploy this Model to an
  /// Endpoint][google.cloud.aiplatform.v1.EndpointService.DeployModel]:
  /// <code>/v1/endpoints/<var>ENDPOINT</var>/deployedModels/<var>DEPLOYED_MODEL</var>:predict</code>
  /// The placeholders in this value are replaced as follows:
  ///
  /// * <var>ENDPOINT</var>: The last segment (following `endpoints/`)of the
  ///   Endpoint.name][] field of the Endpoint where this Model has been
  ///   deployed. (Vertex AI makes this value available to your container code
  ///   as the [`AIP_ENDPOINT_ID` environment
  ///  variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// * <var>DEPLOYED_MODEL</var>:
  /// [DeployedModel.id][google.cloud.aiplatform.v1.DeployedModel.id] of the
  /// `DeployedModel`.
  ///   (Vertex AI makes this value available to your container code
  ///   as the [`AIP_DEPLOYED_MODEL_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  public var predictRoute: String {
    get {return _storage._predictRoute}
    set {_uniqueStorage()._predictRoute = newValue}
  }

  /// Immutable. HTTP path on the container to send health checks to. Vertex AI
  /// intermittently sends GET requests to this path on the container's IP
  /// address and port to check that the container is healthy. Read more about
  /// [health
  /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
  ///
  /// For example, if you set this field to `/bar`, then Vertex AI
  /// intermittently sends a GET request to the `/bar` path on the port of your
  /// container specified by the first value of this `ModelContainerSpec`'s
  /// [ports][google.cloud.aiplatform.v1.ModelContainerSpec.ports] field.
  ///
  /// If you don't specify this field, it defaults to the following value when
  /// you [deploy this Model to an
  /// Endpoint][google.cloud.aiplatform.v1.EndpointService.DeployModel]:
  /// <code>/v1/endpoints/<var>ENDPOINT</var>/deployedModels/<var>DEPLOYED_MODEL</var>:predict</code>
  /// The placeholders in this value are replaced as follows:
  ///
  /// * <var>ENDPOINT</var>: The last segment (following `endpoints/`)of the
  ///   Endpoint.name][] field of the Endpoint where this Model has been
  ///   deployed. (Vertex AI makes this value available to your container code
  ///   as the [`AIP_ENDPOINT_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// * <var>DEPLOYED_MODEL</var>:
  /// [DeployedModel.id][google.cloud.aiplatform.v1.DeployedModel.id] of the
  /// `DeployedModel`.
  ///   (Vertex AI makes this value available to your container code as the
  ///   [`AIP_DEPLOYED_MODEL_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  public var healthRoute: String {
    get {return _storage._healthRoute}
    set {_uniqueStorage()._healthRoute = newValue}
  }

  /// Immutable. List of ports to expose from the container. Vertex AI sends gRPC
  /// prediction requests that it receives to the first port on this list. Vertex
  /// AI also sends liveness and health checks to this port.
  ///
  /// If you do not specify this field, gRPC requests to the container will be
  /// disabled.
  ///
  /// Vertex AI does not use ports other than the first one listed. This field
  /// corresponds to the `ports` field of the Kubernetes Containers v1 core API.
  public var grpcPorts: [Google_Cloud_Aiplatform_V1_Port] {
    get {return _storage._grpcPorts}
    set {_uniqueStorage()._grpcPorts = newValue}
  }

  /// Immutable. Deployment timeout.
  /// Limit for deployment timeout is 2 hours.
  public var deploymentTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._deploymentTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._deploymentTimeout = newValue}
  }
  /// Returns true if `deploymentTimeout` has been explicitly set.
  public var hasDeploymentTimeout: Bool {return _storage._deploymentTimeout != nil}
  /// Clears the value of `deploymentTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearDeploymentTimeout() {_uniqueStorage()._deploymentTimeout = nil}

  /// Immutable. The amount of the VM memory to reserve as the shared memory for
  /// the model in megabytes.
  public var sharedMemorySizeMb: Int64 {
    get {return _storage._sharedMemorySizeMb}
    set {_uniqueStorage()._sharedMemorySizeMb = newValue}
  }

  /// Immutable. Specification for Kubernetes startup probe.
  public var startupProbe: Google_Cloud_Aiplatform_V1_Probe {
    get {return _storage._startupProbe ?? Google_Cloud_Aiplatform_V1_Probe()}
    set {_uniqueStorage()._startupProbe = newValue}
  }
  /// Returns true if `startupProbe` has been explicitly set.
  public var hasStartupProbe: Bool {return _storage._startupProbe != nil}
  /// Clears the value of `startupProbe`. Subsequent reads from it will return its default value.
  public mutating func clearStartupProbe() {_uniqueStorage()._startupProbe = nil}

  /// Immutable. Specification for Kubernetes readiness probe.
  public var healthProbe: Google_Cloud_Aiplatform_V1_Probe {
    get {return _storage._healthProbe ?? Google_Cloud_Aiplatform_V1_Probe()}
    set {_uniqueStorage()._healthProbe = newValue}
  }
  /// Returns true if `healthProbe` has been explicitly set.
  public var hasHealthProbe: Bool {return _storage._healthProbe != nil}
  /// Clears the value of `healthProbe`. Subsequent reads from it will return its default value.
  public mutating func clearHealthProbe() {_uniqueStorage()._healthProbe = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a network port in a container.
public struct Google_Cloud_Aiplatform_V1_Port: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of the port to expose on the pod's IP address.
  /// Must be a valid port number, between 1 and 65535 inclusive.
  public var containerPort: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Detail description of the source information of the model.
public struct Google_Cloud_Aiplatform_V1_ModelSourceInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the model source.
  public var sourceType: Google_Cloud_Aiplatform_V1_ModelSourceInfo.ModelSourceType = .unspecified

  /// If this Model is copy of another Model. If true then
  /// [source_type][google.cloud.aiplatform.v1.ModelSourceInfo.source_type]
  /// pertains to the original.
  public var copy: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Source of the model.
  /// Different from `objective` field, this `ModelSourceType` enum
  /// indicates the source from which the model was accessed or obtained,
  /// whereas the `objective` indicates the overall aim or function of this
  /// model.
  public enum ModelSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Should not be used.
    case unspecified // = 0

    /// The Model is uploaded by automl training pipeline.
    case automl // = 1

    /// The Model is uploaded by user or custom training pipeline.
    case custom // = 2

    /// The Model is registered and sync'ed from BigQuery ML.
    case bqml // = 3

    /// The Model is saved or tuned from Model Garden.
    case modelGarden // = 4

    /// The Model is saved or tuned from Genie.
    case genie // = 5

    /// The Model is uploaded by text embedding finetuning pipeline.
    case customTextEmbedding // = 6

    /// The Model is saved or tuned from Marketplace.
    case marketplace // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .automl
      case 2: self = .custom
      case 3: self = .bqml
      case 4: self = .modelGarden
      case 5: self = .genie
      case 6: self = .customTextEmbedding
      case 7: self = .marketplace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .automl: return 1
      case .custom: return 2
      case .bqml: return 3
      case .modelGarden: return 4
      case .genie: return 5
      case .customTextEmbedding: return 6
      case .marketplace: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_ModelSourceInfo.ModelSourceType] = [
      .unspecified,
      .automl,
      .custom,
      .bqml,
      .modelGarden,
      .genie,
      .customTextEmbedding,
      .marketplace,
    ]

  }

  public init() {}
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
public struct Google_Cloud_Aiplatform_V1_Probe: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var probeType: Google_Cloud_Aiplatform_V1_Probe.OneOf_ProbeType? = nil

  /// ExecAction probes the health of a container by executing a command.
  public var exec: Google_Cloud_Aiplatform_V1_Probe.ExecAction {
    get {
      if case .exec(let v)? = probeType {return v}
      return Google_Cloud_Aiplatform_V1_Probe.ExecAction()
    }
    set {probeType = .exec(newValue)}
  }

  /// How often (in seconds) to perform the probe. Default to 10 seconds.
  /// Minimum value is 1. Must be less than timeout_seconds.
  ///
  /// Maps to Kubernetes probe argument 'periodSeconds'.
  public var periodSeconds: Int32 = 0

  /// Number of seconds after which the probe times out. Defaults to 1 second.
  /// Minimum value is 1. Must be greater or equal to period_seconds.
  ///
  /// Maps to Kubernetes probe argument 'timeoutSeconds'.
  public var timeoutSeconds: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ProbeType: Equatable, Sendable {
    /// ExecAction probes the health of a container by executing a command.
    case exec(Google_Cloud_Aiplatform_V1_Probe.ExecAction)

  }

  /// ExecAction specifies a command to execute.
  public struct ExecAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Command is the command line to execute inside the container, the working
    /// directory for the command is root ('/') in the container's filesystem.
    /// The command is simply exec'd, it is not run inside a shell, so
    /// traditional shell instructions ('|', etc) won't work. To use a shell, you
    /// need to explicitly call out to that shell. Exit status of 0 is treated as
    /// live/healthy and non-zero is unhealthy.
    public var command: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Model"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    28: .standard(proto: "version_id"),
    29: .standard(proto: "version_aliases"),
    31: .standard(proto: "version_create_time"),
    32: .standard(proto: "version_update_time"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    30: .standard(proto: "version_description"),
    4: .standard(proto: "predict_schemata"),
    5: .standard(proto: "metadata_schema_uri"),
    6: .same(proto: "metadata"),
    20: .standard(proto: "supported_export_formats"),
    7: .standard(proto: "training_pipeline"),
    47: .standard(proto: "pipeline_job"),
    9: .standard(proto: "container_spec"),
    26: .standard(proto: "artifact_uri"),
    10: .standard(proto: "supported_deployment_resources_types"),
    11: .standard(proto: "supported_input_storage_formats"),
    12: .standard(proto: "supported_output_storage_formats"),
    13: .standard(proto: "create_time"),
    14: .standard(proto: "update_time"),
    15: .standard(proto: "deployed_models"),
    23: .standard(proto: "explanation_spec"),
    16: .same(proto: "etag"),
    17: .same(proto: "labels"),
    21: .standard(proto: "data_stats"),
    24: .standard(proto: "encryption_spec"),
    38: .standard(proto: "model_source_info"),
    34: .standard(proto: "original_model_info"),
    44: .standard(proto: "metadata_artifact"),
    50: .standard(proto: "base_model_source"),
    51: .standard(proto: "satisfies_pzs"),
    52: .standard(proto: "satisfies_pzi"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _versionID: String = String()
    var _versionAliases: [String] = []
    var _versionCreateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _versionUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _displayName: String = String()
    var _description_p: String = String()
    var _versionDescription: String = String()
    var _predictSchemata: Google_Cloud_Aiplatform_V1_PredictSchemata? = nil
    var _metadataSchemaUri: String = String()
    var _metadata: SwiftProtobuf.Google_Protobuf_Value? = nil
    var _supportedExportFormats: [Google_Cloud_Aiplatform_V1_Model.ExportFormat] = []
    var _trainingPipeline: String = String()
    var _pipelineJob: String = String()
    var _containerSpec: Google_Cloud_Aiplatform_V1_ModelContainerSpec? = nil
    var _artifactUri: String = String()
    var _supportedDeploymentResourcesTypes: [Google_Cloud_Aiplatform_V1_Model.DeploymentResourcesType] = []
    var _supportedInputStorageFormats: [String] = []
    var _supportedOutputStorageFormats: [String] = []
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deployedModels: [Google_Cloud_Aiplatform_V1_DeployedModelRef] = []
    var _explanationSpec: Google_Cloud_Aiplatform_V1_ExplanationSpec? = nil
    var _etag: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _dataStats: Google_Cloud_Aiplatform_V1_Model.DataStats? = nil
    var _encryptionSpec: Google_Cloud_Aiplatform_V1_EncryptionSpec? = nil
    var _modelSourceInfo: Google_Cloud_Aiplatform_V1_ModelSourceInfo? = nil
    var _originalModelInfo: Google_Cloud_Aiplatform_V1_Model.OriginalModelInfo? = nil
    var _metadataArtifact: String = String()
    var _baseModelSource: Google_Cloud_Aiplatform_V1_Model.BaseModelSource? = nil
    var _satisfiesPzs: Bool = false
    var _satisfiesPzi: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _versionID = source._versionID
      _versionAliases = source._versionAliases
      _versionCreateTime = source._versionCreateTime
      _versionUpdateTime = source._versionUpdateTime
      _displayName = source._displayName
      _description_p = source._description_p
      _versionDescription = source._versionDescription
      _predictSchemata = source._predictSchemata
      _metadataSchemaUri = source._metadataSchemaUri
      _metadata = source._metadata
      _supportedExportFormats = source._supportedExportFormats
      _trainingPipeline = source._trainingPipeline
      _pipelineJob = source._pipelineJob
      _containerSpec = source._containerSpec
      _artifactUri = source._artifactUri
      _supportedDeploymentResourcesTypes = source._supportedDeploymentResourcesTypes
      _supportedInputStorageFormats = source._supportedInputStorageFormats
      _supportedOutputStorageFormats = source._supportedOutputStorageFormats
      _createTime = source._createTime
      _updateTime = source._updateTime
      _deployedModels = source._deployedModels
      _explanationSpec = source._explanationSpec
      _etag = source._etag
      _labels = source._labels
      _dataStats = source._dataStats
      _encryptionSpec = source._encryptionSpec
      _modelSourceInfo = source._modelSourceInfo
      _originalModelInfo = source._originalModelInfo
      _metadataArtifact = source._metadataArtifact
      _baseModelSource = source._baseModelSource
      _satisfiesPzs = source._satisfiesPzs
      _satisfiesPzi = source._satisfiesPzi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._predictSchemata) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._metadataSchemaUri) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._trainingPipeline) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._containerSpec) }()
        case 10: try { try decoder.decodeRepeatedEnumField(value: &_storage._supportedDeploymentResourcesTypes) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._supportedInputStorageFormats) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._supportedOutputStorageFormats) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._deployedModels) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._etag) }()
        case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._supportedExportFormats) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._dataStats) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._explanationSpec) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._encryptionSpec) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._artifactUri) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._versionID) }()
        case 29: try { try decoder.decodeRepeatedStringField(value: &_storage._versionAliases) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._versionDescription) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._versionCreateTime) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._versionUpdateTime) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._originalModelInfo) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._modelSourceInfo) }()
        case 44: try { try decoder.decodeSingularStringField(value: &_storage._metadataArtifact) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._pipelineJob) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._baseModelSource) }()
        case 51: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzs) }()
        case 52: try { try decoder.decodeSingularBoolField(value: &_storage._satisfiesPzi) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      try { if let v = _storage._predictSchemata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._metadataSchemaUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadataSchemaUri, fieldNumber: 5)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._trainingPipeline.isEmpty {
        try visitor.visitSingularStringField(value: _storage._trainingPipeline, fieldNumber: 7)
      }
      try { if let v = _storage._containerSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._supportedDeploymentResourcesTypes.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._supportedDeploymentResourcesTypes, fieldNumber: 10)
      }
      if !_storage._supportedInputStorageFormats.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedInputStorageFormats, fieldNumber: 11)
      }
      if !_storage._supportedOutputStorageFormats.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedOutputStorageFormats, fieldNumber: 12)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._deployedModels.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deployedModels, fieldNumber: 15)
      }
      if !_storage._etag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._etag, fieldNumber: 16)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 17)
      }
      if !_storage._supportedExportFormats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._supportedExportFormats, fieldNumber: 20)
      }
      try { if let v = _storage._dataStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._explanationSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._encryptionSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if !_storage._artifactUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._artifactUri, fieldNumber: 26)
      }
      if !_storage._versionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionID, fieldNumber: 28)
      }
      if !_storage._versionAliases.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._versionAliases, fieldNumber: 29)
      }
      if !_storage._versionDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionDescription, fieldNumber: 30)
      }
      try { if let v = _storage._versionCreateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._versionUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._originalModelInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._modelSourceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      if !_storage._metadataArtifact.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadataArtifact, fieldNumber: 44)
      }
      if !_storage._pipelineJob.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pipelineJob, fieldNumber: 47)
      }
      try { if let v = _storage._baseModelSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
      if _storage._satisfiesPzs != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzs, fieldNumber: 51)
      }
      if _storage._satisfiesPzi != false {
        try visitor.visitSingularBoolField(value: _storage._satisfiesPzi, fieldNumber: 52)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Model, rhs: Google_Cloud_Aiplatform_V1_Model) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._versionID != rhs_storage._versionID {return false}
        if _storage._versionAliases != rhs_storage._versionAliases {return false}
        if _storage._versionCreateTime != rhs_storage._versionCreateTime {return false}
        if _storage._versionUpdateTime != rhs_storage._versionUpdateTime {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._versionDescription != rhs_storage._versionDescription {return false}
        if _storage._predictSchemata != rhs_storage._predictSchemata {return false}
        if _storage._metadataSchemaUri != rhs_storage._metadataSchemaUri {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._supportedExportFormats != rhs_storage._supportedExportFormats {return false}
        if _storage._trainingPipeline != rhs_storage._trainingPipeline {return false}
        if _storage._pipelineJob != rhs_storage._pipelineJob {return false}
        if _storage._containerSpec != rhs_storage._containerSpec {return false}
        if _storage._artifactUri != rhs_storage._artifactUri {return false}
        if _storage._supportedDeploymentResourcesTypes != rhs_storage._supportedDeploymentResourcesTypes {return false}
        if _storage._supportedInputStorageFormats != rhs_storage._supportedInputStorageFormats {return false}
        if _storage._supportedOutputStorageFormats != rhs_storage._supportedOutputStorageFormats {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._deployedModels != rhs_storage._deployedModels {return false}
        if _storage._explanationSpec != rhs_storage._explanationSpec {return false}
        if _storage._etag != rhs_storage._etag {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._dataStats != rhs_storage._dataStats {return false}
        if _storage._encryptionSpec != rhs_storage._encryptionSpec {return false}
        if _storage._modelSourceInfo != rhs_storage._modelSourceInfo {return false}
        if _storage._originalModelInfo != rhs_storage._originalModelInfo {return false}
        if _storage._metadataArtifact != rhs_storage._metadataArtifact {return false}
        if _storage._baseModelSource != rhs_storage._baseModelSource {return false}
        if _storage._satisfiesPzs != rhs_storage._satisfiesPzs {return false}
        if _storage._satisfiesPzi != rhs_storage._satisfiesPzi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Model.DeploymentResourcesType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED"),
    1: .same(proto: "DEDICATED_RESOURCES"),
    2: .same(proto: "AUTOMATIC_RESOURCES"),
    3: .same(proto: "SHARED_RESOURCES"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Model.ExportFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Model.protoMessageName + ".ExportFormat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "exportable_contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.exportableContents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.exportableContents.isEmpty {
      try visitor.visitPackedEnumField(value: self.exportableContents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Model.ExportFormat, rhs: Google_Cloud_Aiplatform_V1_Model.ExportFormat) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.exportableContents != rhs.exportableContents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Model.ExportFormat.ExportableContent: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPORTABLE_CONTENT_UNSPECIFIED"),
    1: .same(proto: "ARTIFACT"),
    2: .same(proto: "IMAGE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Model.DataStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Model.protoMessageName + ".DataStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "training_data_items_count"),
    2: .standard(proto: "validation_data_items_count"),
    3: .standard(proto: "test_data_items_count"),
    4: .standard(proto: "training_annotations_count"),
    5: .standard(proto: "validation_annotations_count"),
    6: .standard(proto: "test_annotations_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.trainingDataItemsCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.validationDataItemsCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.testDataItemsCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.trainingAnnotationsCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.validationAnnotationsCount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.testAnnotationsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.trainingDataItemsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.trainingDataItemsCount, fieldNumber: 1)
    }
    if self.validationDataItemsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.validationDataItemsCount, fieldNumber: 2)
    }
    if self.testDataItemsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.testDataItemsCount, fieldNumber: 3)
    }
    if self.trainingAnnotationsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.trainingAnnotationsCount, fieldNumber: 4)
    }
    if self.validationAnnotationsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.validationAnnotationsCount, fieldNumber: 5)
    }
    if self.testAnnotationsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.testAnnotationsCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Model.DataStats, rhs: Google_Cloud_Aiplatform_V1_Model.DataStats) -> Bool {
    if lhs.trainingDataItemsCount != rhs.trainingDataItemsCount {return false}
    if lhs.validationDataItemsCount != rhs.validationDataItemsCount {return false}
    if lhs.testDataItemsCount != rhs.testDataItemsCount {return false}
    if lhs.trainingAnnotationsCount != rhs.trainingAnnotationsCount {return false}
    if lhs.validationAnnotationsCount != rhs.validationAnnotationsCount {return false}
    if lhs.testAnnotationsCount != rhs.testAnnotationsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Model.OriginalModelInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Model.protoMessageName + ".OriginalModelInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.model) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Model.OriginalModelInfo, rhs: Google_Cloud_Aiplatform_V1_Model.OriginalModelInfo) -> Bool {
    if lhs.model != rhs.model {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Model.BaseModelSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Model.protoMessageName + ".BaseModelSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_garden_source"),
    2: .standard(proto: "genie_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_ModelGardenSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .modelGardenSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .modelGardenSource(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_GenieSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .genieSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .genieSource(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.source {
    case .modelGardenSource?: try {
      guard case .modelGardenSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .genieSource?: try {
      guard case .genieSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Model.BaseModelSource, rhs: Google_Cloud_Aiplatform_V1_Model.BaseModelSource) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_LargeModelReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LargeModelReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_LargeModelReference, rhs: Google_Cloud_Aiplatform_V1_LargeModelReference) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelGardenSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelGardenSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_model_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicModelName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicModelName.isEmpty {
      try visitor.visitSingularStringField(value: self.publicModelName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelGardenSource, rhs: Google_Cloud_Aiplatform_V1_ModelGardenSource) -> Bool {
    if lhs.publicModelName != rhs.publicModelName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_GenieSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenieSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_model_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseModelUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseModelUri.isEmpty {
      try visitor.visitSingularStringField(value: self.baseModelUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_GenieSource, rhs: Google_Cloud_Aiplatform_V1_GenieSource) -> Bool {
    if lhs.baseModelUri != rhs.baseModelUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_PredictSchemata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredictSchemata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_schema_uri"),
    2: .standard(proto: "parameters_schema_uri"),
    3: .standard(proto: "prediction_schema_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceSchemaUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parametersSchemaUri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.predictionSchemaUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceSchemaUri.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceSchemaUri, fieldNumber: 1)
    }
    if !self.parametersSchemaUri.isEmpty {
      try visitor.visitSingularStringField(value: self.parametersSchemaUri, fieldNumber: 2)
    }
    if !self.predictionSchemaUri.isEmpty {
      try visitor.visitSingularStringField(value: self.predictionSchemaUri, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_PredictSchemata, rhs: Google_Cloud_Aiplatform_V1_PredictSchemata) -> Bool {
    if lhs.instanceSchemaUri != rhs.instanceSchemaUri {return false}
    if lhs.parametersSchemaUri != rhs.parametersSchemaUri {return false}
    if lhs.predictionSchemaUri != rhs.predictionSchemaUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelContainerSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelContainerSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_uri"),
    2: .same(proto: "command"),
    3: .same(proto: "args"),
    4: .same(proto: "env"),
    5: .same(proto: "ports"),
    6: .standard(proto: "predict_route"),
    7: .standard(proto: "health_route"),
    9: .standard(proto: "grpc_ports"),
    10: .standard(proto: "deployment_timeout"),
    11: .standard(proto: "shared_memory_size_mb"),
    12: .standard(proto: "startup_probe"),
    13: .standard(proto: "health_probe"),
  ]

  fileprivate class _StorageClass {
    var _imageUri: String = String()
    var _command: [String] = []
    var _args: [String] = []
    var _env: [Google_Cloud_Aiplatform_V1_EnvVar] = []
    var _ports: [Google_Cloud_Aiplatform_V1_Port] = []
    var _predictRoute: String = String()
    var _healthRoute: String = String()
    var _grpcPorts: [Google_Cloud_Aiplatform_V1_Port] = []
    var _deploymentTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _sharedMemorySizeMb: Int64 = 0
    var _startupProbe: Google_Cloud_Aiplatform_V1_Probe? = nil
    var _healthProbe: Google_Cloud_Aiplatform_V1_Probe? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _imageUri = source._imageUri
      _command = source._command
      _args = source._args
      _env = source._env
      _ports = source._ports
      _predictRoute = source._predictRoute
      _healthRoute = source._healthRoute
      _grpcPorts = source._grpcPorts
      _deploymentTimeout = source._deploymentTimeout
      _sharedMemorySizeMb = source._sharedMemorySizeMb
      _startupProbe = source._startupProbe
      _healthProbe = source._healthProbe
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._imageUri) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._command) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._args) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._env) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._ports) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._predictRoute) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._healthRoute) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._grpcPorts) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentTimeout) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._sharedMemorySizeMb) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._startupProbe) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._healthProbe) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._imageUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageUri, fieldNumber: 1)
      }
      if !_storage._command.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._command, fieldNumber: 2)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._args, fieldNumber: 3)
      }
      if !_storage._env.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._env, fieldNumber: 4)
      }
      if !_storage._ports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ports, fieldNumber: 5)
      }
      if !_storage._predictRoute.isEmpty {
        try visitor.visitSingularStringField(value: _storage._predictRoute, fieldNumber: 6)
      }
      if !_storage._healthRoute.isEmpty {
        try visitor.visitSingularStringField(value: _storage._healthRoute, fieldNumber: 7)
      }
      if !_storage._grpcPorts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._grpcPorts, fieldNumber: 9)
      }
      try { if let v = _storage._deploymentTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._sharedMemorySizeMb != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sharedMemorySizeMb, fieldNumber: 11)
      }
      try { if let v = _storage._startupProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._healthProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelContainerSpec, rhs: Google_Cloud_Aiplatform_V1_ModelContainerSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._imageUri != rhs_storage._imageUri {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._env != rhs_storage._env {return false}
        if _storage._ports != rhs_storage._ports {return false}
        if _storage._predictRoute != rhs_storage._predictRoute {return false}
        if _storage._healthRoute != rhs_storage._healthRoute {return false}
        if _storage._grpcPorts != rhs_storage._grpcPorts {return false}
        if _storage._deploymentTimeout != rhs_storage._deploymentTimeout {return false}
        if _storage._sharedMemorySizeMb != rhs_storage._sharedMemorySizeMb {return false}
        if _storage._startupProbe != rhs_storage._startupProbe {return false}
        if _storage._healthProbe != rhs_storage._healthProbe {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Port: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Port"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "container_port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.containerPort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.containerPort != 0 {
      try visitor.visitSingularInt32Field(value: self.containerPort, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Port, rhs: Google_Cloud_Aiplatform_V1_Port) -> Bool {
    if lhs.containerPort != rhs.containerPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelSourceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelSourceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_type"),
    2: .same(proto: "copy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sourceType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.copy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceType != .unspecified {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 1)
    }
    if self.copy != false {
      try visitor.visitSingularBoolField(value: self.copy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelSourceInfo, rhs: Google_Cloud_Aiplatform_V1_ModelSourceInfo) -> Bool {
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.copy != rhs.copy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelSourceInfo.ModelSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODEL_SOURCE_TYPE_UNSPECIFIED"),
    1: .same(proto: "AUTOML"),
    2: .same(proto: "CUSTOM"),
    3: .same(proto: "BQML"),
    4: .same(proto: "MODEL_GARDEN"),
    5: .same(proto: "GENIE"),
    6: .same(proto: "CUSTOM_TEXT_EMBEDDING"),
    7: .same(proto: "MARKETPLACE"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Probe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Probe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exec"),
    2: .standard(proto: "period_seconds"),
    3: .standard(proto: "timeout_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_Probe.ExecAction?
        var hadOneofValue = false
        if let current = self.probeType {
          hadOneofValue = true
          if case .exec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.probeType = .exec(v)
        }
      }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.periodSeconds) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeoutSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .exec(let v)? = self.probeType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.periodSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.periodSeconds, fieldNumber: 2)
    }
    if self.timeoutSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Probe, rhs: Google_Cloud_Aiplatform_V1_Probe) -> Bool {
    if lhs.probeType != rhs.probeType {return false}
    if lhs.periodSeconds != rhs.periodSeconds {return false}
    if lhs.timeoutSeconds != rhs.timeoutSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Probe.ExecAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Probe.protoMessageName + ".ExecAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitRepeatedStringField(value: self.command, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Probe.ExecAction, rhs: Google_Cloud_Aiplatform_V1_Probe.ExecAction) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
