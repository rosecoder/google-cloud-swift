// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/model_monitoring.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
public struct Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Training dataset for models. This field has to be set only if
  /// TrainingPredictionSkewDetectionConfig is specified.
  public var trainingDataset: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingDataset {
    get {return _trainingDataset ?? Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingDataset()}
    set {_trainingDataset = newValue}
  }
  /// Returns true if `trainingDataset` has been explicitly set.
  public var hasTrainingDataset: Bool {return self._trainingDataset != nil}
  /// Clears the value of `trainingDataset`. Subsequent reads from it will return its default value.
  public mutating func clearTrainingDataset() {self._trainingDataset = nil}

  /// The config for skew between training data and prediction data.
  public var trainingPredictionSkewDetectionConfig: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig {
    get {return _trainingPredictionSkewDetectionConfig ?? Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig()}
    set {_trainingPredictionSkewDetectionConfig = newValue}
  }
  /// Returns true if `trainingPredictionSkewDetectionConfig` has been explicitly set.
  public var hasTrainingPredictionSkewDetectionConfig: Bool {return self._trainingPredictionSkewDetectionConfig != nil}
  /// Clears the value of `trainingPredictionSkewDetectionConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTrainingPredictionSkewDetectionConfig() {self._trainingPredictionSkewDetectionConfig = nil}

  /// The config for drift of prediction data.
  public var predictionDriftDetectionConfig: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig {
    get {return _predictionDriftDetectionConfig ?? Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig()}
    set {_predictionDriftDetectionConfig = newValue}
  }
  /// Returns true if `predictionDriftDetectionConfig` has been explicitly set.
  public var hasPredictionDriftDetectionConfig: Bool {return self._predictionDriftDetectionConfig != nil}
  /// Clears the value of `predictionDriftDetectionConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPredictionDriftDetectionConfig() {self._predictionDriftDetectionConfig = nil}

  /// The config for integrating with Vertex Explainable AI.
  public var explanationConfig: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig {
    get {return _explanationConfig ?? Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig()}
    set {_explanationConfig = newValue}
  }
  /// Returns true if `explanationConfig` has been explicitly set.
  public var hasExplanationConfig: Bool {return self._explanationConfig != nil}
  /// Clears the value of `explanationConfig`. Subsequent reads from it will return its default value.
  public mutating func clearExplanationConfig() {self._explanationConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Training Dataset information.
  public struct TrainingDataset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var dataSource: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingDataset.OneOf_DataSource? = nil

    /// The resource name of the Dataset used to train this Model.
    public var dataset: String {
      get {
        if case .dataset(let v)? = dataSource {return v}
        return String()
      }
      set {dataSource = .dataset(newValue)}
    }

    /// The Google Cloud Storage uri of the unmanaged Dataset used to train
    /// this Model.
    public var gcsSource: Google_Cloud_Aiplatform_V1_GcsSource {
      get {
        if case .gcsSource(let v)? = dataSource {return v}
        return Google_Cloud_Aiplatform_V1_GcsSource()
      }
      set {dataSource = .gcsSource(newValue)}
    }

    /// The BigQuery table of the unmanaged Dataset used to train this
    /// Model.
    public var bigquerySource: Google_Cloud_Aiplatform_V1_BigQuerySource {
      get {
        if case .bigquerySource(let v)? = dataSource {return v}
        return Google_Cloud_Aiplatform_V1_BigQuerySource()
      }
      set {dataSource = .bigquerySource(newValue)}
    }

    /// Data format of the dataset, only applicable if the input is from
    /// Google Cloud Storage.
    /// The possible formats are:
    ///
    /// "tf-record"
    /// The source file is a TFRecord file.
    ///
    /// "csv"
    /// The source file is a CSV file.
    /// "jsonl"
    /// The source file is a JSONL file.
    public var dataFormat: String = String()

    /// The target field name the model is to predict.
    /// This field will be excluded when doing Predict and (or) Explain for the
    /// training data.
    public var targetField: String = String()

    /// Strategy to sample data from Training Dataset.
    /// If not set, we process the whole dataset.
    public var loggingSamplingStrategy: Google_Cloud_Aiplatform_V1_SamplingStrategy {
      get {return _loggingSamplingStrategy ?? Google_Cloud_Aiplatform_V1_SamplingStrategy()}
      set {_loggingSamplingStrategy = newValue}
    }
    /// Returns true if `loggingSamplingStrategy` has been explicitly set.
    public var hasLoggingSamplingStrategy: Bool {return self._loggingSamplingStrategy != nil}
    /// Clears the value of `loggingSamplingStrategy`. Subsequent reads from it will return its default value.
    public mutating func clearLoggingSamplingStrategy() {self._loggingSamplingStrategy = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_DataSource: Equatable, Sendable {
      /// The resource name of the Dataset used to train this Model.
      case dataset(String)
      /// The Google Cloud Storage uri of the unmanaged Dataset used to train
      /// this Model.
      case gcsSource(Google_Cloud_Aiplatform_V1_GcsSource)
      /// The BigQuery table of the unmanaged Dataset used to train this
      /// Model.
      case bigquerySource(Google_Cloud_Aiplatform_V1_BigQuerySource)

    }

    public init() {}

    fileprivate var _loggingSamplingStrategy: Google_Cloud_Aiplatform_V1_SamplingStrategy? = nil
  }

  /// The config for Training & Prediction data skew detection. It specifies the
  /// training dataset sources and the skew detection parameters.
  public struct TrainingPredictionSkewDetectionConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Key is the feature name and value is the threshold. If a feature needs to
    /// be monitored for skew, a value threshold must be configured for that
    /// feature. The threshold here is against feature distribution distance
    /// between the training and prediction feature.
    public var skewThresholds: Dictionary<String,Google_Cloud_Aiplatform_V1_ThresholdConfig> = [:]

    /// Key is the feature name and value is the threshold. The threshold here is
    /// against attribution score distance between the training and prediction
    /// feature.
    public var attributionScoreSkewThresholds: Dictionary<String,Google_Cloud_Aiplatform_V1_ThresholdConfig> = [:]

    /// Skew anomaly detection threshold used by all features.
    /// When the per-feature thresholds are not set, this field can be used to
    /// specify a threshold for all features.
    public var defaultSkewThreshold: Google_Cloud_Aiplatform_V1_ThresholdConfig {
      get {return _defaultSkewThreshold ?? Google_Cloud_Aiplatform_V1_ThresholdConfig()}
      set {_defaultSkewThreshold = newValue}
    }
    /// Returns true if `defaultSkewThreshold` has been explicitly set.
    public var hasDefaultSkewThreshold: Bool {return self._defaultSkewThreshold != nil}
    /// Clears the value of `defaultSkewThreshold`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultSkewThreshold() {self._defaultSkewThreshold = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _defaultSkewThreshold: Google_Cloud_Aiplatform_V1_ThresholdConfig? = nil
  }

  /// The config for Prediction data drift detection.
  public struct PredictionDriftDetectionConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Key is the feature name and value is the threshold. If a feature needs to
    /// be monitored for drift, a value threshold must be configured for that
    /// feature. The threshold here is against feature distribution distance
    /// between different time windws.
    public var driftThresholds: Dictionary<String,Google_Cloud_Aiplatform_V1_ThresholdConfig> = [:]

    /// Key is the feature name and value is the threshold. The threshold here is
    /// against attribution score distance between different time windows.
    public var attributionScoreDriftThresholds: Dictionary<String,Google_Cloud_Aiplatform_V1_ThresholdConfig> = [:]

    /// Drift anomaly detection threshold used by all features.
    /// When the per-feature thresholds are not set, this field can be used to
    /// specify a threshold for all features.
    public var defaultDriftThreshold: Google_Cloud_Aiplatform_V1_ThresholdConfig {
      get {return _defaultDriftThreshold ?? Google_Cloud_Aiplatform_V1_ThresholdConfig()}
      set {_defaultDriftThreshold = newValue}
    }
    /// Returns true if `defaultDriftThreshold` has been explicitly set.
    public var hasDefaultDriftThreshold: Bool {return self._defaultDriftThreshold != nil}
    /// Clears the value of `defaultDriftThreshold`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultDriftThreshold() {self._defaultDriftThreshold = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _defaultDriftThreshold: Google_Cloud_Aiplatform_V1_ThresholdConfig? = nil
  }

  /// The config for integrating with Vertex Explainable AI. Only applicable if
  /// the Model has explanation_spec populated.
  public struct ExplanationConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If want to analyze the Vertex Explainable AI feature attribute scores or
    /// not. If set to true, Vertex AI will log the feature attributions from
    /// explain response and do the skew/drift detection for them.
    public var enableFeatureAttributes: Bool = false

    /// Predictions generated by the BatchPredictionJob using baseline dataset.
    public var explanationBaseline: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline {
      get {return _explanationBaseline ?? Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline()}
      set {_explanationBaseline = newValue}
    }
    /// Returns true if `explanationBaseline` has been explicitly set.
    public var hasExplanationBaseline: Bool {return self._explanationBaseline != nil}
    /// Clears the value of `explanationBaseline`. Subsequent reads from it will return its default value.
    public mutating func clearExplanationBaseline() {self._explanationBaseline = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Output from
    /// [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob] for
    /// Model Monitoring baseline dataset, which can be used to generate baseline
    /// attribution scores.
    public struct ExplanationBaseline: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The configuration specifying of BatchExplain job output. This can be
      /// used to generate the baseline of feature attribution scores.
      public var destination: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline.OneOf_Destination? = nil

      /// Cloud Storage location for BatchExplain output.
      public var gcs: Google_Cloud_Aiplatform_V1_GcsDestination {
        get {
          if case .gcs(let v)? = destination {return v}
          return Google_Cloud_Aiplatform_V1_GcsDestination()
        }
        set {destination = .gcs(newValue)}
      }

      /// BigQuery location for BatchExplain output.
      public var bigquery: Google_Cloud_Aiplatform_V1_BigQueryDestination {
        get {
          if case .bigquery(let v)? = destination {return v}
          return Google_Cloud_Aiplatform_V1_BigQueryDestination()
        }
        set {destination = .bigquery(newValue)}
      }

      /// The storage format of the predictions generated BatchPrediction job.
      public var predictionFormat: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline.PredictionFormat = .unspecified

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The configuration specifying of BatchExplain job output. This can be
      /// used to generate the baseline of feature attribution scores.
      public enum OneOf_Destination: Equatable, Sendable {
        /// Cloud Storage location for BatchExplain output.
        case gcs(Google_Cloud_Aiplatform_V1_GcsDestination)
        /// BigQuery location for BatchExplain output.
        case bigquery(Google_Cloud_Aiplatform_V1_BigQueryDestination)

      }

      /// The storage format of the predictions generated BatchPrediction job.
      public enum PredictionFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Should not be set.
        case unspecified // = 0

        /// Predictions are in JSONL files.
        case jsonl // = 2

        /// Predictions are in BigQuery.
        case bigquery // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecified
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 2: self = .jsonl
          case 3: self = .bigquery
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .jsonl: return 2
          case .bigquery: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline.PredictionFormat] = [
          .unspecified,
          .jsonl,
          .bigquery,
        ]

      }

      public init() {}
    }

    public init() {}

    fileprivate var _explanationBaseline: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline? = nil
  }

  public init() {}

  fileprivate var _trainingDataset: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingDataset? = nil
  fileprivate var _trainingPredictionSkewDetectionConfig: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig? = nil
  fileprivate var _predictionDriftDetectionConfig: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig? = nil
  fileprivate var _explanationConfig: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig? = nil
}

/// The alert config for model monitoring.
public struct Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alert: Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.OneOf_Alert? = nil

  /// Email alert config.
  public var emailAlertConfig: Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.EmailAlertConfig {
    get {
      if case .emailAlertConfig(let v)? = alert {return v}
      return Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.EmailAlertConfig()
    }
    set {alert = .emailAlertConfig(newValue)}
  }

  /// Dump the anomalies to Cloud Logging. The anomalies will be put to json
  /// payload encoded from proto
  /// [google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry][].
  /// This can be further sinked to Pub/Sub or any other services supported
  /// by Cloud Logging.
  public var enableLogging: Bool = false

  /// Resource names of the NotificationChannels to send alert.
  /// Must be of the format
  /// `projects/<project_id_or_number>/notificationChannels/<channel_id>`
  public var notificationChannels: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Alert: Equatable, Sendable {
    /// Email alert config.
    case emailAlertConfig(Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.EmailAlertConfig)

  }

  /// The config for email alert.
  public struct EmailAlertConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The email addresses to send the alert.
    public var userEmails: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// The config for feature monitoring threshold.
public struct Google_Cloud_Aiplatform_V1_ThresholdConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threshold: Google_Cloud_Aiplatform_V1_ThresholdConfig.OneOf_Threshold? = nil

  /// Specify a threshold value that can trigger the alert.
  /// If this threshold config is for feature distribution distance:
  ///   1. For categorical feature, the distribution distance is calculated by
  ///      L-inifinity norm.
  ///   2. For numerical feature, the distribution distance is calculated by
  ///      Jensen–Shannon divergence.
  /// Each feature must have a non-zero threshold if they need to be monitored.
  /// Otherwise no alert will be triggered for that feature.
  public var value: Double {
    get {
      if case .value(let v)? = threshold {return v}
      return 0
    }
    set {threshold = .value(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Threshold: Equatable, Sendable {
    /// Specify a threshold value that can trigger the alert.
    /// If this threshold config is for feature distribution distance:
    ///   1. For categorical feature, the distribution distance is calculated by
    ///      L-inifinity norm.
    ///   2. For numerical feature, the distribution distance is calculated by
    ///      Jensen–Shannon divergence.
    /// Each feature must have a non-zero threshold if they need to be monitored.
    /// Otherwise no alert will be triggered for that feature.
    case value(Double)

  }

  public init() {}
}

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
public struct Google_Cloud_Aiplatform_V1_SamplingStrategy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random sample config. Will support more sampling strategies later.
  public var randomSampleConfig: Google_Cloud_Aiplatform_V1_SamplingStrategy.RandomSampleConfig {
    get {return _randomSampleConfig ?? Google_Cloud_Aiplatform_V1_SamplingStrategy.RandomSampleConfig()}
    set {_randomSampleConfig = newValue}
  }
  /// Returns true if `randomSampleConfig` has been explicitly set.
  public var hasRandomSampleConfig: Bool {return self._randomSampleConfig != nil}
  /// Clears the value of `randomSampleConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRandomSampleConfig() {self._randomSampleConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Requests are randomly selected.
  public struct RandomSampleConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Sample rate (0, 1]
    public var sampleRate: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _randomSampleConfig: Google_Cloud_Aiplatform_V1_SamplingStrategy.RandomSampleConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelMonitoringObjectiveConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "training_dataset"),
    2: .standard(proto: "training_prediction_skew_detection_config"),
    3: .standard(proto: "prediction_drift_detection_config"),
    5: .standard(proto: "explanation_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trainingDataset) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._trainingPredictionSkewDetectionConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._predictionDriftDetectionConfig) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._explanationConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._trainingDataset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._trainingPredictionSkewDetectionConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._predictionDriftDetectionConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._explanationConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig) -> Bool {
    if lhs._trainingDataset != rhs._trainingDataset {return false}
    if lhs._trainingPredictionSkewDetectionConfig != rhs._trainingPredictionSkewDetectionConfig {return false}
    if lhs._predictionDriftDetectionConfig != rhs._predictionDriftDetectionConfig {return false}
    if lhs._explanationConfig != rhs._explanationConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingDataset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.protoMessageName + ".TrainingDataset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "dataset"),
    4: .standard(proto: "gcs_source"),
    5: .standard(proto: "bigquery_source"),
    2: .standard(proto: "data_format"),
    6: .standard(proto: "target_field"),
    7: .standard(proto: "logging_sampling_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.dataFormat) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.dataSource != nil {try decoder.handleConflictingOneOf()}
          self.dataSource = .dataset(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_GcsSource?
        var hadOneofValue = false
        if let current = self.dataSource {
          hadOneofValue = true
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dataSource = .gcsSource(v)
        }
      }()
      case 5: try {
        var v: Google_Cloud_Aiplatform_V1_BigQuerySource?
        var hadOneofValue = false
        if let current = self.dataSource {
          hadOneofValue = true
          if case .bigquerySource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dataSource = .bigquerySource(v)
        }
      }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.targetField) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._loggingSamplingStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dataFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.dataFormat, fieldNumber: 2)
    }
    switch self.dataSource {
    case .dataset?: try {
      guard case .dataset(let v)? = self.dataSource else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .gcsSource?: try {
      guard case .gcsSource(let v)? = self.dataSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .bigquerySource?: try {
      guard case .bigquerySource(let v)? = self.dataSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if !self.targetField.isEmpty {
      try visitor.visitSingularStringField(value: self.targetField, fieldNumber: 6)
    }
    try { if let v = self._loggingSamplingStrategy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingDataset, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingDataset) -> Bool {
    if lhs.dataSource != rhs.dataSource {return false}
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs.targetField != rhs.targetField {return false}
    if lhs._loggingSamplingStrategy != rhs._loggingSamplingStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.protoMessageName + ".TrainingPredictionSkewDetectionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "skew_thresholds"),
    2: .standard(proto: "attribution_score_skew_thresholds"),
    6: .standard(proto: "default_skew_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: &self.skewThresholds) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: &self.attributionScoreSkewThresholds) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._defaultSkewThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.skewThresholds.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: self.skewThresholds, fieldNumber: 1)
    }
    if !self.attributionScoreSkewThresholds.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: self.attributionScoreSkewThresholds, fieldNumber: 2)
    }
    try { if let v = self._defaultSkewThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig) -> Bool {
    if lhs.skewThresholds != rhs.skewThresholds {return false}
    if lhs.attributionScoreSkewThresholds != rhs.attributionScoreSkewThresholds {return false}
    if lhs._defaultSkewThreshold != rhs._defaultSkewThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.protoMessageName + ".PredictionDriftDetectionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "drift_thresholds"),
    2: .standard(proto: "attribution_score_drift_thresholds"),
    5: .standard(proto: "default_drift_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: &self.driftThresholds) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: &self.attributionScoreDriftThresholds) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._defaultDriftThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.driftThresholds.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: self.driftThresholds, fieldNumber: 1)
    }
    if !self.attributionScoreDriftThresholds.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ThresholdConfig>.self, value: self.attributionScoreDriftThresholds, fieldNumber: 2)
    }
    try { if let v = self._defaultDriftThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig) -> Bool {
    if lhs.driftThresholds != rhs.driftThresholds {return false}
    if lhs.attributionScoreDriftThresholds != rhs.attributionScoreDriftThresholds {return false}
    if lhs._defaultDriftThreshold != rhs._defaultDriftThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.protoMessageName + ".ExplanationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_feature_attributes"),
    2: .standard(proto: "explanation_baseline"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableFeatureAttributes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._explanationBaseline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enableFeatureAttributes != false {
      try visitor.visitSingularBoolField(value: self.enableFeatureAttributes, fieldNumber: 1)
    }
    try { if let v = self._explanationBaseline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig) -> Bool {
    if lhs.enableFeatureAttributes != rhs.enableFeatureAttributes {return false}
    if lhs._explanationBaseline != rhs._explanationBaseline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.protoMessageName + ".ExplanationBaseline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "gcs"),
    3: .same(proto: "bigquery"),
    1: .standard(proto: "prediction_format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.predictionFormat) }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_GcsDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .gcs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .gcs(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_BigQueryDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .bigquery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .bigquery(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.predictionFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.predictionFormat, fieldNumber: 1)
    }
    switch self.destination {
    case .gcs?: try {
      guard case .gcs(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bigquery?: try {
      guard case .bigquery(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.predictionFormat != rhs.predictionFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline.PredictionFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREDICTION_FORMAT_UNSPECIFIED"),
    2: .same(proto: "JSONL"),
    3: .same(proto: "BIGQUERY"),
  ]
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelMonitoringAlertConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "email_alert_config"),
    2: .standard(proto: "enable_logging"),
    3: .standard(proto: "notification_channels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.EmailAlertConfig?
        var hadOneofValue = false
        if let current = self.alert {
          hadOneofValue = true
          if case .emailAlertConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.alert = .emailAlertConfig(v)
        }
      }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableLogging) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.notificationChannels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .emailAlertConfig(let v)? = self.alert {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.enableLogging != false {
      try visitor.visitSingularBoolField(value: self.enableLogging, fieldNumber: 2)
    }
    if !self.notificationChannels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.notificationChannels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig) -> Bool {
    if lhs.alert != rhs.alert {return false}
    if lhs.enableLogging != rhs.enableLogging {return false}
    if lhs.notificationChannels != rhs.notificationChannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.EmailAlertConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.protoMessageName + ".EmailAlertConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_emails"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.userEmails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userEmails.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userEmails, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.EmailAlertConfig, rhs: Google_Cloud_Aiplatform_V1_ModelMonitoringAlertConfig.EmailAlertConfig) -> Bool {
    if lhs.userEmails != rhs.userEmails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ThresholdConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.threshold != nil {try decoder.handleConflictingOneOf()}
          self.threshold = .value(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .value(let v)? = self.threshold {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ThresholdConfig, rhs: Google_Cloud_Aiplatform_V1_ThresholdConfig) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SamplingStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SamplingStrategy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "random_sample_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._randomSampleConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._randomSampleConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SamplingStrategy, rhs: Google_Cloud_Aiplatform_V1_SamplingStrategy) -> Bool {
    if lhs._randomSampleConfig != rhs._randomSampleConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SamplingStrategy.RandomSampleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_SamplingStrategy.protoMessageName + ".RandomSampleConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.sampleRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sampleRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.sampleRate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SamplingStrategy.RandomSampleConfig, rhs: Google_Cloud_Aiplatform_V1_SamplingStrategy.RandomSampleConfig) -> Bool {
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
