// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1/explanation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Explanation of a prediction (provided in
/// [PredictResponse.predictions][google.cloud.aiplatform.v1.PredictResponse.predictions])
/// produced by the Model on a given
/// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances].
public struct Google_Cloud_Aiplatform_V1_Explanation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Feature attributions grouped by predicted outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item.
  /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
  /// can be used to identify which output this attribution is explaining.
  ///
  /// By default, we provide Shapley values for the predicted class. However,
  /// you can configure the explanation request to generate Shapley values for
  /// any other classes too. For example, if a model predicts a probability of
  /// `0.4` for approving a loan application, the model's decision is to reject
  /// the application since `p(reject) = 0.6 > p(approve) = 0.4`, and the default
  /// Shapley values would be computed for rejection decision and not approval,
  /// even though the latter might be the positive class.
  ///
  /// If users set
  /// [ExplanationParameters.top_k][google.cloud.aiplatform.v1.ExplanationParameters.top_k],
  /// the attributions are sorted by
  /// [instance_output_value][Attributions.instance_output_value] in descending
  /// order. If
  /// [ExplanationParameters.output_indices][google.cloud.aiplatform.v1.ExplanationParameters.output_indices]
  /// is specified, the attributions are stored by
  /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
  /// in the same order as they appear in the output_indices.
  public var attributions: [Google_Cloud_Aiplatform_V1_Attribution] = []

  /// Output only. List of the nearest neighbors for example-based explanations.
  ///
  /// For models deployed with the examples explanations feature enabled, the
  /// attributions field is empty and instead the neighbors field is populated.
  public var neighbors: [Google_Cloud_Aiplatform_V1_Neighbor] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Aggregated explanation metrics for a Model over a set of instances.
public struct Google_Cloud_Aiplatform_V1_ModelExplanation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Aggregated attributions explaining the Model's prediction
  /// outputs over the set of instances. The attributions are grouped by outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item.
  /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
  /// can be used to identify which output this attribution is explaining.
  ///
  /// The
  /// [baselineOutputValue][google.cloud.aiplatform.v1.Attribution.baseline_output_value],
  /// [instanceOutputValue][google.cloud.aiplatform.v1.Attribution.instance_output_value]
  /// and
  /// [featureAttributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
  /// fields are averaged over the test data.
  ///
  /// NOTE: Currently AutoML tabular classification Models produce only one
  /// attribution, which averages attributions over all the classes it predicts.
  /// [Attribution.approximation_error][google.cloud.aiplatform.v1.Attribution.approximation_error]
  /// is not populated.
  public var meanAttributions: [Google_Cloud_Aiplatform_V1_Attribution] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Attribution that explains a particular prediction output.
public struct Google_Cloud_Aiplatform_V1_Attribution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Model predicted output if the input instance is constructed
  /// from the baselines of all the features defined in
  /// [ExplanationMetadata.inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
  /// The field name of the output is determined by the key in
  /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
  ///
  /// If the Model's predicted output has multiple dimensions (rank > 1), this is
  /// the value in the output located by
  /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index].
  ///
  /// If there are multiple baselines, their output values are averaged.
  public var baselineOutputValue: Double = 0

  /// Output only. Model predicted output on the corresponding [explanation
  /// instance][ExplainRequest.instances]. The field name of the output is
  /// determined by the key in
  /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
  ///
  /// If the Model predicted output has multiple dimensions, this is the value in
  /// the output located by
  /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index].
  public var instanceOutputValue: Double = 0

  /// Output only. Attributions of each explained feature. Features are extracted
  /// from the [prediction
  /// instances][google.cloud.aiplatform.v1.ExplainRequest.instances] according
  /// to [explanation metadata for
  /// inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
  ///
  /// The value is a struct, whose keys are the name of the feature. The values
  /// are how much the feature in the
  /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances] contributed
  /// to the predicted result.
  ///
  /// The format of the value is determined by the feature's input format:
  ///
  ///   * If the feature is a scalar value, the attribution value is a
  ///     [floating number][google.protobuf.Value.number_value].
  ///
  ///   * If the feature is an array of scalar values, the attribution value is
  ///     an [array][google.protobuf.Value.list_value].
  ///
  ///   * If the feature is a struct, the attribution value is a
  ///     [struct][google.protobuf.Value.struct_value]. The keys in the
  ///     attribution value struct are the same as the keys in the feature
  ///     struct. The formats of the values in the attribution struct are
  ///     determined by the formats of the values in the feature struct.
  ///
  /// The
  /// [ExplanationMetadata.feature_attributions_schema_uri][google.cloud.aiplatform.v1.ExplanationMetadata.feature_attributions_schema_uri]
  /// field, pointed to by the
  /// [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] field of the
  /// [Endpoint.deployed_models][google.cloud.aiplatform.v1.Endpoint.deployed_models]
  /// object, points to the schema file that describes the features and their
  /// attribution values (if it is populated).
  public var featureAttributions: SwiftProtobuf.Google_Protobuf_Value {
    get {return _featureAttributions ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_featureAttributions = newValue}
  }
  /// Returns true if `featureAttributions` has been explicitly set.
  public var hasFeatureAttributions: Bool {return self._featureAttributions != nil}
  /// Clears the value of `featureAttributions`. Subsequent reads from it will return its default value.
  public mutating func clearFeatureAttributions() {self._featureAttributions = nil}

  /// Output only. The index that locates the explained prediction output.
  ///
  /// If the prediction output is a scalar value, output_index is not populated.
  /// If the prediction output has multiple dimensions, the length of the
  /// output_index list is the same as the number of dimensions of the output.
  /// The i-th element in output_index is the element index of the i-th dimension
  /// of the output vector. Indices start from 0.
  public var outputIndex: [Int32] = []

  /// Output only. The display name of the output identified by
  /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index]. For
  /// example, the predicted class name by a multi-classification Model.
  ///
  /// This field is only populated iff the Model predicts display names as a
  /// separate field along with the explained output. The predicted display name
  /// must has the same shape of the explained output, and can be located using
  /// output_index.
  public var outputDisplayName: String = String()

  /// Output only. Error of
  /// [feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
  /// caused by approximation used in the explanation method. Lower value means
  /// more precise attributions.
  ///
  /// * For Sampled Shapley
  /// [attribution][google.cloud.aiplatform.v1.ExplanationParameters.sampled_shapley_attribution],
  /// increasing
  /// [path_count][google.cloud.aiplatform.v1.SampledShapleyAttribution.path_count]
  /// might reduce the error.
  /// * For Integrated Gradients
  /// [attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution],
  /// increasing
  /// [step_count][google.cloud.aiplatform.v1.IntegratedGradientsAttribution.step_count]
  /// might reduce the error.
  /// * For [XRAI
  /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution],
  /// increasing
  /// [step_count][google.cloud.aiplatform.v1.XraiAttribution.step_count] might
  /// reduce the error.
  ///
  /// See [this introduction](/vertex-ai/docs/explainable-ai/overview)
  /// for more information.
  public var approximationError: Double = 0

  /// Output only. Name of the explain output. Specified as the key in
  /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1.ExplanationMetadata.outputs].
  public var outputName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _featureAttributions: SwiftProtobuf.Google_Protobuf_Value? = nil
}

/// Neighbors for example-based explanations.
public struct Google_Cloud_Aiplatform_V1_Neighbor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The neighbor id.
  public var neighborID: String = String()

  /// Output only. The neighbor distance.
  public var neighborDistance: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specification of Model explanation.
public struct Google_Cloud_Aiplatform_V1_ExplanationSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parameters that configure explaining of the Model's predictions.
  public var parameters: Google_Cloud_Aiplatform_V1_ExplanationParameters {
    get {return _parameters ?? Google_Cloud_Aiplatform_V1_ExplanationParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  /// Optional. Metadata describing the Model's input and output for explanation.
  public var metadata: Google_Cloud_Aiplatform_V1_ExplanationMetadata {
    get {return _metadata ?? Google_Cloud_Aiplatform_V1_ExplanationMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameters: Google_Cloud_Aiplatform_V1_ExplanationParameters? = nil
  fileprivate var _metadata: Google_Cloud_Aiplatform_V1_ExplanationMetadata? = nil
}

/// Parameters to configure explaining for Model's predictions.
public struct Google_Cloud_Aiplatform_V1_ExplanationParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: Google_Cloud_Aiplatform_V1_ExplanationParameters.OneOf_Method? = nil

  /// An attribution method that approximates Shapley values for features that
  /// contribute to the label being predicted. A sampling strategy is used to
  /// approximate the value rather than considering all subsets of features.
  /// Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
  public var sampledShapleyAttribution: Google_Cloud_Aiplatform_V1_SampledShapleyAttribution {
    get {
      if case .sampledShapleyAttribution(let v)? = method {return v}
      return Google_Cloud_Aiplatform_V1_SampledShapleyAttribution()
    }
    set {method = .sampledShapleyAttribution(newValue)}
  }

  /// An attribution method that computes Aumann-Shapley values taking
  /// advantage of the model's fully differentiable structure. Refer to this
  /// paper for more details: https://arxiv.org/abs/1703.01365
  public var integratedGradientsAttribution: Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution {
    get {
      if case .integratedGradientsAttribution(let v)? = method {return v}
      return Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution()
    }
    set {method = .integratedGradientsAttribution(newValue)}
  }

  /// An attribution method that redistributes Integrated Gradients
  /// attribution to segmented regions, taking advantage of the model's fully
  /// differentiable structure. Refer to this paper for
  /// more details: https://arxiv.org/abs/1906.02825
  ///
  /// XRAI currently performs better on natural images, like a picture of a
  /// house or an animal. If the images are taken in artificial environments,
  /// like a lab or manufacturing line, or from diagnostic equipment, like
  /// x-rays or quality-control cameras, use Integrated Gradients instead.
  public var xraiAttribution: Google_Cloud_Aiplatform_V1_XraiAttribution {
    get {
      if case .xraiAttribution(let v)? = method {return v}
      return Google_Cloud_Aiplatform_V1_XraiAttribution()
    }
    set {method = .xraiAttribution(newValue)}
  }

  /// Example-based explanations that returns the nearest neighbors from the
  /// provided dataset.
  public var examples: Google_Cloud_Aiplatform_V1_Examples {
    get {
      if case .examples(let v)? = method {return v}
      return Google_Cloud_Aiplatform_V1_Examples()
    }
    set {method = .examples(newValue)}
  }

  /// If populated, returns attributions for top K indices of outputs
  /// (defaults to 1). Only applies to Models that predicts more than one outputs
  /// (e,g, multi-class Models). When set to -1, returns explanations for all
  /// outputs.
  public var topK: Int32 = 0

  /// If populated, only returns attributions that have
  /// [output_index][google.cloud.aiplatform.v1.Attribution.output_index]
  /// contained in output_indices. It must be an ndarray of integers, with the
  /// same shape of the output it's explaining.
  ///
  /// If not populated, returns attributions for
  /// [top_k][google.cloud.aiplatform.v1.ExplanationParameters.top_k] indices of
  /// outputs. If neither top_k nor output_indices is populated, returns the
  /// argmax index of the outputs.
  ///
  /// Only applicable to Models that predict multiple outputs (e,g, multi-class
  /// Models that predict multiple classes).
  public var outputIndices: SwiftProtobuf.Google_Protobuf_ListValue {
    get {return _outputIndices ?? SwiftProtobuf.Google_Protobuf_ListValue()}
    set {_outputIndices = newValue}
  }
  /// Returns true if `outputIndices` has been explicitly set.
  public var hasOutputIndices: Bool {return self._outputIndices != nil}
  /// Clears the value of `outputIndices`. Subsequent reads from it will return its default value.
  public mutating func clearOutputIndices() {self._outputIndices = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Method: Equatable, Sendable {
    /// An attribution method that approximates Shapley values for features that
    /// contribute to the label being predicted. A sampling strategy is used to
    /// approximate the value rather than considering all subsets of features.
    /// Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
    case sampledShapleyAttribution(Google_Cloud_Aiplatform_V1_SampledShapleyAttribution)
    /// An attribution method that computes Aumann-Shapley values taking
    /// advantage of the model's fully differentiable structure. Refer to this
    /// paper for more details: https://arxiv.org/abs/1703.01365
    case integratedGradientsAttribution(Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution)
    /// An attribution method that redistributes Integrated Gradients
    /// attribution to segmented regions, taking advantage of the model's fully
    /// differentiable structure. Refer to this paper for
    /// more details: https://arxiv.org/abs/1906.02825
    ///
    /// XRAI currently performs better on natural images, like a picture of a
    /// house or an animal. If the images are taken in artificial environments,
    /// like a lab or manufacturing line, or from diagnostic equipment, like
    /// x-rays or quality-control cameras, use Integrated Gradients instead.
    case xraiAttribution(Google_Cloud_Aiplatform_V1_XraiAttribution)
    /// Example-based explanations that returns the nearest neighbors from the
    /// provided dataset.
    case examples(Google_Cloud_Aiplatform_V1_Examples)

  }

  public init() {}

  fileprivate var _outputIndices: SwiftProtobuf.Google_Protobuf_ListValue? = nil
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted. A sampling strategy is used to
/// approximate the value rather than considering all subsets of features.
public struct Google_Cloud_Aiplatform_V1_SampledShapleyAttribution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The number of feature permutations to consider when approximating
  /// the Shapley values.
  ///
  /// Valid range of its value is [1, 50], inclusively.
  public var pathCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An attribution method that computes the Aumann-Shapley value taking advantage
/// of the model's fully differentiable structure. Refer to this paper for
/// more details: https://arxiv.org/abs/1703.01365
public struct Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  public var stepCount: Int32 = 0

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  public var smoothGradConfig: Google_Cloud_Aiplatform_V1_SmoothGradConfig {
    get {return _smoothGradConfig ?? Google_Cloud_Aiplatform_V1_SmoothGradConfig()}
    set {_smoothGradConfig = newValue}
  }
  /// Returns true if `smoothGradConfig` has been explicitly set.
  public var hasSmoothGradConfig: Bool {return self._smoothGradConfig != nil}
  /// Clears the value of `smoothGradConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSmoothGradConfig() {self._smoothGradConfig = nil}

  /// Config for IG with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image) is
  /// motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  public var blurBaselineConfig: Google_Cloud_Aiplatform_V1_BlurBaselineConfig {
    get {return _blurBaselineConfig ?? Google_Cloud_Aiplatform_V1_BlurBaselineConfig()}
    set {_blurBaselineConfig = newValue}
  }
  /// Returns true if `blurBaselineConfig` has been explicitly set.
  public var hasBlurBaselineConfig: Bool {return self._blurBaselineConfig != nil}
  /// Clears the value of `blurBaselineConfig`. Subsequent reads from it will return its default value.
  public mutating func clearBlurBaselineConfig() {self._blurBaselineConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _smoothGradConfig: Google_Cloud_Aiplatform_V1_SmoothGradConfig? = nil
  fileprivate var _blurBaselineConfig: Google_Cloud_Aiplatform_V1_BlurBaselineConfig? = nil
}

/// An explanation method that redistributes Integrated Gradients
/// attributions to segmented regions, taking advantage of the model's fully
/// differentiable structure. Refer to this paper for more details:
/// https://arxiv.org/abs/1906.02825
///
/// Supported only by image Models.
public struct Google_Cloud_Aiplatform_V1_XraiAttribution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is met within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  public var stepCount: Int32 = 0

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  public var smoothGradConfig: Google_Cloud_Aiplatform_V1_SmoothGradConfig {
    get {return _smoothGradConfig ?? Google_Cloud_Aiplatform_V1_SmoothGradConfig()}
    set {_smoothGradConfig = newValue}
  }
  /// Returns true if `smoothGradConfig` has been explicitly set.
  public var hasSmoothGradConfig: Bool {return self._smoothGradConfig != nil}
  /// Clears the value of `smoothGradConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSmoothGradConfig() {self._smoothGradConfig = nil}

  /// Config for XRAI with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image) is
  /// motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  public var blurBaselineConfig: Google_Cloud_Aiplatform_V1_BlurBaselineConfig {
    get {return _blurBaselineConfig ?? Google_Cloud_Aiplatform_V1_BlurBaselineConfig()}
    set {_blurBaselineConfig = newValue}
  }
  /// Returns true if `blurBaselineConfig` has been explicitly set.
  public var hasBlurBaselineConfig: Bool {return self._blurBaselineConfig != nil}
  /// Clears the value of `blurBaselineConfig`. Subsequent reads from it will return its default value.
  public mutating func clearBlurBaselineConfig() {self._blurBaselineConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _smoothGradConfig: Google_Cloud_Aiplatform_V1_SmoothGradConfig? = nil
  fileprivate var _blurBaselineConfig: Google_Cloud_Aiplatform_V1_BlurBaselineConfig? = nil
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// https://arxiv.org/pdf/1706.03825.pdf
public struct Google_Cloud_Aiplatform_V1_SmoothGradConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents the standard deviation of the gaussian kernel
  /// that will be used to add noise to the interpolated inputs
  /// prior to computing gradients.
  public var gradientNoiseSigma: Google_Cloud_Aiplatform_V1_SmoothGradConfig.OneOf_GradientNoiseSigma? = nil

  /// This is a single float value and will be used to add noise to all the
  /// features. Use this field when all features are normalized to have the
  /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
  /// features are normalized to have 0-mean and 1-variance. Learn more about
  /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
  ///
  /// For best results the recommended value is about 10% - 20% of the standard
  /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
  /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1.
  ///
  /// If the distribution is different per feature, set
  /// [feature_noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.feature_noise_sigma]
  /// instead for each feature.
  public var noiseSigma: Float {
    get {
      if case .noiseSigma(let v)? = gradientNoiseSigma {return v}
      return 0
    }
    set {gradientNoiseSigma = .noiseSigma(newValue)}
  }

  /// This is similar to
  /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma],
  /// but provides additional flexibility. A separate noise sigma can be
  /// provided for each feature, which is useful if their distributions are
  /// different. No noise is added to features that are not set. If this field
  /// is unset,
  /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]
  /// will be used for all features.
  public var featureNoiseSigma: Google_Cloud_Aiplatform_V1_FeatureNoiseSigma {
    get {
      if case .featureNoiseSigma(let v)? = gradientNoiseSigma {return v}
      return Google_Cloud_Aiplatform_V1_FeatureNoiseSigma()
    }
    set {gradientNoiseSigma = .featureNoiseSigma(newValue)}
  }

  /// The number of gradient samples to use for
  /// approximation. The higher this number, the more accurate the gradient
  /// is, but the runtime complexity increases by this factor as well.
  /// Valid range of its value is [1, 50]. Defaults to 3.
  public var noisySampleCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents the standard deviation of the gaussian kernel
  /// that will be used to add noise to the interpolated inputs
  /// prior to computing gradients.
  public enum OneOf_GradientNoiseSigma: Equatable, Sendable {
    /// This is a single float value and will be used to add noise to all the
    /// features. Use this field when all features are normalized to have the
    /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
    /// features are normalized to have 0-mean and 1-variance. Learn more about
    /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
    ///
    /// For best results the recommended value is about 10% - 20% of the standard
    /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
    /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1.
    ///
    /// If the distribution is different per feature, set
    /// [feature_noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.feature_noise_sigma]
    /// instead for each feature.
    case noiseSigma(Float)
    /// This is similar to
    /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma],
    /// but provides additional flexibility. A separate noise sigma can be
    /// provided for each feature, which is useful if their distributions are
    /// different. No noise is added to features that are not set. If this field
    /// is unset,
    /// [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]
    /// will be used for all features.
    case featureNoiseSigma(Google_Cloud_Aiplatform_V1_FeatureNoiseSigma)

  }

  public init() {}
}

/// Noise sigma by features. Noise sigma represents the standard deviation of the
/// gaussian kernel that will be used to add noise to interpolated inputs prior
/// to computing gradients.
public struct Google_Cloud_Aiplatform_V1_FeatureNoiseSigma: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Noise sigma per feature. No noise is added to features that are not set.
  public var noiseSigma: [Google_Cloud_Aiplatform_V1_FeatureNoiseSigma.NoiseSigmaForFeature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Noise sigma for a single feature.
  public struct NoiseSigmaForFeature: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the input feature for which noise sigma is provided. The
    /// features are defined in
    /// [explanation metadata
    /// inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    public var name: String = String()

    /// This represents the standard deviation of the Gaussian kernel that will
    /// be used to add noise to the feature prior to computing gradients. Similar
    /// to [noise_sigma][google.cloud.aiplatform.v1.SmoothGradConfig.noise_sigma]
    /// but represents the noise added to the current feature. Defaults to 0.1.
    public var sigma: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// https://arxiv.org/abs/2004.03383
public struct Google_Cloud_Aiplatform_V1_BlurBaselineConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The standard deviation of the blur kernel for the blurred baseline. The
  /// same blurring parameter is used for both the height and the width
  /// dimension. If not set, the method defaults to the zero (i.e. black for
  /// images) baseline.
  public var maxBlurSigma: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
public struct Google_Cloud_Aiplatform_V1_Examples: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: Google_Cloud_Aiplatform_V1_Examples.OneOf_Source? = nil

  /// The Cloud Storage input instances.
  public var exampleGcsSource: Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource {
    get {
      if case .exampleGcsSource(let v)? = source {return v}
      return Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource()
    }
    set {source = .exampleGcsSource(newValue)}
  }

  public var config: Google_Cloud_Aiplatform_V1_Examples.OneOf_Config? = nil

  /// The full configuration for the generated index, the semantics are the
  /// same as [metadata][google.cloud.aiplatform.v1.Index.metadata] and should
  /// match
  /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
  public var nearestNeighborSearchConfig: SwiftProtobuf.Google_Protobuf_Value {
    get {
      if case .nearestNeighborSearchConfig(let v)? = config {return v}
      return SwiftProtobuf.Google_Protobuf_Value()
    }
    set {config = .nearestNeighborSearchConfig(newValue)}
  }

  /// Simplified preset configuration, which automatically sets configuration
  /// values based on the desired query speed-precision trade-off and modality.
  public var presets: Google_Cloud_Aiplatform_V1_Presets {
    get {
      if case .presets(let v)? = config {return v}
      return Google_Cloud_Aiplatform_V1_Presets()
    }
    set {config = .presets(newValue)}
  }

  /// The number of neighbors to return when querying for examples.
  public var neighborCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Source: Equatable, Sendable {
    /// The Cloud Storage input instances.
    case exampleGcsSource(Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource)

  }

  public enum OneOf_Config: Equatable, Sendable {
    /// The full configuration for the generated index, the semantics are the
    /// same as [metadata][google.cloud.aiplatform.v1.Index.metadata] and should
    /// match
    /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
    case nearestNeighborSearchConfig(SwiftProtobuf.Google_Protobuf_Value)
    /// Simplified preset configuration, which automatically sets configuration
    /// values based on the desired query speed-precision trade-off and modality.
    case presets(Google_Cloud_Aiplatform_V1_Presets)

  }

  /// The Cloud Storage input instances.
  public struct ExampleGcsSource: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The format in which instances are given, if not specified, assume it's
    /// JSONL format. Currently only JSONL format is supported.
    public var dataFormat: Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource.DataFormat = .unspecified

    /// The Cloud Storage location for the input instances.
    public var gcsSource: Google_Cloud_Aiplatform_V1_GcsSource {
      get {return _gcsSource ?? Google_Cloud_Aiplatform_V1_GcsSource()}
      set {_gcsSource = newValue}
    }
    /// Returns true if `gcsSource` has been explicitly set.
    public var hasGcsSource: Bool {return self._gcsSource != nil}
    /// Clears the value of `gcsSource`. Subsequent reads from it will return its default value.
    public mutating func clearGcsSource() {self._gcsSource = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The format of the input example instances.
    public enum DataFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Format unspecified, used when unset.
      case unspecified // = 0

      /// Examples are stored in JSONL files.
      case jsonl // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .jsonl
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .jsonl: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource.DataFormat] = [
        .unspecified,
        .jsonl,
      ]

    }

    public init() {}

    fileprivate var _gcsSource: Google_Cloud_Aiplatform_V1_GcsSource? = nil
  }

  public init() {}
}

/// Preset configuration for example-based explanations
public struct Google_Cloud_Aiplatform_V1_Presets: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Preset option controlling parameters for speed-precision trade-off when
  /// querying for examples. If omitted, defaults to `PRECISE`.
  public var query: Google_Cloud_Aiplatform_V1_Presets.Query {
    get {return _query ?? .precise}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  /// The modality of the uploaded model, which automatically configures the
  /// distance measurement and feature normalization for the underlying example
  /// index and queries. If your model does not precisely fit one of these types,
  /// it is okay to choose the closest type.
  public var modality: Google_Cloud_Aiplatform_V1_Presets.Modality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Preset option controlling parameters for query speed-precision trade-off
  public enum Query: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// More precise neighbors as a trade-off against slower response.
    case precise // = 0

    /// Faster response as a trade-off against less precise neighbors.
    case fast // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .precise
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .precise
      case 1: self = .fast
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .precise: return 0
      case .fast: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Presets.Query] = [
      .precise,
      .fast,
    ]

  }

  /// Preset option controlling parameters for different modalities
  public enum Modality: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Should not be set. Added as a recommended best practice for enums
    case unspecified // = 0

    /// IMAGE modality
    case image // = 1

    /// TEXT modality
    case text // = 2

    /// TABULAR modality
    case tabular // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .image
      case 2: self = .text
      case 3: self = .tabular
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .image: return 1
      case .text: return 2
      case .tabular: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_Presets.Modality] = [
      .unspecified,
      .image,
      .text,
      .tabular,
    ]

  }

  public init() {}

  fileprivate var _query: Google_Cloud_Aiplatform_V1_Presets.Query? = nil
}

/// The [ExplanationSpec][google.cloud.aiplatform.v1.ExplanationSpec] entries
/// that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] time.
public struct Google_Cloud_Aiplatform_V1_ExplanationSpecOverride: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parameters to be overridden. Note that the
  /// attribution method cannot be changed. If not specified,
  /// no parameter is overridden.
  public var parameters: Google_Cloud_Aiplatform_V1_ExplanationParameters {
    get {return _parameters ?? Google_Cloud_Aiplatform_V1_ExplanationParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  /// The metadata to be overridden. If not specified, no metadata is overridden.
  public var metadata: Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride {
    get {return _metadata ?? Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// The example-based explanations parameter overrides.
  public var examplesOverride: Google_Cloud_Aiplatform_V1_ExamplesOverride {
    get {return _examplesOverride ?? Google_Cloud_Aiplatform_V1_ExamplesOverride()}
    set {_examplesOverride = newValue}
  }
  /// Returns true if `examplesOverride` has been explicitly set.
  public var hasExamplesOverride: Bool {return self._examplesOverride != nil}
  /// Clears the value of `examplesOverride`. Subsequent reads from it will return its default value.
  public mutating func clearExamplesOverride() {self._examplesOverride = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameters: Google_Cloud_Aiplatform_V1_ExplanationParameters? = nil
  fileprivate var _metadata: Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride? = nil
  fileprivate var _examplesOverride: Google_Cloud_Aiplatform_V1_ExamplesOverride? = nil
}

/// The [ExplanationMetadata][google.cloud.aiplatform.v1.ExplanationMetadata]
/// entries that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1.PredictionService.Explain] time.
public struct Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Overrides the [input
  /// metadata][google.cloud.aiplatform.v1.ExplanationMetadata.inputs] of the
  /// features. The key is the name of the feature to be overridden. The keys
  /// specified here must exist in the input metadata to be overridden. If a
  /// feature is not specified here, the corresponding feature's input metadata
  /// is not overridden.
  public var inputs: Dictionary<String,Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride.InputMetadataOverride> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The [input
  /// metadata][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]
  /// entries to be overridden.
  public struct InputMetadataOverride: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baseline inputs for this feature.
    ///
    /// This overrides the `input_baseline` field of the
    /// [ExplanationMetadata.InputMetadata][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata]
    /// object of the corresponding feature's input metadata. If it's not
    /// specified, the original baselines are not overridden.
    public var inputBaselines: [SwiftProtobuf.Google_Protobuf_Value] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Overrides for example-based explanations.
public struct Google_Cloud_Aiplatform_V1_ExamplesOverride: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of neighbors to return.
  public var neighborCount: Int32 = 0

  /// The number of neighbors to return that have the same crowding tag.
  public var crowdingCount: Int32 = 0

  /// Restrict the resulting nearest neighbors to respect these constraints.
  public var restrictions: [Google_Cloud_Aiplatform_V1_ExamplesRestrictionsNamespace] = []

  /// If true, return the embeddings instead of neighbors.
  public var returnEmbeddings: Bool = false

  /// The format of the data being provided with each call.
  public var dataFormat: Google_Cloud_Aiplatform_V1_ExamplesOverride.DataFormat = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data format enum.
  public enum DataFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Unspecified format. Must not be used.
    case unspecified // = 0

    /// Provided data is a set of model inputs.
    case instances // = 1

    /// Provided data is a set of embeddings.
    case embeddings // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .instances
      case 2: self = .embeddings
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .instances: return 1
      case .embeddings: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Cloud_Aiplatform_V1_ExamplesOverride.DataFormat] = [
      .unspecified,
      .instances,
      .embeddings,
    ]

  }

  public init() {}
}

/// Restrictions namespace for example-based explanations overrides.
public struct Google_Cloud_Aiplatform_V1_ExamplesRestrictionsNamespace: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace name.
  public var namespaceName: String = String()

  /// The list of allowed tags.
  public var allow: [String] = []

  /// The list of deny tags.
  public var deny: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1"

extension Google_Cloud_Aiplatform_V1_Explanation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Explanation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributions"),
    2: .same(proto: "neighbors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attributions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.neighbors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attributions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributions, fieldNumber: 1)
    }
    if !self.neighbors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.neighbors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Explanation, rhs: Google_Cloud_Aiplatform_V1_Explanation) -> Bool {
    if lhs.attributions != rhs.attributions {return false}
    if lhs.neighbors != rhs.neighbors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ModelExplanation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelExplanation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mean_attributions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.meanAttributions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.meanAttributions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.meanAttributions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ModelExplanation, rhs: Google_Cloud_Aiplatform_V1_ModelExplanation) -> Bool {
    if lhs.meanAttributions != rhs.meanAttributions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Attribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baseline_output_value"),
    2: .standard(proto: "instance_output_value"),
    3: .standard(proto: "feature_attributions"),
    4: .standard(proto: "output_index"),
    5: .standard(proto: "output_display_name"),
    6: .standard(proto: "approximation_error"),
    7: .standard(proto: "output_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.baselineOutputValue) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.instanceOutputValue) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._featureAttributions) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.outputIndex) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.outputDisplayName) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.approximationError) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.outputName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.baselineOutputValue.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.baselineOutputValue, fieldNumber: 1)
    }
    if self.instanceOutputValue.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.instanceOutputValue, fieldNumber: 2)
    }
    try { if let v = self._featureAttributions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.outputIndex.isEmpty {
      try visitor.visitPackedInt32Field(value: self.outputIndex, fieldNumber: 4)
    }
    if !self.outputDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.outputDisplayName, fieldNumber: 5)
    }
    if self.approximationError.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.approximationError, fieldNumber: 6)
    }
    if !self.outputName.isEmpty {
      try visitor.visitSingularStringField(value: self.outputName, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Attribution, rhs: Google_Cloud_Aiplatform_V1_Attribution) -> Bool {
    if lhs.baselineOutputValue != rhs.baselineOutputValue {return false}
    if lhs.instanceOutputValue != rhs.instanceOutputValue {return false}
    if lhs._featureAttributions != rhs._featureAttributions {return false}
    if lhs.outputIndex != rhs.outputIndex {return false}
    if lhs.outputDisplayName != rhs.outputDisplayName {return false}
    if lhs.approximationError != rhs.approximationError {return false}
    if lhs.outputName != rhs.outputName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Neighbor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Neighbor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "neighbor_id"),
    2: .standard(proto: "neighbor_distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.neighborID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.neighborDistance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.neighborID.isEmpty {
      try visitor.visitSingularStringField(value: self.neighborID, fieldNumber: 1)
    }
    if self.neighborDistance.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.neighborDistance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Neighbor, rhs: Google_Cloud_Aiplatform_V1_Neighbor) -> Bool {
    if lhs.neighborID != rhs.neighborID {return false}
    if lhs.neighborDistance != rhs.neighborDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExplanationSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplanationSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExplanationSpec, rhs: Google_Cloud_Aiplatform_V1_ExplanationSpec) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExplanationParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplanationParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sampled_shapley_attribution"),
    2: .standard(proto: "integrated_gradients_attribution"),
    3: .standard(proto: "xrai_attribution"),
    7: .same(proto: "examples"),
    4: .standard(proto: "top_k"),
    5: .standard(proto: "output_indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1_SampledShapleyAttribution?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .sampledShapleyAttribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .sampledShapleyAttribution(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .integratedGradientsAttribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .integratedGradientsAttribution(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1_XraiAttribution?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .xraiAttribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .xraiAttribution(v)
        }
      }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.topK) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outputIndices) }()
      case 7: try {
        var v: Google_Cloud_Aiplatform_V1_Examples?
        var hadOneofValue = false
        if let current = self.method {
          hadOneofValue = true
          if case .examples(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.method = .examples(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.method {
    case .sampledShapleyAttribution?: try {
      guard case .sampledShapleyAttribution(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .integratedGradientsAttribution?: try {
      guard case .integratedGradientsAttribution(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .xraiAttribution?: try {
      guard case .xraiAttribution(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if self.topK != 0 {
      try visitor.visitSingularInt32Field(value: self.topK, fieldNumber: 4)
    }
    try { if let v = self._outputIndices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if case .examples(let v)? = self.method {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExplanationParameters, rhs: Google_Cloud_Aiplatform_V1_ExplanationParameters) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.topK != rhs.topK {return false}
    if lhs._outputIndices != rhs._outputIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SampledShapleyAttribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SampledShapleyAttribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pathCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pathCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SampledShapleyAttribution, rhs: Google_Cloud_Aiplatform_V1_SampledShapleyAttribution) -> Bool {
    if lhs.pathCount != rhs.pathCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegratedGradientsAttribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_count"),
    2: .standard(proto: "smooth_grad_config"),
    3: .standard(proto: "blur_baseline_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.stepCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._smoothGradConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blurBaselineConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.stepCount != 0 {
      try visitor.visitSingularInt32Field(value: self.stepCount, fieldNumber: 1)
    }
    try { if let v = self._smoothGradConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blurBaselineConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution, rhs: Google_Cloud_Aiplatform_V1_IntegratedGradientsAttribution) -> Bool {
    if lhs.stepCount != rhs.stepCount {return false}
    if lhs._smoothGradConfig != rhs._smoothGradConfig {return false}
    if lhs._blurBaselineConfig != rhs._blurBaselineConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_XraiAttribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".XraiAttribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_count"),
    2: .standard(proto: "smooth_grad_config"),
    3: .standard(proto: "blur_baseline_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.stepCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._smoothGradConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blurBaselineConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.stepCount != 0 {
      try visitor.visitSingularInt32Field(value: self.stepCount, fieldNumber: 1)
    }
    try { if let v = self._smoothGradConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blurBaselineConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_XraiAttribution, rhs: Google_Cloud_Aiplatform_V1_XraiAttribution) -> Bool {
    if lhs.stepCount != rhs.stepCount {return false}
    if lhs._smoothGradConfig != rhs._smoothGradConfig {return false}
    if lhs._blurBaselineConfig != rhs._blurBaselineConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_SmoothGradConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SmoothGradConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "noise_sigma"),
    2: .standard(proto: "feature_noise_sigma"),
    3: .standard(proto: "noisy_sample_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.gradientNoiseSigma != nil {try decoder.handleConflictingOneOf()}
          self.gradientNoiseSigma = .noiseSigma(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1_FeatureNoiseSigma?
        var hadOneofValue = false
        if let current = self.gradientNoiseSigma {
          hadOneofValue = true
          if case .featureNoiseSigma(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.gradientNoiseSigma = .featureNoiseSigma(v)
        }
      }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.noisySampleCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.gradientNoiseSigma {
    case .noiseSigma?: try {
      guard case .noiseSigma(let v)? = self.gradientNoiseSigma else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }()
    case .featureNoiseSigma?: try {
      guard case .featureNoiseSigma(let v)? = self.gradientNoiseSigma else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.noisySampleCount != 0 {
      try visitor.visitSingularInt32Field(value: self.noisySampleCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_SmoothGradConfig, rhs: Google_Cloud_Aiplatform_V1_SmoothGradConfig) -> Bool {
    if lhs.gradientNoiseSigma != rhs.gradientNoiseSigma {return false}
    if lhs.noisySampleCount != rhs.noisySampleCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureNoiseSigma: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureNoiseSigma"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "noise_sigma"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.noiseSigma) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.noiseSigma.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noiseSigma, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureNoiseSigma, rhs: Google_Cloud_Aiplatform_V1_FeatureNoiseSigma) -> Bool {
    if lhs.noiseSigma != rhs.noiseSigma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_FeatureNoiseSigma.NoiseSigmaForFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_FeatureNoiseSigma.protoMessageName + ".NoiseSigmaForFeature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "sigma"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.sigma) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.sigma.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.sigma, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_FeatureNoiseSigma.NoiseSigmaForFeature, rhs: Google_Cloud_Aiplatform_V1_FeatureNoiseSigma.NoiseSigmaForFeature) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sigma != rhs.sigma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_BlurBaselineConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlurBaselineConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_blur_sigma"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.maxBlurSigma) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxBlurSigma.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.maxBlurSigma, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_BlurBaselineConfig, rhs: Google_Cloud_Aiplatform_V1_BlurBaselineConfig) -> Bool {
    if lhs.maxBlurSigma != rhs.maxBlurSigma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Examples: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Examples"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "example_gcs_source"),
    2: .standard(proto: "nearest_neighbor_search_config"),
    4: .same(proto: "presets"),
    3: .standard(proto: "neighbor_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Value?
        var hadOneofValue = false
        if let current = self.config {
          hadOneofValue = true
          if case .nearestNeighborSearchConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.config = .nearestNeighborSearchConfig(v)
        }
      }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.neighborCount) }()
      case 4: try {
        var v: Google_Cloud_Aiplatform_V1_Presets?
        var hadOneofValue = false
        if let current = self.config {
          hadOneofValue = true
          if case .presets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.config = .presets(v)
        }
      }()
      case 5: try {
        var v: Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .exampleGcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .exampleGcsSource(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .nearestNeighborSearchConfig(let v)? = self.config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.neighborCount != 0 {
      try visitor.visitSingularInt32Field(value: self.neighborCount, fieldNumber: 3)
    }
    try { if case .presets(let v)? = self.config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if case .exampleGcsSource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Examples, rhs: Google_Cloud_Aiplatform_V1_Examples) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.config != rhs.config {return false}
    if lhs.neighborCount != rhs.neighborCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_Examples.protoMessageName + ".ExampleGcsSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_format"),
    2: .standard(proto: "gcs_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dataFormat) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gcsSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dataFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataFormat, fieldNumber: 1)
    }
    try { if let v = self._gcsSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource, rhs: Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource) -> Bool {
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs._gcsSource != rhs._gcsSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Examples.ExampleGcsSource.DataFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_FORMAT_UNSPECIFIED"),
    1: .same(proto: "JSONL"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Presets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Presets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .same(proto: "modality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._query) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.modality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._query {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if self.modality != .unspecified {
      try visitor.visitSingularEnumField(value: self.modality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_Presets, rhs: Google_Cloud_Aiplatform_V1_Presets) -> Bool {
    if lhs._query != rhs._query {return false}
    if lhs.modality != rhs.modality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_Presets.Query: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRECISE"),
    1: .same(proto: "FAST"),
  ]
}

extension Google_Cloud_Aiplatform_V1_Presets.Modality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODALITY_UNSPECIFIED"),
    1: .same(proto: "IMAGE"),
    2: .same(proto: "TEXT"),
    3: .same(proto: "TABULAR"),
  ]
}

extension Google_Cloud_Aiplatform_V1_ExplanationSpecOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplanationSpecOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "examples_override"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._examplesOverride) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._examplesOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExplanationSpecOverride, rhs: Google_Cloud_Aiplatform_V1_ExplanationSpecOverride) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._examplesOverride != rhs._examplesOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplanationMetadataOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride.InputMetadataOverride>.self, value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride.InputMetadataOverride>.self, value: self.inputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride, rhs: Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride.InputMetadataOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride.protoMessageName + ".InputMetadataOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_baselines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputBaselines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputBaselines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputBaselines, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride.InputMetadataOverride, rhs: Google_Cloud_Aiplatform_V1_ExplanationMetadataOverride.InputMetadataOverride) -> Bool {
    if lhs.inputBaselines != rhs.inputBaselines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExamplesOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExamplesOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "neighbor_count"),
    2: .standard(proto: "crowding_count"),
    3: .same(proto: "restrictions"),
    4: .standard(proto: "return_embeddings"),
    5: .standard(proto: "data_format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.neighborCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.crowdingCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.restrictions) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.returnEmbeddings) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.dataFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.neighborCount != 0 {
      try visitor.visitSingularInt32Field(value: self.neighborCount, fieldNumber: 1)
    }
    if self.crowdingCount != 0 {
      try visitor.visitSingularInt32Field(value: self.crowdingCount, fieldNumber: 2)
    }
    if !self.restrictions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.restrictions, fieldNumber: 3)
    }
    if self.returnEmbeddings != false {
      try visitor.visitSingularBoolField(value: self.returnEmbeddings, fieldNumber: 4)
    }
    if self.dataFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataFormat, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExamplesOverride, rhs: Google_Cloud_Aiplatform_V1_ExamplesOverride) -> Bool {
    if lhs.neighborCount != rhs.neighborCount {return false}
    if lhs.crowdingCount != rhs.crowdingCount {return false}
    if lhs.restrictions != rhs.restrictions {return false}
    if lhs.returnEmbeddings != rhs.returnEmbeddings {return false}
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1_ExamplesOverride.DataFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_FORMAT_UNSPECIFIED"),
    1: .same(proto: "INSTANCES"),
    2: .same(proto: "EMBEDDINGS"),
  ]
}

extension Google_Cloud_Aiplatform_V1_ExamplesRestrictionsNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExamplesRestrictionsNamespace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "namespace_name"),
    2: .same(proto: "allow"),
    3: .same(proto: "deny"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespaceName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allow) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.deny) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceName, fieldNumber: 1)
    }
    if !self.allow.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allow, fieldNumber: 2)
    }
    if !self.deny.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deny, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1_ExamplesRestrictionsNamespace, rhs: Google_Cloud_Aiplatform_V1_ExamplesRestrictionsNamespace) -> Bool {
    if lhs.namespaceName != rhs.namespaceName {return false}
    if lhs.allow != rhs.allow {return false}
    if lhs.deny != rhs.deny {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
