// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/translate/v3/adaptive_mt.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An Adaptive MT Dataset.
struct Google_Cloud_Translation_V3_AdaptiveMtDataset: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the dataset, in form of
  /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset_id}`
  var name: String = String()

  /// The name of the dataset to show in the interface. The name can be
  /// up to 32 characters long and can consist only of ASCII Latin letters A-Z
  /// and a-z, underscores (_), and ASCII digits 0-9.
  var displayName: String = String()

  /// The BCP-47 language code of the source language.
  var sourceLanguageCode: String = String()

  /// The BCP-47 language code of the target language.
  var targetLanguageCode: String = String()

  /// The number of examples in the dataset.
  var exampleCount: Int32 = 0

  /// Output only. Timestamp when this dataset was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Timestamp when this dataset was last updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Â Request message for creating an AdaptiveMtDataset.
struct Google_Cloud_Translation_V3_CreateAdaptiveMtDatasetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the parent project. In form of
  /// `projects/{project-number-or-id}/locations/{location-id}`
  var parent: String = String()

  /// Required. The AdaptiveMtDataset to be created.
  var adaptiveMtDataset: Google_Cloud_Translation_V3_AdaptiveMtDataset {
    get {return _adaptiveMtDataset ?? Google_Cloud_Translation_V3_AdaptiveMtDataset()}
    set {_adaptiveMtDataset = newValue}
  }
  /// Returns true if `adaptiveMtDataset` has been explicitly set.
  var hasAdaptiveMtDataset: Bool {return self._adaptiveMtDataset != nil}
  /// Clears the value of `adaptiveMtDataset`. Subsequent reads from it will return its default value.
  mutating func clearAdaptiveMtDataset() {self._adaptiveMtDataset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adaptiveMtDataset: Google_Cloud_Translation_V3_AdaptiveMtDataset? = nil
}

/// Request message for deleting an AdaptiveMtDataset.
struct Google_Cloud_Translation_V3_DeleteAdaptiveMtDatasetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the dataset. In the form of
  /// `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for getting an Adaptive MT dataset.
struct Google_Cloud_Translation_V3_GetAdaptiveMtDatasetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the dataset. In the form of
  /// `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for listing all Adaptive MT datasets that the requestor has
/// access to.
struct Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the project from which to list the Adaptive
  /// MT datasets. `projects/{project-number-or-id}/locations/{location-id}`
  var parent: String = String()

  /// Optional. Requested page size. The server may return fewer results than
  /// requested. If unspecified, the server picks an appropriate default.
  var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results the server should return.
  /// Typically, this is the value of
  /// ListAdaptiveMtDatasetsResponse.next_page_token returned from the
  /// previous call to `ListAdaptiveMtDatasets` method. The first page is
  /// returned if `page_token`is empty or missing.
  var pageToken: String = String()

  /// Optional. An expression for filtering the results of the request.
  /// Filter is not supported yet.
  var filter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list of AdaptiveMtDatasets.
struct Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. A list of Adaptive MT datasets.
  var adaptiveMtDatasets: [Google_Cloud_Translation_V3_AdaptiveMtDataset] = []

  /// Optional. A token to retrieve a page of results. Pass this value in the
  /// [ListAdaptiveMtDatasetsRequest.page_token] field in the subsequent call to
  /// `ListAdaptiveMtDatasets` method to retrieve the next page of results.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request for sending an AdaptiveMt translation query.
struct Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Location to make a regional call.
  ///
  /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
  var parent: String = String()

  /// Required. The resource name for the dataset to use for adaptive MT.
  /// `projects/{project}/locations/{location-id}/adaptiveMtDatasets/{dataset}`
  var dataset: String = String()

  /// Required. The content of the input in string format.
  var content: [String] = []

  /// Configuration for caller provided reference sentences.
  var referenceSentenceConfig: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentenceConfig {
    get {return _referenceSentenceConfig ?? Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentenceConfig()}
    set {_referenceSentenceConfig = newValue}
  }
  /// Returns true if `referenceSentenceConfig` has been explicitly set.
  var hasReferenceSentenceConfig: Bool {return self._referenceSentenceConfig != nil}
  /// Clears the value of `referenceSentenceConfig`. Subsequent reads from it will return its default value.
  mutating func clearReferenceSentenceConfig() {self._referenceSentenceConfig = nil}

  /// Optional. Glossary to be applied. The glossary must be
  /// within the same region (have the same location-id) as the model, otherwise
  /// an INVALID_ARGUMENT (400) error is returned.
  var glossaryConfig: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.GlossaryConfig {
    get {return _glossaryConfig ?? Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.GlossaryConfig()}
    set {_glossaryConfig = newValue}
  }
  /// Returns true if `glossaryConfig` has been explicitly set.
  var hasGlossaryConfig: Bool {return self._glossaryConfig != nil}
  /// Clears the value of `glossaryConfig`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryConfig() {self._glossaryConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A pair of sentences used as reference in source and target languages.
  struct ReferenceSentencePair: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Source sentence in the sentence pair.
    var sourceSentence: String = String()

    /// Target sentence in the sentence pair.
    var targetSentence: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A list of reference sentence pairs.
  struct ReferenceSentencePairList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Reference sentence pairs.
    var referenceSentencePairs: [Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePair] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Message of caller-provided reference configuration.
  struct ReferenceSentenceConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Reference sentences pair lists. Each list will be used as the references
    /// to translate the sentence under "content" field at the corresponding
    /// index. Length of the list is required to be equal to the length of
    /// "content" field.
    var referenceSentencePairLists: [Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePairList] = []

    /// Source language code.
    var sourceLanguageCode: String = String()

    /// Target language code.
    var targetLanguageCode: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Configures which glossary is used for a specific target language and
  /// defines
  /// options for applying that glossary.
  struct GlossaryConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The `glossary` to be applied for this translation.
    ///
    /// The format depends on the glossary:
    ///
    /// - User-provided custom glossary:
    ///   `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
    var glossary: String = String()

    /// Optional. Indicates match is case insensitive. The default value is
    /// `false` if missing.
    var ignoreCase: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _referenceSentenceConfig: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentenceConfig? = nil
  fileprivate var _glossaryConfig: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.GlossaryConfig? = nil
}

/// An AdaptiveMt translation.
struct Google_Cloud_Translation_V3_AdaptiveMtTranslation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The translated text.
  var translatedText: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An AdaptiveMtTranslate response.
struct Google_Cloud_Translation_V3_AdaptiveMtTranslateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The translation.
  var translations: [Google_Cloud_Translation_V3_AdaptiveMtTranslation] = []

  /// Output only. The translation's language code.
  var languageCode: String = String()

  /// Text translation response if a glossary is provided in the request. This
  /// could be the same as 'translation' above if no terms apply.
  var glossaryTranslations: [Google_Cloud_Translation_V3_AdaptiveMtTranslation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An AdaptiveMtFile.
struct Google_Cloud_Translation_V3_AdaptiveMtFile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the file, in form of
  /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
  var name: String = String()

  /// The file's display name.
  var displayName: String = String()

  /// The number of entries that the file contains.
  var entryCount: Int32 = 0

  /// Output only. Timestamp when this file was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Timestamp when this file was last updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for getting an AdaptiveMtFile.
struct Google_Cloud_Translation_V3_GetAdaptiveMtFileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the file, in form of
  /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request for deleting an AdaptiveMt file.
struct Google_Cloud_Translation_V3_DeleteAdaptiveMtFileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the file to delete, in form of
  /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request for importing an AdaptiveMt file along with its sentences.
struct Google_Cloud_Translation_V3_ImportAdaptiveMtFileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the file, in form of
  /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}`
  var parent: String = String()

  /// The source for the document.
  var source: Google_Cloud_Translation_V3_ImportAdaptiveMtFileRequest.OneOf_Source? = nil

  /// Inline file source.
  var fileInputSource: Google_Cloud_Translation_V3_FileInputSource {
    get {
      if case .fileInputSource(let v)? = source {return v}
      return Google_Cloud_Translation_V3_FileInputSource()
    }
    set {source = .fileInputSource(newValue)}
  }

  /// Google Cloud Storage file source.
  var gcsInputSource: Google_Cloud_Translation_V3_GcsInputSource {
    get {
      if case .gcsInputSource(let v)? = source {return v}
      return Google_Cloud_Translation_V3_GcsInputSource()
    }
    set {source = .gcsInputSource(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The source for the document.
  enum OneOf_Source: Equatable, Sendable {
    /// Inline file source.
    case fileInputSource(Google_Cloud_Translation_V3_FileInputSource)
    /// Google Cloud Storage file source.
    case gcsInputSource(Google_Cloud_Translation_V3_GcsInputSource)

  }

  init() {}
}

/// The response for importing an AdaptiveMtFile
struct Google_Cloud_Translation_V3_ImportAdaptiveMtFileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The Adaptive MT file that was imported.
  var adaptiveMtFile: Google_Cloud_Translation_V3_AdaptiveMtFile {
    get {return _adaptiveMtFile ?? Google_Cloud_Translation_V3_AdaptiveMtFile()}
    set {_adaptiveMtFile = newValue}
  }
  /// Returns true if `adaptiveMtFile` has been explicitly set.
  var hasAdaptiveMtFile: Bool {return self._adaptiveMtFile != nil}
  /// Clears the value of `adaptiveMtFile`. Subsequent reads from it will return its default value.
  mutating func clearAdaptiveMtFile() {self._adaptiveMtFile = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adaptiveMtFile: Google_Cloud_Translation_V3_AdaptiveMtFile? = nil
}

/// The request to list all AdaptiveMt files under a given dataset.
struct Google_Cloud_Translation_V3_ListAdaptiveMtFilesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the project from which to list the Adaptive
  /// MT files.
  /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
  var parent: String = String()

  /// Optional.
  var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results the server should return.
  /// Typically, this is the value of
  /// ListAdaptiveMtFilesResponse.next_page_token returned from the
  /// previous call to `ListAdaptiveMtFiles` method. The first page is
  /// returned if `page_token`is empty or missing.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for listing all AdaptiveMt files under a given dataset.
struct Google_Cloud_Translation_V3_ListAdaptiveMtFilesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The Adaptive MT files.
  var adaptiveMtFiles: [Google_Cloud_Translation_V3_AdaptiveMtFile] = []

  /// Optional. A token to retrieve a page of results. Pass this value in the
  /// ListAdaptiveMtFilesRequest.page_token field in the subsequent call to
  /// `ListAdaptiveMtFiles` method to retrieve the next page of results.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An AdaptiveMt sentence entry.
struct Google_Cloud_Translation_V3_AdaptiveMtSentence: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the file, in form of
  /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}/adaptiveMtSentences/{sentence}`
  var name: String = String()

  /// Required. The source sentence.
  var sourceSentence: String = String()

  /// Required. The target sentence.
  var targetSentence: String = String()

  /// Output only. Timestamp when this sentence was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Timestamp when this sentence was last updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for listing Adaptive MT sentences from a Dataset/File.
struct Google_Cloud_Translation_V3_ListAdaptiveMtSentencesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the project from which to list the Adaptive
  /// MT files. The following format lists all sentences under a file.
  /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
  /// The following format lists all sentences within a dataset.
  /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
  var parent: String = String()

  var pageSize: Int32 = 0

  /// A token identifying a page of results the server should return.
  /// Typically, this is the value of
  /// ListAdaptiveMtSentencesRequest.next_page_token returned from the
  /// previous call to `ListTranslationMemories` method. The first page is
  /// returned if `page_token` is empty or missing.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// List AdaptiveMt sentences response.
struct Google_Cloud_Translation_V3_ListAdaptiveMtSentencesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The list of AdaptiveMtSentences.
  var adaptiveMtSentences: [Google_Cloud_Translation_V3_AdaptiveMtSentence] = []

  /// Optional.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.translation.v3"

extension Google_Cloud_Translation_V3_AdaptiveMtDataset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdaptiveMtDataset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "source_language_code"),
    4: .standard(proto: "target_language_code"),
    5: .standard(proto: "example_count"),
    9: .standard(proto: "create_time"),
    10: .standard(proto: "update_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetLanguageCode) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.exampleCount) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 3)
    }
    if !self.targetLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.targetLanguageCode, fieldNumber: 4)
    }
    if self.exampleCount != 0 {
      try visitor.visitSingularInt32Field(value: self.exampleCount, fieldNumber: 5)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtDataset, rhs: Google_Cloud_Translation_V3_AdaptiveMtDataset) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.targetLanguageCode != rhs.targetLanguageCode {return false}
    if lhs.exampleCount != rhs.exampleCount {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_CreateAdaptiveMtDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAdaptiveMtDatasetRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "adaptive_mt_dataset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._adaptiveMtDataset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._adaptiveMtDataset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_CreateAdaptiveMtDatasetRequest, rhs: Google_Cloud_Translation_V3_CreateAdaptiveMtDatasetRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._adaptiveMtDataset != rhs._adaptiveMtDataset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DeleteAdaptiveMtDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAdaptiveMtDatasetRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DeleteAdaptiveMtDatasetRequest, rhs: Google_Cloud_Translation_V3_DeleteAdaptiveMtDatasetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GetAdaptiveMtDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAdaptiveMtDatasetRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GetAdaptiveMtDatasetRequest, rhs: Google_Cloud_Translation_V3_GetAdaptiveMtDatasetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAdaptiveMtDatasetsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsRequest, rhs: Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAdaptiveMtDatasetsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adaptive_mt_datasets"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.adaptiveMtDatasets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adaptiveMtDatasets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.adaptiveMtDatasets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsResponse, rhs: Google_Cloud_Translation_V3_ListAdaptiveMtDatasetsResponse) -> Bool {
    if lhs.adaptiveMtDatasets != rhs.adaptiveMtDatasets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdaptiveMtTranslateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "dataset"),
    3: .same(proto: "content"),
    6: .standard(proto: "reference_sentence_config"),
    7: .standard(proto: "glossary_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dataset) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.content) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._referenceSentenceConfig) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._glossaryConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.dataset.isEmpty {
      try visitor.visitSingularStringField(value: self.dataset, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitRepeatedStringField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._referenceSentenceConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._glossaryConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest, rhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.dataset != rhs.dataset {return false}
    if lhs.content != rhs.content {return false}
    if lhs._referenceSentenceConfig != rhs._referenceSentenceConfig {return false}
    if lhs._glossaryConfig != rhs._glossaryConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.protoMessageName + ".ReferenceSentencePair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_sentence"),
    2: .standard(proto: "target_sentence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceSentence) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetSentence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceSentence.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSentence, fieldNumber: 1)
    }
    if !self.targetSentence.isEmpty {
      try visitor.visitSingularStringField(value: self.targetSentence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePair, rhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePair) -> Bool {
    if lhs.sourceSentence != rhs.sourceSentence {return false}
    if lhs.targetSentence != rhs.targetSentence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePairList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.protoMessageName + ".ReferenceSentencePairList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_sentence_pairs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.referenceSentencePairs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceSentencePairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referenceSentencePairs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePairList, rhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentencePairList) -> Bool {
    if lhs.referenceSentencePairs != rhs.referenceSentencePairs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentenceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.protoMessageName + ".ReferenceSentenceConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_sentence_pair_lists"),
    2: .standard(proto: "source_language_code"),
    3: .standard(proto: "target_language_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.referenceSentencePairLists) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetLanguageCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceSentencePairLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referenceSentencePairLists, fieldNumber: 1)
    }
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 2)
    }
    if !self.targetLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.targetLanguageCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentenceConfig, rhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.ReferenceSentenceConfig) -> Bool {
    if lhs.referenceSentencePairLists != rhs.referenceSentencePairLists {return false}
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.targetLanguageCode != rhs.targetLanguageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.GlossaryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.protoMessageName + ".GlossaryConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "glossary"),
    2: .standard(proto: "ignore_case"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.glossary) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ignoreCase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.glossary.isEmpty {
      try visitor.visitSingularStringField(value: self.glossary, fieldNumber: 1)
    }
    if self.ignoreCase != false {
      try visitor.visitSingularBoolField(value: self.ignoreCase, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.GlossaryConfig, rhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateRequest.GlossaryConfig) -> Bool {
    if lhs.glossary != rhs.glossary {return false}
    if lhs.ignoreCase != rhs.ignoreCase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtTranslation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdaptiveMtTranslation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "translated_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.translatedText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translatedText.isEmpty {
      try visitor.visitSingularStringField(value: self.translatedText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtTranslation, rhs: Google_Cloud_Translation_V3_AdaptiveMtTranslation) -> Bool {
    if lhs.translatedText != rhs.translatedText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtTranslateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdaptiveMtTranslateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "translations"),
    2: .standard(proto: "language_code"),
    4: .standard(proto: "glossary_translations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.translations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.glossaryTranslations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.translations, fieldNumber: 1)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 2)
    }
    if !self.glossaryTranslations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.glossaryTranslations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateResponse, rhs: Google_Cloud_Translation_V3_AdaptiveMtTranslateResponse) -> Bool {
    if lhs.translations != rhs.translations {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.glossaryTranslations != rhs.glossaryTranslations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdaptiveMtFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "entry_count"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.entryCount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if self.entryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.entryCount, fieldNumber: 3)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtFile, rhs: Google_Cloud_Translation_V3_AdaptiveMtFile) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.entryCount != rhs.entryCount {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GetAdaptiveMtFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAdaptiveMtFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GetAdaptiveMtFileRequest, rhs: Google_Cloud_Translation_V3_GetAdaptiveMtFileRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DeleteAdaptiveMtFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAdaptiveMtFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DeleteAdaptiveMtFileRequest, rhs: Google_Cloud_Translation_V3_DeleteAdaptiveMtFileRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ImportAdaptiveMtFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportAdaptiveMtFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "file_input_source"),
    3: .standard(proto: "gcs_input_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Cloud_Translation_V3_FileInputSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .fileInputSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .fileInputSource(v)
        }
      }()
      case 3: try {
        var v: Google_Cloud_Translation_V3_GcsInputSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .gcsInputSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .gcsInputSource(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    switch self.source {
    case .fileInputSource?: try {
      guard case .fileInputSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .gcsInputSource?: try {
      guard case .gcsInputSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ImportAdaptiveMtFileRequest, rhs: Google_Cloud_Translation_V3_ImportAdaptiveMtFileRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ImportAdaptiveMtFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportAdaptiveMtFileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adaptive_mt_file"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._adaptiveMtFile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._adaptiveMtFile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ImportAdaptiveMtFileResponse, rhs: Google_Cloud_Translation_V3_ImportAdaptiveMtFileResponse) -> Bool {
    if lhs._adaptiveMtFile != rhs._adaptiveMtFile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListAdaptiveMtFilesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAdaptiveMtFilesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListAdaptiveMtFilesRequest, rhs: Google_Cloud_Translation_V3_ListAdaptiveMtFilesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListAdaptiveMtFilesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAdaptiveMtFilesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adaptive_mt_files"),
    3: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.adaptiveMtFiles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adaptiveMtFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.adaptiveMtFiles, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListAdaptiveMtFilesResponse, rhs: Google_Cloud_Translation_V3_ListAdaptiveMtFilesResponse) -> Bool {
    if lhs.adaptiveMtFiles != rhs.adaptiveMtFiles {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_AdaptiveMtSentence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdaptiveMtSentence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "source_sentence"),
    3: .standard(proto: "target_sentence"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSentence) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetSentence) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.sourceSentence.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSentence, fieldNumber: 2)
    }
    if !self.targetSentence.isEmpty {
      try visitor.visitSingularStringField(value: self.targetSentence, fieldNumber: 3)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_AdaptiveMtSentence, rhs: Google_Cloud_Translation_V3_AdaptiveMtSentence) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sourceSentence != rhs.sourceSentence {return false}
    if lhs.targetSentence != rhs.targetSentence {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListAdaptiveMtSentencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAdaptiveMtSentencesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListAdaptiveMtSentencesRequest, rhs: Google_Cloud_Translation_V3_ListAdaptiveMtSentencesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListAdaptiveMtSentencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAdaptiveMtSentencesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adaptive_mt_sentences"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.adaptiveMtSentences) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adaptiveMtSentences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.adaptiveMtSentences, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListAdaptiveMtSentencesResponse, rhs: Google_Cloud_Translation_V3_ListAdaptiveMtSentencesResponse) -> Bool {
    if lhs.adaptiveMtSentences != rhs.adaptiveMtSentences {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
