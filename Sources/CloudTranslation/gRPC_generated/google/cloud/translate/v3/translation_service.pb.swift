// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/translate/v3/translation_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configures transliteration feature on top of translation.
struct Google_Cloud_Translation_V3_TransliterationConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, source text in romanized form can be translated to the target
  /// language.
  var enableTransliteration: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request message for synchronous translation.
struct Google_Cloud_Translation_V3_TranslateTextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The content of the input in string format.
  /// We recommend the total content be less than 30,000 codepoints. The max
  /// length of this field is 1024. Use BatchTranslateText for larger text.
  var contents: [String] = []

  /// Optional. The format of the source text, for example, "text/html",
  ///  "text/plain". If left blank, the MIME type defaults to "text/html".
  var mimeType: String = String()

  /// Optional. The ISO-639 language code of the input text if
  /// known, for example, "en-US" or "sr-Latn". Supported language codes are
  /// listed in Language Support. If the source language isn't specified, the API
  /// attempts to identify the source language automatically and returns the
  /// source language within the response.
  var sourceLanguageCode: String = String()

  /// Required. The ISO-639 language code to use for translation of the input
  /// text, set to one of the language codes listed in Language Support.
  var targetLanguageCode: String = String()

  /// Required. Project or location to make a call. Must refer to a caller's
  /// project.
  ///
  /// Format: `projects/{project-number-or-id}` or
  /// `projects/{project-number-or-id}/locations/{location-id}`.
  ///
  /// For global calls, use `projects/{project-number-or-id}/locations/global` or
  /// `projects/{project-number-or-id}`.
  ///
  /// Non-global location is required for requests using AutoML models or
  /// custom glossaries.
  ///
  /// Models and glossaries must be within the same region (have same
  /// location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
  var parent: String = String()

  /// Optional. The `model` type requested for this translation.
  ///
  /// The format depends on model type:
  ///
  /// - AutoML Translation models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
  ///
  /// - General (built-in) models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
  ///
  /// - Translation LLM models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/translation-llm`,
  ///
  /// For global (non-regionalized) requests, use `location-id` `global`.
  /// For example,
  /// `projects/{project-number-or-id}/locations/global/models/general/nmt`.
  ///
  /// If not provided, the default Google model (NMT) will be used
  var model: String = String()

  /// Optional. Glossary to be applied. The glossary must be
  /// within the same region (have the same location-id) as the model, otherwise
  /// an INVALID_ARGUMENT (400) error is returned.
  var glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig {
    get {return _glossaryConfig ?? Google_Cloud_Translation_V3_TranslateTextGlossaryConfig()}
    set {_glossaryConfig = newValue}
  }
  /// Returns true if `glossaryConfig` has been explicitly set.
  var hasGlossaryConfig: Bool {return self._glossaryConfig != nil}
  /// Clears the value of `glossaryConfig`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryConfig() {self._glossaryConfig = nil}

  /// Optional. Transliteration to be applied.
  var transliterationConfig: Google_Cloud_Translation_V3_TransliterationConfig {
    get {return _transliterationConfig ?? Google_Cloud_Translation_V3_TransliterationConfig()}
    set {_transliterationConfig = newValue}
  }
  /// Returns true if `transliterationConfig` has been explicitly set.
  var hasTransliterationConfig: Bool {return self._transliterationConfig != nil}
  /// Clears the value of `transliterationConfig`. Subsequent reads from it will return its default value.
  mutating func clearTransliterationConfig() {self._transliterationConfig = nil}

  /// Optional. The labels with user-defined metadata for the request.
  ///
  /// Label keys and values can be no longer than 63 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// Label values are optional. Label keys must start with a letter.
  ///
  /// See https://cloud.google.com/translate/docs/advanced/labels for more
  /// information.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig? = nil
  fileprivate var _transliterationConfig: Google_Cloud_Translation_V3_TransliterationConfig? = nil
}

struct Google_Cloud_Translation_V3_TranslateTextResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text translation responses with no glossary applied.
  /// This field has the same length as
  /// [`contents`][google.cloud.translation.v3.TranslateTextRequest.contents].
  var translations: [Google_Cloud_Translation_V3_Translation] = []

  /// Text translation responses if a glossary is provided in the request.
  /// This can be the same as
  /// [`translations`][google.cloud.translation.v3.TranslateTextResponse.translations]
  /// if no terms apply. This field has the same length as
  /// [`contents`][google.cloud.translation.v3.TranslateTextRequest.contents].
  var glossaryTranslations: [Google_Cloud_Translation_V3_Translation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A single translation response.
struct Google_Cloud_Translation_V3_Translation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text translated into the target language.
  /// If an error occurs during translation, this field might be excluded from
  /// the response.
  var translatedText: String = String()

  /// Only present when `model` is present in the request.
  /// `model` here is normalized to have project number.
  ///
  /// For example:
  /// If the `model` requested in TranslationTextRequest is
  /// `projects/{project-id}/locations/{location-id}/models/general/nmt` then
  /// `model` here would be normalized to
  /// `projects/{project-number}/locations/{location-id}/models/general/nmt`.
  var model: String = String()

  /// The ISO-639 language code of source text in the initial request, detected
  /// automatically, if no source language was passed within the initial
  /// request. If the source language was passed, auto-detection of the language
  /// does not occur and this field is empty.
  var detectedLanguageCode: String = String()

  /// The `glossary_config` used for this translation.
  var glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig {
    get {return _glossaryConfig ?? Google_Cloud_Translation_V3_TranslateTextGlossaryConfig()}
    set {_glossaryConfig = newValue}
  }
  /// Returns true if `glossaryConfig` has been explicitly set.
  var hasGlossaryConfig: Bool {return self._glossaryConfig != nil}
  /// Clears the value of `glossaryConfig`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryConfig() {self._glossaryConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig? = nil
}

/// The request message for synchronous romanization.
struct Google_Cloud_Translation_V3_RomanizeTextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Project or location to make a call. Must refer to a caller's
  /// project.
  ///
  /// Format: `projects/{project-number-or-id}/locations/{location-id}` or
  /// `projects/{project-number-or-id}`.
  ///
  /// For global calls, use `projects/{project-number-or-id}/locations/global` or
  /// `projects/{project-number-or-id}`.
  var parent: String = String()

  /// Required. The content of the input in string format.
  var contents: [String] = []

  /// Optional. The ISO-639 language code of the input text if
  /// known, for example, "hi" or "zh". If the source language isn't specified,
  /// the API attempts to identify the source language automatically and returns
  /// the source language for each content in the response.
  var sourceLanguageCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A single romanization response.
struct Google_Cloud_Translation_V3_Romanization: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Romanized text.
  /// If an error occurs during romanization, this field might be excluded from
  /// the response.
  var romanizedText: String = String()

  /// The ISO-639 language code of source text in the initial request, detected
  /// automatically, if no source language was passed within the initial
  /// request. If the source language was passed, auto-detection of the language
  /// does not occur and this field is empty.
  var detectedLanguageCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response message for synchronous romanization.
struct Google_Cloud_Translation_V3_RomanizeTextResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text romanization responses.
  /// This field has the same length as
  /// [`contents`][google.cloud.translation.v3.RomanizeTextRequest.contents].
  var romanizations: [Google_Cloud_Translation_V3_Romanization] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request message for language detection.
struct Google_Cloud_Translation_V3_DetectLanguageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Project or location to make a call. Must refer to a caller's
  /// project.
  ///
  /// Format: `projects/{project-number-or-id}/locations/{location-id}` or
  /// `projects/{project-number-or-id}`.
  ///
  /// For global calls, use `projects/{project-number-or-id}/locations/global` or
  /// `projects/{project-number-or-id}`.
  ///
  /// Only models within the same region (has same location-id) can be used.
  /// Otherwise an INVALID_ARGUMENT (400) error is returned.
  var parent: String = String()

  /// Optional. The language detection model to be used.
  ///
  /// Format:
  /// `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/{model-id}`
  ///
  /// Only one language detection model is currently supported:
  /// `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/default`.
  ///
  /// If not specified, the default model is used.
  var model: String = String()

  /// Required. The source of the document from which to detect the language.
  var source: Google_Cloud_Translation_V3_DetectLanguageRequest.OneOf_Source? = nil

  /// The content of the input stored as a string.
  var content: String {
    get {
      if case .content(let v)? = source {return v}
      return String()
    }
    set {source = .content(newValue)}
  }

  /// Optional. The format of the source text, for example, "text/html",
  /// "text/plain". If left blank, the MIME type defaults to "text/html".
  var mimeType: String = String()

  /// Optional. The labels with user-defined metadata for the request.
  ///
  /// Label keys and values can be no longer than 63 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// Label values are optional. Label keys must start with a letter.
  ///
  /// See https://cloud.google.com/translate/docs/advanced/labels for more
  /// information.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The source of the document from which to detect the language.
  enum OneOf_Source: Equatable, Sendable {
    /// The content of the input stored as a string.
    case content(String)

  }

  init() {}
}

/// The response message for language detection.
struct Google_Cloud_Translation_V3_DetectedLanguage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ISO-639 language code of the source content in the request, detected
  /// automatically.
  var languageCode: String = String()

  /// The confidence of the detection result for this language.
  var confidence: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response message for language detection.
struct Google_Cloud_Translation_V3_DetectLanguageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The most probable language detected by the Translation API. For each
  /// request, the Translation API will always return only one result.
  var languages: [Google_Cloud_Translation_V3_DetectedLanguage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request message for discovering supported languages.
struct Google_Cloud_Translation_V3_GetSupportedLanguagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Project or location to make a call. Must refer to a caller's
  /// project.
  ///
  /// Format: `projects/{project-number-or-id}` or
  /// `projects/{project-number-or-id}/locations/{location-id}`.
  ///
  /// For global calls, use `projects/{project-number-or-id}/locations/global` or
  /// `projects/{project-number-or-id}`.
  ///
  /// Non-global location is required for AutoML models.
  ///
  /// Only models within the same region (have same location-id) can be used,
  /// otherwise an INVALID_ARGUMENT (400) error is returned.
  var parent: String = String()

  /// Optional. The language to use to return localized, human readable names
  /// of supported languages. If missing, then display names are not returned
  /// in a response.
  var displayLanguageCode: String = String()

  /// Optional. Get supported languages of this model.
  ///
  /// The format depends on model type:
  ///
  /// - AutoML Translation models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
  ///
  /// - General (built-in) models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
  ///
  ///
  /// Returns languages supported by the specified model.
  /// If missing, we get supported languages of Google general NMT model.
  var model: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response message for discovering supported languages.
struct Google_Cloud_Translation_V3_SupportedLanguages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of supported language responses. This list contains an entry
  /// for each language the Translation API supports.
  var languages: [Google_Cloud_Translation_V3_SupportedLanguage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A single supported language response corresponds to information related
/// to one supported language.
struct Google_Cloud_Translation_V3_SupportedLanguage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supported language code, generally consisting of its ISO 639-1
  /// identifier, for example, 'en', 'ja'. In certain cases, ISO-639 codes
  /// including language and region identifiers are returned (for example,
  /// 'zh-TW' and 'zh-CN').
  var languageCode: String = String()

  /// Human-readable name of the language localized in the display language
  /// specified in the request.
  var displayName: String = String()

  /// Can be used as a source language.
  var supportSource: Bool = false

  /// Can be used as a target language.
  var supportTarget: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The Google Cloud Storage location for the input content.
struct Google_Cloud_Translation_V3_GcsSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Source data URI. For example, `gs://my_bucket/my_object`.
  var inputUri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Input configuration for BatchTranslateText request.
struct Google_Cloud_Translation_V3_InputConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Can be "text/plain" or "text/html".
  /// For `.tsv`, "text/html" is used if mime_type is missing.
  /// For `.html`, this field must be "text/html" or empty.
  /// For `.txt`, this field must be "text/plain" or empty.
  var mimeType: String = String()

  /// Required. Specify the input.
  var source: Google_Cloud_Translation_V3_InputConfig.OneOf_Source? = nil

  /// Required. Google Cloud Storage location for the source input.
  /// This can be a single file (for example,
  /// `gs://translation-test/input.tsv`) or a wildcard (for example,
  /// `gs://translation-test/*`). If a file extension is `.tsv`, it can
  /// contain either one or two columns. The first column (optional) is the id
  /// of the text request. If the first column is missing, we use the row
  /// number (0-based) from the input file as the ID in the output file. The
  /// second column is the actual text to be
  ///  translated. We recommend each row be <= 10K Unicode codepoints,
  /// otherwise an error might be returned.
  /// Note that the input tsv must be RFC 4180 compliant.
  ///
  /// You could use https://github.com/Clever/csvlint to check potential
  /// formatting errors in your tsv file.
  /// csvlint --delimiter='\t' your_input_file.tsv
  ///
  /// The other supported file extensions are `.txt` or `.html`, which is
  /// treated as a single large chunk of text.
  var gcsSource: Google_Cloud_Translation_V3_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Translation_V3_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Specify the input.
  enum OneOf_Source: Equatable, Sendable {
    /// Required. Google Cloud Storage location for the source input.
    /// This can be a single file (for example,
    /// `gs://translation-test/input.tsv`) or a wildcard (for example,
    /// `gs://translation-test/*`). If a file extension is `.tsv`, it can
    /// contain either one or two columns. The first column (optional) is the id
    /// of the text request. If the first column is missing, we use the row
    /// number (0-based) from the input file as the ID in the output file. The
    /// second column is the actual text to be
    ///  translated. We recommend each row be <= 10K Unicode codepoints,
    /// otherwise an error might be returned.
    /// Note that the input tsv must be RFC 4180 compliant.
    ///
    /// You could use https://github.com/Clever/csvlint to check potential
    /// formatting errors in your tsv file.
    /// csvlint --delimiter='\t' your_input_file.tsv
    ///
    /// The other supported file extensions are `.txt` or `.html`, which is
    /// treated as a single large chunk of text.
    case gcsSource(Google_Cloud_Translation_V3_GcsSource)

  }

  init() {}
}

/// The Google Cloud Storage location for the output content.
struct Google_Cloud_Translation_V3_GcsDestination: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The bucket used in 'output_uri_prefix' must exist and there must
  /// be no files under 'output_uri_prefix'. 'output_uri_prefix' must end with
  /// "/" and start with "gs://". One 'output_uri_prefix' can only be used by one
  /// batch translation job at a time. Otherwise an INVALID_ARGUMENT (400) error
  /// is returned.
  var outputUriPrefix: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Output configuration for BatchTranslateText request.
struct Google_Cloud_Translation_V3_OutputConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The destination of output.
  var destination: Google_Cloud_Translation_V3_OutputConfig.OneOf_Destination? = nil

  /// Google Cloud Storage destination for output content.
  /// For every single input file (for example, gs://a/b/c.[extension]), we
  /// generate at most 2 * n output files. (n is the # of target_language_codes
  /// in the BatchTranslateTextRequest).
  ///
  /// Output files (tsv) generated are compliant with RFC 4180 except that
  /// record delimiters are '\n' instead of '\r\n'. We don't provide any way to
  /// change record delimiters.
  ///
  /// While the input files are being processed, we write/update an index file
  /// 'index.csv'  under 'output_uri_prefix' (for example,
  /// gs://translation-test/index.csv) The index file is generated/updated as
  /// new files are being translated. The format is:
  ///
  /// input_file,target_language_code,translations_file,errors_file,
  /// glossary_translations_file,glossary_errors_file
  ///
  /// input_file is one file we matched using gcs_source.input_uri.
  /// target_language_code is provided in the request.
  /// translations_file contains the translations. (details provided below)
  /// errors_file contains the errors during processing of the file. (details
  /// below). Both translations_file and errors_file could be empty
  /// strings if we have no content to output.
  /// glossary_translations_file and glossary_errors_file are always empty
  /// strings if the input_file is tsv. They could also be empty if we have no
  /// content to output.
  ///
  /// Once a row is present in index.csv, the input/output matching never
  /// changes. Callers should also expect all the content in input_file are
  /// processed and ready to be consumed (that is, no partial output file is
  /// written).
  ///
  /// Since index.csv will be keeping updated during the process, please make
  /// sure there is no custom retention policy applied on the output bucket
  /// that may avoid file updating.
  /// (https://cloud.google.com/storage/docs/bucket-lock#retention-policy)
  ///
  /// The format of translations_file (for target language code 'trg') is:
  /// `gs://translation_test/a_b_c_'trg'_translations.[extension]`
  ///
  /// If the input file extension is tsv, the output has the following
  /// columns:
  /// Column 1: ID of the request provided in the input, if it's not
  /// provided in the input, then the input row number is used (0-based).
  /// Column 2: source sentence.
  /// Column 3: translation without applying a glossary. Empty string if there
  /// is an error.
  /// Column 4 (only present if a glossary is provided in the request):
  /// translation after applying the glossary. Empty string if there is an
  /// error applying the glossary. Could be same string as column 3 if there is
  /// no glossary applied.
  ///
  /// If input file extension is a txt or html, the translation is directly
  /// written to the output file. If glossary is requested, a separate
  /// glossary_translations_file has format of
  /// `gs://translation_test/a_b_c_'trg'_glossary_translations.[extension]`
  ///
  /// The format of errors file (for target language code 'trg') is:
  /// `gs://translation_test/a_b_c_'trg'_errors.[extension]`
  ///
  /// If the input file extension is tsv, errors_file contains the following:
  /// Column 1: ID of the request provided in the input, if it's not
  /// provided in the input, then the input row number is used (0-based).
  /// Column 2: source sentence.
  /// Column 3: Error detail for the translation. Could be empty.
  /// Column 4 (only present if a glossary is provided in the request):
  /// Error when applying the glossary.
  ///
  /// If the input file extension is txt or html, glossary_error_file will be
  /// generated that contains error details. glossary_error_file has format of
  /// `gs://translation_test/a_b_c_'trg'_glossary_errors.[extension]`
  var gcsDestination: Google_Cloud_Translation_V3_GcsDestination {
    get {
      if case .gcsDestination(let v)? = destination {return v}
      return Google_Cloud_Translation_V3_GcsDestination()
    }
    set {destination = .gcsDestination(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The destination of output.
  enum OneOf_Destination: Equatable, Sendable {
    /// Google Cloud Storage destination for output content.
    /// For every single input file (for example, gs://a/b/c.[extension]), we
    /// generate at most 2 * n output files. (n is the # of target_language_codes
    /// in the BatchTranslateTextRequest).
    ///
    /// Output files (tsv) generated are compliant with RFC 4180 except that
    /// record delimiters are '\n' instead of '\r\n'. We don't provide any way to
    /// change record delimiters.
    ///
    /// While the input files are being processed, we write/update an index file
    /// 'index.csv'  under 'output_uri_prefix' (for example,
    /// gs://translation-test/index.csv) The index file is generated/updated as
    /// new files are being translated. The format is:
    ///
    /// input_file,target_language_code,translations_file,errors_file,
    /// glossary_translations_file,glossary_errors_file
    ///
    /// input_file is one file we matched using gcs_source.input_uri.
    /// target_language_code is provided in the request.
    /// translations_file contains the translations. (details provided below)
    /// errors_file contains the errors during processing of the file. (details
    /// below). Both translations_file and errors_file could be empty
    /// strings if we have no content to output.
    /// glossary_translations_file and glossary_errors_file are always empty
    /// strings if the input_file is tsv. They could also be empty if we have no
    /// content to output.
    ///
    /// Once a row is present in index.csv, the input/output matching never
    /// changes. Callers should also expect all the content in input_file are
    /// processed and ready to be consumed (that is, no partial output file is
    /// written).
    ///
    /// Since index.csv will be keeping updated during the process, please make
    /// sure there is no custom retention policy applied on the output bucket
    /// that may avoid file updating.
    /// (https://cloud.google.com/storage/docs/bucket-lock#retention-policy)
    ///
    /// The format of translations_file (for target language code 'trg') is:
    /// `gs://translation_test/a_b_c_'trg'_translations.[extension]`
    ///
    /// If the input file extension is tsv, the output has the following
    /// columns:
    /// Column 1: ID of the request provided in the input, if it's not
    /// provided in the input, then the input row number is used (0-based).
    /// Column 2: source sentence.
    /// Column 3: translation without applying a glossary. Empty string if there
    /// is an error.
    /// Column 4 (only present if a glossary is provided in the request):
    /// translation after applying the glossary. Empty string if there is an
    /// error applying the glossary. Could be same string as column 3 if there is
    /// no glossary applied.
    ///
    /// If input file extension is a txt or html, the translation is directly
    /// written to the output file. If glossary is requested, a separate
    /// glossary_translations_file has format of
    /// `gs://translation_test/a_b_c_'trg'_glossary_translations.[extension]`
    ///
    /// The format of errors file (for target language code 'trg') is:
    /// `gs://translation_test/a_b_c_'trg'_errors.[extension]`
    ///
    /// If the input file extension is tsv, errors_file contains the following:
    /// Column 1: ID of the request provided in the input, if it's not
    /// provided in the input, then the input row number is used (0-based).
    /// Column 2: source sentence.
    /// Column 3: Error detail for the translation. Could be empty.
    /// Column 4 (only present if a glossary is provided in the request):
    /// Error when applying the glossary.
    ///
    /// If the input file extension is txt or html, glossary_error_file will be
    /// generated that contains error details. glossary_error_file has format of
    /// `gs://translation_test/a_b_c_'trg'_glossary_errors.[extension]`
    case gcsDestination(Google_Cloud_Translation_V3_GcsDestination)

  }

  init() {}
}

/// A document translation request input config.
struct Google_Cloud_Translation_V3_DocumentInputConfig: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the source for the document's content.
  /// The input file size should be <= 20MB for
  /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
  /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
  /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
  /// The input file size should be <= 20MB and the maximum page limit is 20 for
  /// - application/pdf
  var source: Google_Cloud_Translation_V3_DocumentInputConfig.OneOf_Source? = nil

  /// Document's content represented as a stream of bytes.
  var content: Data {
    get {
      if case .content(let v)? = source {return v}
      return Data()
    }
    set {source = .content(newValue)}
  }

  /// Google Cloud Storage location. This must be a single file.
  /// For example: gs://example_bucket/example_file.pdf
  var gcsSource: Google_Cloud_Translation_V3_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Translation_V3_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  /// Specifies the input document's mime_type.
  ///
  /// If not specified it will be determined using the file extension for
  /// gcs_source provided files. For a file provided through bytes content the
  /// mime_type must be provided.
  /// Currently supported mime types are:
  /// - application/pdf
  /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
  /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
  /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
  var mimeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the source for the document's content.
  /// The input file size should be <= 20MB for
  /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
  /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
  /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
  /// The input file size should be <= 20MB and the maximum page limit is 20 for
  /// - application/pdf
  enum OneOf_Source: Equatable, @unchecked Sendable {
    /// Document's content represented as a stream of bytes.
    case content(Data)
    /// Google Cloud Storage location. This must be a single file.
    /// For example: gs://example_bucket/example_file.pdf
    case gcsSource(Google_Cloud_Translation_V3_GcsSource)

  }

  init() {}
}

/// A document translation request output config.
struct Google_Cloud_Translation_V3_DocumentOutputConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A URI destination for the translated document.
  /// It is optional to provide a destination. If provided the results from
  /// TranslateDocument will be stored in the destination.
  /// Whether a destination is provided or not, the translated documents will be
  /// returned within TranslateDocumentResponse.document_translation and
  /// TranslateDocumentResponse.glossary_document_translation.
  var destination: Google_Cloud_Translation_V3_DocumentOutputConfig.OneOf_Destination? = nil

  /// Optional. Google Cloud Storage destination for the translation output,
  /// e.g., `gs://my_bucket/my_directory/`.
  ///
  /// The destination directory provided does not have to be empty, but the
  /// bucket must exist. If a file with the same name as the output file
  /// already exists in the destination an error will be returned.
  ///
  /// For a DocumentInputConfig.contents provided document, the output file
  /// will have the name "output_[trg]_translations.[ext]", where
  /// - [trg] corresponds to the translated file's language code,
  /// - [ext] corresponds to the translated file's extension according to its
  /// mime type.
  ///
  ///
  /// For a DocumentInputConfig.gcs_uri provided document, the output file will
  /// have a name according to its URI. For example: an input file with URI:
  /// `gs://a/b/c.[extension]` stored in a gcs_destination bucket with name
  /// "my_bucket" will have an output URI:
  /// `gs://my_bucket/a_b_c_[trg]_translations.[ext]`, where
  /// - [trg] corresponds to the translated file's language code,
  /// - [ext] corresponds to the translated file's extension according to its
  /// mime type.
  ///
  ///
  /// If the document was directly provided through the request, then the
  /// output document will have the format:
  /// `gs://my_bucket/translated_document_[trg]_translations.[ext]`, where
  /// - [trg] corresponds to the translated file's language code,
  /// - [ext] corresponds to the translated file's extension according to its
  /// mime type.
  ///
  /// If a glossary was provided, then the output URI for the glossary
  /// translation will be equal to the default output URI but have
  /// `glossary_translations` instead of `translations`. For the previous
  /// example, its glossary URI would be:
  /// `gs://my_bucket/a_b_c_[trg]_glossary_translations.[ext]`.
  ///
  /// Thus the max number of output files will be 2 (Translated document,
  /// Glossary translated document).
  ///
  /// Callers should expect no partial outputs. If there is any error during
  /// document translation, no output will be stored in the Cloud Storage
  /// bucket.
  var gcsDestination: Google_Cloud_Translation_V3_GcsDestination {
    get {
      if case .gcsDestination(let v)? = destination {return v}
      return Google_Cloud_Translation_V3_GcsDestination()
    }
    set {destination = .gcsDestination(newValue)}
  }

  /// Optional. Specifies the translated document's mime_type.
  /// If not specified, the translated file's mime type will be the same as the
  /// input file's mime type.
  /// Currently only support the output mime type to be the same as input mime
  /// type.
  /// - application/pdf
  /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
  /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
  /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
  var mimeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A URI destination for the translated document.
  /// It is optional to provide a destination. If provided the results from
  /// TranslateDocument will be stored in the destination.
  /// Whether a destination is provided or not, the translated documents will be
  /// returned within TranslateDocumentResponse.document_translation and
  /// TranslateDocumentResponse.glossary_document_translation.
  enum OneOf_Destination: Equatable, Sendable {
    /// Optional. Google Cloud Storage destination for the translation output,
    /// e.g., `gs://my_bucket/my_directory/`.
    ///
    /// The destination directory provided does not have to be empty, but the
    /// bucket must exist. If a file with the same name as the output file
    /// already exists in the destination an error will be returned.
    ///
    /// For a DocumentInputConfig.contents provided document, the output file
    /// will have the name "output_[trg]_translations.[ext]", where
    /// - [trg] corresponds to the translated file's language code,
    /// - [ext] corresponds to the translated file's extension according to its
    /// mime type.
    ///
    ///
    /// For a DocumentInputConfig.gcs_uri provided document, the output file will
    /// have a name according to its URI. For example: an input file with URI:
    /// `gs://a/b/c.[extension]` stored in a gcs_destination bucket with name
    /// "my_bucket" will have an output URI:
    /// `gs://my_bucket/a_b_c_[trg]_translations.[ext]`, where
    /// - [trg] corresponds to the translated file's language code,
    /// - [ext] corresponds to the translated file's extension according to its
    /// mime type.
    ///
    ///
    /// If the document was directly provided through the request, then the
    /// output document will have the format:
    /// `gs://my_bucket/translated_document_[trg]_translations.[ext]`, where
    /// - [trg] corresponds to the translated file's language code,
    /// - [ext] corresponds to the translated file's extension according to its
    /// mime type.
    ///
    /// If a glossary was provided, then the output URI for the glossary
    /// translation will be equal to the default output URI but have
    /// `glossary_translations` instead of `translations`. For the previous
    /// example, its glossary URI would be:
    /// `gs://my_bucket/a_b_c_[trg]_glossary_translations.[ext]`.
    ///
    /// Thus the max number of output files will be 2 (Translated document,
    /// Glossary translated document).
    ///
    /// Callers should expect no partial outputs. If there is any error during
    /// document translation, no output will be stored in the Cloud Storage
    /// bucket.
    case gcsDestination(Google_Cloud_Translation_V3_GcsDestination)

  }

  init() {}
}

/// A document translation request.
struct Google_Cloud_Translation_V3_TranslateDocumentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Location to make a regional call.
  ///
  /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
  ///
  /// For global calls, use `projects/{project-number-or-id}/locations/global` or
  /// `projects/{project-number-or-id}`.
  ///
  /// Non-global location is required for requests using AutoML models or custom
  /// glossaries.
  ///
  /// Models and glossaries must be within the same region (have the same
  /// location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
  var parent: String = String()

  /// Optional. The ISO-639 language code of the input document if known, for
  /// example, "en-US" or "sr-Latn". Supported language codes are listed in
  /// Language Support. If the source language isn't specified, the API attempts
  /// to identify the source language automatically and returns the source
  /// language within the response. Source language must be specified if the
  /// request contains a glossary or a custom model.
  var sourceLanguageCode: String = String()

  /// Required. The ISO-639 language code to use for translation of the input
  /// document, set to one of the language codes listed in Language Support.
  var targetLanguageCode: String = String()

  /// Required. Input configurations.
  var documentInputConfig: Google_Cloud_Translation_V3_DocumentInputConfig {
    get {return _documentInputConfig ?? Google_Cloud_Translation_V3_DocumentInputConfig()}
    set {_documentInputConfig = newValue}
  }
  /// Returns true if `documentInputConfig` has been explicitly set.
  var hasDocumentInputConfig: Bool {return self._documentInputConfig != nil}
  /// Clears the value of `documentInputConfig`. Subsequent reads from it will return its default value.
  mutating func clearDocumentInputConfig() {self._documentInputConfig = nil}

  /// Optional. Output configurations.
  /// Defines if the output file should be stored within Cloud Storage as well
  /// as the desired output format. If not provided the translated file will
  /// only be returned through a byte-stream and its output mime type will be
  /// the same as the input file's mime type.
  var documentOutputConfig: Google_Cloud_Translation_V3_DocumentOutputConfig {
    get {return _documentOutputConfig ?? Google_Cloud_Translation_V3_DocumentOutputConfig()}
    set {_documentOutputConfig = newValue}
  }
  /// Returns true if `documentOutputConfig` has been explicitly set.
  var hasDocumentOutputConfig: Bool {return self._documentOutputConfig != nil}
  /// Clears the value of `documentOutputConfig`. Subsequent reads from it will return its default value.
  mutating func clearDocumentOutputConfig() {self._documentOutputConfig = nil}

  /// Optional. The `model` type requested for this translation.
  ///
  /// The format depends on model type:
  ///
  /// - AutoML Translation models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
  ///
  /// - General (built-in) models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
  ///
  ///
  /// If not provided, the default Google model (NMT) will be used for
  /// translation.
  var model: String = String()

  /// Optional. Glossary to be applied. The glossary must be within the same
  /// region (have the same location-id) as the model, otherwise an
  /// INVALID_ARGUMENT (400) error is returned.
  var glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig {
    get {return _glossaryConfig ?? Google_Cloud_Translation_V3_TranslateTextGlossaryConfig()}
    set {_glossaryConfig = newValue}
  }
  /// Returns true if `glossaryConfig` has been explicitly set.
  var hasGlossaryConfig: Bool {return self._glossaryConfig != nil}
  /// Clears the value of `glossaryConfig`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryConfig() {self._glossaryConfig = nil}

  /// Optional. The labels with user-defined metadata for the request.
  ///
  /// Label keys and values can be no longer than 63 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. Label values
  /// are optional. Label keys must start with a letter.
  ///
  /// See https://cloud.google.com/translate/docs/advanced/labels for more
  /// information.
  var labels: Dictionary<String,String> = [:]

  /// Optional. This flag is to support user customized attribution.
  /// If not provided, the default is `Machine Translated by Google`.
  /// Customized attribution should follow rules in
  /// https://cloud.google.com/translate/attribution#attribution_and_logos
  var customizedAttribution: String = String()

  /// Optional. is_translate_native_pdf_only field for external customers.
  /// If true, the page limit of online native pdf translation is 300 and only
  /// native pdf pages will be translated.
  var isTranslateNativePdfOnly: Bool = false

  /// Optional. If true, use the text removal server to remove the shadow text on
  /// background image for native pdf translation.
  /// Shadow removal feature can only be enabled when
  /// is_translate_native_pdf_only: false && pdf_native_only: false
  var enableShadowRemovalNativePdf: Bool = false

  /// Optional. If true, enable auto rotation correction in DVS.
  var enableRotationCorrection: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentInputConfig: Google_Cloud_Translation_V3_DocumentInputConfig? = nil
  fileprivate var _documentOutputConfig: Google_Cloud_Translation_V3_DocumentOutputConfig? = nil
  fileprivate var _glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig? = nil
}

/// A translated document message.
struct Google_Cloud_Translation_V3_DocumentTranslation: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The array of translated documents. It is expected to be size 1 for now. We
  /// may produce multiple translated documents in the future for other type of
  /// file formats.
  var byteStreamOutputs: [Data] = []

  /// The translated document's mime type.
  var mimeType: String = String()

  /// The detected language for the input document.
  /// If the user did not provide the source language for the input document,
  /// this field will have the language code automatically detected. If the
  /// source language was passed, auto-detection of the language does not occur
  /// and this field is empty.
  var detectedLanguageCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A translated document response message.
struct Google_Cloud_Translation_V3_TranslateDocumentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Translated document.
  var documentTranslation: Google_Cloud_Translation_V3_DocumentTranslation {
    get {return _documentTranslation ?? Google_Cloud_Translation_V3_DocumentTranslation()}
    set {_documentTranslation = newValue}
  }
  /// Returns true if `documentTranslation` has been explicitly set.
  var hasDocumentTranslation: Bool {return self._documentTranslation != nil}
  /// Clears the value of `documentTranslation`. Subsequent reads from it will return its default value.
  mutating func clearDocumentTranslation() {self._documentTranslation = nil}

  /// The document's translation output if a glossary is provided in the request.
  /// This can be the same as [TranslateDocumentResponse.document_translation]
  /// if no glossary terms apply.
  var glossaryDocumentTranslation: Google_Cloud_Translation_V3_DocumentTranslation {
    get {return _glossaryDocumentTranslation ?? Google_Cloud_Translation_V3_DocumentTranslation()}
    set {_glossaryDocumentTranslation = newValue}
  }
  /// Returns true if `glossaryDocumentTranslation` has been explicitly set.
  var hasGlossaryDocumentTranslation: Bool {return self._glossaryDocumentTranslation != nil}
  /// Clears the value of `glossaryDocumentTranslation`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryDocumentTranslation() {self._glossaryDocumentTranslation = nil}

  /// Only present when 'model' is present in the request.
  /// 'model' is normalized to have a project number.
  ///
  /// For example:
  /// If the 'model' field in TranslateDocumentRequest is:
  /// `projects/{project-id}/locations/{location-id}/models/general/nmt` then
  /// `model` here would be normalized to
  /// `projects/{project-number}/locations/{location-id}/models/general/nmt`.
  var model: String = String()

  /// The `glossary_config` used for this translation.
  var glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig {
    get {return _glossaryConfig ?? Google_Cloud_Translation_V3_TranslateTextGlossaryConfig()}
    set {_glossaryConfig = newValue}
  }
  /// Returns true if `glossaryConfig` has been explicitly set.
  var hasGlossaryConfig: Bool {return self._glossaryConfig != nil}
  /// Clears the value of `glossaryConfig`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryConfig() {self._glossaryConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentTranslation: Google_Cloud_Translation_V3_DocumentTranslation? = nil
  fileprivate var _glossaryDocumentTranslation: Google_Cloud_Translation_V3_DocumentTranslation? = nil
  fileprivate var _glossaryConfig: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig? = nil
}

/// The batch translation request.
struct Google_Cloud_Translation_V3_BatchTranslateTextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Location to make a call. Must refer to a caller's project.
  ///
  /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
  ///
  /// The `global` location is not supported for batch translation.
  ///
  /// Only AutoML Translation models or glossaries within the same region (have
  /// the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
  /// error is returned.
  var parent: String = String()

  /// Required. Source language code.
  var sourceLanguageCode: String = String()

  /// Required. Specify up to 10 language codes here.
  var targetLanguageCodes: [String] = []

  /// Optional. The models to use for translation. Map's key is target language
  /// code. Map's value is model name. Value can be a built-in general model,
  /// or an AutoML Translation model.
  ///
  /// The value format depends on model type:
  ///
  /// - AutoML Translation models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
  ///
  /// - General (built-in) models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
  ///
  ///
  /// If the map is empty or a specific model is
  /// not requested for a language pair, then default google model (nmt) is used.
  var models: Dictionary<String,String> = [:]

  /// Required. Input configurations.
  /// The total number of files matched should be <= 100.
  /// The total content size should be <= 100M Unicode codepoints.
  /// The files must use UTF-8 encoding.
  var inputConfigs: [Google_Cloud_Translation_V3_InputConfig] = []

  /// Required. Output configuration.
  /// If 2 input configs match to the same file (that is, same input path),
  /// we don't generate output for duplicate inputs.
  var outputConfig: Google_Cloud_Translation_V3_OutputConfig {
    get {return _outputConfig ?? Google_Cloud_Translation_V3_OutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  mutating func clearOutputConfig() {self._outputConfig = nil}

  /// Optional. Glossaries to be applied for translation.
  /// It's keyed by target language code.
  var glossaries: Dictionary<String,Google_Cloud_Translation_V3_TranslateTextGlossaryConfig> = [:]

  /// Optional. The labels with user-defined metadata for the request.
  ///
  /// Label keys and values can be no longer than 63 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// Label values are optional. Label keys must start with a letter.
  ///
  /// See https://cloud.google.com/translate/docs/advanced/labels for more
  /// information.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outputConfig: Google_Cloud_Translation_V3_OutputConfig? = nil
}

/// State metadata for the batch translation operation.
struct Google_Cloud_Translation_V3_BatchTranslateMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The state of the operation.
  var state: Google_Cloud_Translation_V3_BatchTranslateMetadata.State = .unspecified

  /// Number of successfully translated characters so far (Unicode codepoints).
  var translatedCharacters: Int64 = 0

  /// Number of characters that have failed to process so far (Unicode
  /// codepoints).
  var failedCharacters: Int64 = 0

  /// Total number of characters (Unicode codepoints).
  /// This is the total number of codepoints from input files times the number of
  /// target languages and appears here shortly after the call is submitted.
  var totalCharacters: Int64 = 0

  /// Time when the operation was submitted.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// State of the job.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Invalid.
    case unspecified // = 0

    /// Request is being processed.
    case running // = 1

    /// The batch is processed, and at least one item was successfully
    /// processed.
    case succeeded // = 2

    /// The batch is done and no item was successfully processed.
    case failed // = 3

    /// Request is in the process of being canceled after caller invoked
    /// longrunning.Operations.CancelOperation on the request id.
    case cancelling // = 4

    /// The batch is done after the user has called the
    /// longrunning.Operations.CancelOperation. Any records processed before the
    /// cancel command are output as specified in the request.
    case cancelled // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .succeeded
      case 3: self = .failed
      case 4: self = .cancelling
      case 5: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .succeeded: return 2
      case .failed: return 3
      case .cancelling: return 4
      case .cancelled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Cloud_Translation_V3_BatchTranslateMetadata.State] = [
      .unspecified,
      .running,
      .succeeded,
      .failed,
      .cancelling,
      .cancelled,
    ]

  }

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by BatchTranslateText if at least one sentence is translated
/// successfully.
struct Google_Cloud_Translation_V3_BatchTranslateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total number of characters (Unicode codepoints).
  var totalCharacters: Int64 = 0

  /// Number of successfully translated characters (Unicode codepoints).
  var translatedCharacters: Int64 = 0

  /// Number of characters that have failed to process (Unicode codepoints).
  var failedCharacters: Int64 = 0

  /// Time when the operation was submitted.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  /// The time when the operation is finished and
  /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
  /// set to true.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Input configuration for glossaries.
struct Google_Cloud_Translation_V3_GlossaryInputConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Specify the input.
  var source: Google_Cloud_Translation_V3_GlossaryInputConfig.OneOf_Source? = nil

  /// Required. Google Cloud Storage location of glossary data.
  /// File format is determined based on the filename extension. API returns
  /// [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file
  /// formats. Wildcards are not allowed. This must be a single file in one of
  /// the following formats:
  ///
  /// For unidirectional glossaries:
  ///
  /// - TSV/CSV (`.tsv`/`.csv`): Two column file, tab- or comma-separated.
  ///   The first column is source text. The second column is target text.
  ///   No headers in this file. The first row contains data and not column
  ///   names.
  ///
  /// - TMX (`.tmx`): TMX file with parallel data defining source/target term
  /// pairs.
  ///
  /// For equivalent term sets glossaries:
  ///
  /// - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms
  ///   in multiple languages. See documentation for more information -
  ///   [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
  var gcsSource: Google_Cloud_Translation_V3_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Translation_V3_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Specify the input.
  enum OneOf_Source: Equatable, Sendable {
    /// Required. Google Cloud Storage location of glossary data.
    /// File format is determined based on the filename extension. API returns
    /// [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file
    /// formats. Wildcards are not allowed. This must be a single file in one of
    /// the following formats:
    ///
    /// For unidirectional glossaries:
    ///
    /// - TSV/CSV (`.tsv`/`.csv`): Two column file, tab- or comma-separated.
    ///   The first column is source text. The second column is target text.
    ///   No headers in this file. The first row contains data and not column
    ///   names.
    ///
    /// - TMX (`.tmx`): TMX file with parallel data defining source/target term
    /// pairs.
    ///
    /// For equivalent term sets glossaries:
    ///
    /// - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms
    ///   in multiple languages. See documentation for more information -
    ///   [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
    case gcsSource(Google_Cloud_Translation_V3_GcsSource)

  }

  init() {}
}

/// Represents a glossary built from user-provided data.
struct Google_Cloud_Translation_V3_Glossary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the glossary. Glossary names have the form
  /// `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
  var name: String = String()

  /// Languages supported by the glossary.
  var languages: Google_Cloud_Translation_V3_Glossary.OneOf_Languages? = nil

  /// Used with unidirectional glossaries.
  var languagePair: Google_Cloud_Translation_V3_Glossary.LanguageCodePair {
    get {
      if case .languagePair(let v)? = languages {return v}
      return Google_Cloud_Translation_V3_Glossary.LanguageCodePair()
    }
    set {languages = .languagePair(newValue)}
  }

  /// Used with equivalent term set glossaries.
  var languageCodesSet: Google_Cloud_Translation_V3_Glossary.LanguageCodesSet {
    get {
      if case .languageCodesSet(let v)? = languages {return v}
      return Google_Cloud_Translation_V3_Glossary.LanguageCodesSet()
    }
    set {languages = .languageCodesSet(newValue)}
  }

  /// Required. Provides examples to build the glossary from.
  /// Total glossary must not exceed 10M Unicode codepoints.
  var inputConfig: Google_Cloud_Translation_V3_GlossaryInputConfig {
    get {return _inputConfig ?? Google_Cloud_Translation_V3_GlossaryInputConfig()}
    set {_inputConfig = newValue}
  }
  /// Returns true if `inputConfig` has been explicitly set.
  var hasInputConfig: Bool {return self._inputConfig != nil}
  /// Clears the value of `inputConfig`. Subsequent reads from it will return its default value.
  mutating func clearInputConfig() {self._inputConfig = nil}

  /// Output only. The number of entries defined in the glossary.
  var entryCount: Int32 = 0

  /// Output only. When CreateGlossary was called.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  /// Output only. When the glossary creation was finished.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  /// Optional. The display name of the glossary.
  var displayName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Languages supported by the glossary.
  enum OneOf_Languages: Equatable, Sendable {
    /// Used with unidirectional glossaries.
    case languagePair(Google_Cloud_Translation_V3_Glossary.LanguageCodePair)
    /// Used with equivalent term set glossaries.
    case languageCodesSet(Google_Cloud_Translation_V3_Glossary.LanguageCodesSet)

  }

  /// Used with unidirectional glossaries.
  struct LanguageCodePair: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The ISO-639 language code of the input text, for example,
    /// "en-US". Expected to be an exact match for GlossaryTerm.language_code.
    var sourceLanguageCode: String = String()

    /// Required. The ISO-639 language code for translation output, for example,
    /// "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
    var targetLanguageCode: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Used with equivalent term set glossaries.
  struct LanguageCodesSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ISO-639 language code(s) for terms defined in the glossary.
    /// All entries are unique. The list contains at least two entries.
    /// Expected to be an exact match for GlossaryTerm.language_code.
    var languageCodes: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _inputConfig: Google_Cloud_Translation_V3_GlossaryInputConfig? = nil
  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request message for CreateGlossary.
struct Google_Cloud_Translation_V3_CreateGlossaryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project name.
  var parent: String = String()

  /// Required. The glossary to create.
  var glossary: Google_Cloud_Translation_V3_Glossary {
    get {return _glossary ?? Google_Cloud_Translation_V3_Glossary()}
    set {_glossary = newValue}
  }
  /// Returns true if `glossary` has been explicitly set.
  var hasGlossary: Bool {return self._glossary != nil}
  /// Clears the value of `glossary`. Subsequent reads from it will return its default value.
  mutating func clearGlossary() {self._glossary = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _glossary: Google_Cloud_Translation_V3_Glossary? = nil
}

/// Request message for the update glossary flow
struct Google_Cloud_Translation_V3_UpdateGlossaryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The glossary entry to update.
  var glossary: Google_Cloud_Translation_V3_Glossary {
    get {return _glossary ?? Google_Cloud_Translation_V3_Glossary()}
    set {_glossary = newValue}
  }
  /// Returns true if `glossary` has been explicitly set.
  var hasGlossary: Bool {return self._glossary != nil}
  /// Clears the value of `glossary`. Subsequent reads from it will return its default value.
  mutating func clearGlossary() {self._glossary = nil}

  /// The list of fields to be updated. Currently only `display_name` and
  /// 'input_config'
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _glossary: Google_Cloud_Translation_V3_Glossary? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for GetGlossary.
struct Google_Cloud_Translation_V3_GetGlossaryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the glossary to retrieve.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for DeleteGlossary.
struct Google_Cloud_Translation_V3_DeleteGlossaryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the glossary to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for ListGlossaries.
struct Google_Cloud_Translation_V3_ListGlossariesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project from which to list all of the glossaries.
  var parent: String = String()

  /// Optional. Requested page size. The server may return fewer glossaries than
  /// requested. If unspecified, the server picks an appropriate default.
  var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results the server should return.
  /// Typically, this is the value of [ListGlossariesResponse.next_page_token]
  /// returned from the previous call to `ListGlossaries` method.
  /// The first page is returned if `page_token`is empty or missing.
  var pageToken: String = String()

  /// Optional. Filter specifying constraints of a list operation.
  /// Specify the constraint by the format of "key=value", where key must be
  /// "src" or "tgt", and the value must be a valid language code.
  /// For multiple restrictions, concatenate them by "AND" (uppercase only),
  /// such as: "src=en-US AND tgt=zh-CN". Notice that the exact match is used
  /// here, which means using 'en-US' and 'en' can lead to different results,
  /// which depends on the language code you used when you create the glossary.
  /// For the unidirectional glossaries, the "src" and "tgt" add restrictions
  /// on the source and target language code separately.
  /// For the equivalent term set glossaries, the "src" and/or "tgt" add
  /// restrictions on the term set.
  /// For example: "src=en-US AND tgt=zh-CN" will only pick the unidirectional
  /// glossaries which exactly match the source language code as "en-US" and the
  /// target language code "zh-CN", but all equivalent term set glossaries which
  /// contain "en-US" and "zh-CN" in their language set will be picked.
  /// If missing, no filtering is performed.
  var filter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response message for ListGlossaries.
struct Google_Cloud_Translation_V3_ListGlossariesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of glossaries for a project.
  var glossaries: [Google_Cloud_Translation_V3_Glossary] = []

  /// A token to retrieve a page of results. Pass this value in the
  /// [ListGlossariesRequest.page_token] field in the subsequent call to
  /// `ListGlossaries` method to retrieve the next page of results.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for the Get Glossary Entry Api
struct Google_Cloud_Translation_V3_GetGlossaryEntryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the glossary entry to get
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for Delete Glossary Entry
struct Google_Cloud_Translation_V3_DeleteGlossaryEntryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the glossary entry to delete
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for ListGlossaryEntries
struct Google_Cloud_Translation_V3_ListGlossaryEntriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent glossary resource name for listing the glossary's
  /// entries.
  var parent: String = String()

  /// Optional. Requested page size. The server may return fewer glossary entries
  /// than requested. If unspecified, the server picks an appropriate default.
  var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results the server should return.
  /// Typically, this is the value of
  /// [ListGlossaryEntriesResponse.next_page_token] returned from the previous
  /// call. The first page is returned if `page_token`is empty or missing.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response message for ListGlossaryEntries
struct Google_Cloud_Translation_V3_ListGlossaryEntriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The Glossary Entries
  var glossaryEntries: [Google_Cloud_Translation_V3_GlossaryEntry] = []

  /// Optional. A token to retrieve a page of results. Pass this value in the
  /// [ListGLossaryEntriesRequest.page_token] field in the subsequent calls.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request message for CreateGlossaryEntry
struct Google_Cloud_Translation_V3_CreateGlossaryEntryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the glossary to create the entry under.
  var parent: String = String()

  /// Required. The glossary entry to create
  var glossaryEntry: Google_Cloud_Translation_V3_GlossaryEntry {
    get {return _glossaryEntry ?? Google_Cloud_Translation_V3_GlossaryEntry()}
    set {_glossaryEntry = newValue}
  }
  /// Returns true if `glossaryEntry` has been explicitly set.
  var hasGlossaryEntry: Bool {return self._glossaryEntry != nil}
  /// Clears the value of `glossaryEntry`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryEntry() {self._glossaryEntry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _glossaryEntry: Google_Cloud_Translation_V3_GlossaryEntry? = nil
}

/// Request message for UpdateGlossaryEntry
struct Google_Cloud_Translation_V3_UpdateGlossaryEntryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The glossary entry to update.
  var glossaryEntry: Google_Cloud_Translation_V3_GlossaryEntry {
    get {return _glossaryEntry ?? Google_Cloud_Translation_V3_GlossaryEntry()}
    set {_glossaryEntry = newValue}
  }
  /// Returns true if `glossaryEntry` has been explicitly set.
  var hasGlossaryEntry: Bool {return self._glossaryEntry != nil}
  /// Clears the value of `glossaryEntry`. Subsequent reads from it will return its default value.
  mutating func clearGlossaryEntry() {self._glossaryEntry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _glossaryEntry: Google_Cloud_Translation_V3_GlossaryEntry? = nil
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by CreateGlossary.
struct Google_Cloud_Translation_V3_CreateGlossaryMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the glossary that is being created.
  var name: String = String()

  /// The current state of the glossary creation operation.
  var state: Google_Cloud_Translation_V3_CreateGlossaryMetadata.State = .unspecified

  /// The time when the operation was submitted to the server.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumerates the possible states that the creation request can be in.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Invalid.
    case unspecified // = 0

    /// Request is being processed.
    case running // = 1

    /// The glossary was successfully created.
    case succeeded // = 2

    /// Failed to create the glossary.
    case failed // = 3

    /// Request is in the process of being canceled after caller invoked
    /// longrunning.Operations.CancelOperation on the request id.
    case cancelling // = 4

    /// The glossary creation request was successfully canceled.
    case cancelled // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .succeeded
      case 3: self = .failed
      case 4: self = .cancelling
      case 5: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .succeeded: return 2
      case .failed: return 3
      case .cancelling: return 4
      case .cancelled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Cloud_Translation_V3_CreateGlossaryMetadata.State] = [
      .unspecified,
      .running,
      .succeeded,
      .failed,
      .cancelling,
      .cancelled,
    ]

  }

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by UpdateGlossary.
struct Google_Cloud_Translation_V3_UpdateGlossaryMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The updated glossary object.
  var glossary: Google_Cloud_Translation_V3_Glossary {
    get {return _glossary ?? Google_Cloud_Translation_V3_Glossary()}
    set {_glossary = newValue}
  }
  /// Returns true if `glossary` has been explicitly set.
  var hasGlossary: Bool {return self._glossary != nil}
  /// Clears the value of `glossary`. Subsequent reads from it will return its default value.
  mutating func clearGlossary() {self._glossary = nil}

  /// The current state of the glossary update operation. If the glossary input
  /// file was not updated this will be completed immediately
  var state: Google_Cloud_Translation_V3_UpdateGlossaryMetadata.State = .unspecified

  /// The time when the operation was submitted to the server.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumerates the possible states that the update request can be in.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Invalid.
    case unspecified // = 0

    /// Request is being processed.
    case running // = 1

    /// The glossary was successfully updated.
    case succeeded // = 2

    /// Failed to update the glossary.
    case failed // = 3

    /// Request is in the process of being canceled after caller invoked
    /// longrunning.Operations.CancelOperation on the request id.
    case cancelling // = 4

    /// The glossary update request was successfully canceled.
    case cancelled // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .succeeded
      case 3: self = .failed
      case 4: self = .cancelling
      case 5: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .succeeded: return 2
      case .failed: return 3
      case .cancelling: return 4
      case .cancelled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Cloud_Translation_V3_UpdateGlossaryMetadata.State] = [
      .unspecified,
      .running,
      .succeeded,
      .failed,
      .cancelling,
      .cancelled,
    ]

  }

  init() {}

  fileprivate var _glossary: Google_Cloud_Translation_V3_Glossary? = nil
  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by DeleteGlossary.
struct Google_Cloud_Translation_V3_DeleteGlossaryMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the glossary that is being deleted.
  var name: String = String()

  /// The current state of the glossary deletion operation.
  var state: Google_Cloud_Translation_V3_DeleteGlossaryMetadata.State = .unspecified

  /// The time when the operation was submitted to the server.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumerates the possible states that the creation request can be in.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Invalid.
    case unspecified // = 0

    /// Request is being processed.
    case running // = 1

    /// The glossary was successfully deleted.
    case succeeded // = 2

    /// Failed to delete the glossary.
    case failed // = 3

    /// Request is in the process of being canceled after caller invoked
    /// longrunning.Operations.CancelOperation on the request id.
    case cancelling // = 4

    /// The glossary deletion request was successfully canceled.
    case cancelled // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .succeeded
      case 3: self = .failed
      case 4: self = .cancelling
      case 5: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .succeeded: return 2
      case .failed: return 3
      case .cancelling: return 4
      case .cancelled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Cloud_Translation_V3_DeleteGlossaryMetadata.State] = [
      .unspecified,
      .running,
      .succeeded,
      .failed,
      .cancelling,
      .cancelled,
    ]

  }

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by DeleteGlossary.
struct Google_Cloud_Translation_V3_DeleteGlossaryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the deleted glossary.
  var name: String = String()

  /// The time when the operation was submitted to the server.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  /// The time when the glossary deletion is finished and
  /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
  /// set to true.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The BatchTranslateDocument request.
struct Google_Cloud_Translation_V3_BatchTranslateDocumentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Location to make a regional call.
  ///
  /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
  ///
  /// The `global` location is not supported for batch translation.
  ///
  /// Only AutoML Translation models or glossaries within the same region (have
  /// the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
  /// error is returned.
  var parent: String = String()

  /// Required. The ISO-639 language code of the input document if known, for
  /// example, "en-US" or "sr-Latn". Supported language codes are listed in
  /// [Language Support](https://cloud.google.com/translate/docs/languages).
  var sourceLanguageCode: String = String()

  /// Required. The ISO-639 language code to use for translation of the input
  /// document. Specify up to 10 language codes here.
  var targetLanguageCodes: [String] = []

  /// Required. Input configurations.
  /// The total number of files matched should be <= 100.
  /// The total content size to translate should be <= 100M Unicode codepoints.
  /// The files must use UTF-8 encoding.
  var inputConfigs: [Google_Cloud_Translation_V3_BatchDocumentInputConfig] = []

  /// Required. Output configuration.
  /// If 2 input configs match to the same file (that is, same input path),
  /// we don't generate output for duplicate inputs.
  var outputConfig: Google_Cloud_Translation_V3_BatchDocumentOutputConfig {
    get {return _outputConfig ?? Google_Cloud_Translation_V3_BatchDocumentOutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  mutating func clearOutputConfig() {self._outputConfig = nil}

  /// Optional. The models to use for translation. Map's key is target language
  /// code. Map's value is the model name. Value can be a built-in general model,
  /// or an AutoML Translation model.
  ///
  /// The value format depends on model type:
  ///
  /// - AutoML Translation models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
  ///
  /// - General (built-in) models:
  ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
  ///
  ///
  /// If the map is empty or a specific model is
  /// not requested for a language pair, then default google model (nmt) is used.
  var models: Dictionary<String,String> = [:]

  /// Optional. Glossaries to be applied. It's keyed by target language code.
  var glossaries: Dictionary<String,Google_Cloud_Translation_V3_TranslateTextGlossaryConfig> = [:]

  /// Optional. The file format conversion map that is applied to all input
  /// files. The map key is the original mime_type. The map value is the target
  /// mime_type of translated documents.
  ///
  /// Supported file format conversion includes:
  /// - `application/pdf` to
  ///   `application/vnd.openxmlformats-officedocument.wordprocessingml.document`
  ///
  /// If nothing specified, output files will be in the same format as the
  /// original file.
  var formatConversions: Dictionary<String,String> = [:]

  /// Optional. This flag is to support user customized attribution.
  /// If not provided, the default is `Machine Translated by Google`.
  /// Customized attribution should follow rules in
  /// https://cloud.google.com/translate/attribution#attribution_and_logos
  var customizedAttribution: String = String()

  /// Optional. If true, use the text removal server to remove the shadow text on
  /// background image for native pdf translation.
  /// Shadow removal feature can only be enabled when
  /// is_translate_native_pdf_only: false && pdf_native_only: false
  var enableShadowRemovalNativePdf: Bool = false

  /// Optional. If true, enable auto rotation correction in DVS.
  var enableRotationCorrection: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outputConfig: Google_Cloud_Translation_V3_BatchDocumentOutputConfig? = nil
}

/// Input configuration for BatchTranslateDocument request.
struct Google_Cloud_Translation_V3_BatchDocumentInputConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify the input.
  var source: Google_Cloud_Translation_V3_BatchDocumentInputConfig.OneOf_Source? = nil

  /// Google Cloud Storage location for the source input.
  /// This can be a single file (for example,
  /// `gs://translation-test/input.docx`) or a wildcard (for example,
  /// `gs://translation-test/*`).
  ///
  /// File mime type is determined based on extension. Supported mime type
  /// includes:
  /// - `pdf`, application/pdf
  /// - `docx`,
  /// application/vnd.openxmlformats-officedocument.wordprocessingml.document
  /// - `pptx`,
  /// application/vnd.openxmlformats-officedocument.presentationml.presentation
  /// - `xlsx`,
  /// application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
  ///
  /// The max file size to support for `.docx`, `.pptx` and `.xlsx` is 100MB.
  /// The max file size to support for `.pdf` is 1GB and the max page limit is
  /// 1000 pages.
  /// The max file size to support for all input documents is 1GB.
  var gcsSource: Google_Cloud_Translation_V3_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Translation_V3_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify the input.
  enum OneOf_Source: Equatable, Sendable {
    /// Google Cloud Storage location for the source input.
    /// This can be a single file (for example,
    /// `gs://translation-test/input.docx`) or a wildcard (for example,
    /// `gs://translation-test/*`).
    ///
    /// File mime type is determined based on extension. Supported mime type
    /// includes:
    /// - `pdf`, application/pdf
    /// - `docx`,
    /// application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - `pptx`,
    /// application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - `xlsx`,
    /// application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    ///
    /// The max file size to support for `.docx`, `.pptx` and `.xlsx` is 100MB.
    /// The max file size to support for `.pdf` is 1GB and the max page limit is
    /// 1000 pages.
    /// The max file size to support for all input documents is 1GB.
    case gcsSource(Google_Cloud_Translation_V3_GcsSource)

  }

  init() {}
}

/// Output configuration for BatchTranslateDocument request.
struct Google_Cloud_Translation_V3_BatchDocumentOutputConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination of output. The destination directory provided must exist
  /// and be empty.
  var destination: Google_Cloud_Translation_V3_BatchDocumentOutputConfig.OneOf_Destination? = nil

  /// Google Cloud Storage destination for output content.
  /// For every single input document (for example, gs://a/b/c.[extension]), we
  /// generate at most 2 * n output files. (n is the # of target_language_codes
  /// in the BatchTranslateDocumentRequest).
  ///
  /// While the input documents are being processed, we write/update an index
  /// file `index.csv` under `gcs_destination.output_uri_prefix` (for example,
  /// gs://translation_output/index.csv) The index file is generated/updated as
  /// new files are being translated. The format is:
  ///
  /// input_document,target_language_code,translation_output,error_output,
  /// glossary_translation_output,glossary_error_output
  ///
  /// `input_document` is one file we matched using gcs_source.input_uri.
  /// `target_language_code` is provided in the request.
  /// `translation_output` contains the translations. (details provided below)
  /// `error_output` contains the error message during processing of the file.
  /// Both translations_file and errors_file could be empty strings if we have
  /// no content to output.
  /// `glossary_translation_output` and `glossary_error_output` are the
  /// translated output/error when we apply glossaries. They could also be
  /// empty if we have no content to output.
  ///
  /// Once a row is present in index.csv, the input/output matching never
  /// changes. Callers should also expect all the content in input_file are
  /// processed and ready to be consumed (that is, no partial output file is
  /// written).
  ///
  /// Since index.csv will be keeping updated during the process, please make
  /// sure there is no custom retention policy applied on the output bucket
  /// that may avoid file updating.
  /// (https://cloud.google.com/storage/docs/bucket-lock#retention-policy)
  ///
  /// The naming format of translation output files follows (for target
  /// language code [trg]): `translation_output`:
  /// `gs://translation_output/a_b_c_[trg]_translation.[extension]`
  /// `glossary_translation_output`:
  /// `gs://translation_test/a_b_c_[trg]_glossary_translation.[extension]`. The
  /// output document will maintain the same file format as the input document.
  ///
  /// The naming format of error output files follows (for target language code
  /// [trg]): `error_output`: `gs://translation_test/a_b_c_[trg]_errors.txt`
  /// `glossary_error_output`:
  /// `gs://translation_test/a_b_c_[trg]_glossary_translation.txt`. The error
  /// output is a txt file containing error details.
  var gcsDestination: Google_Cloud_Translation_V3_GcsDestination {
    get {
      if case .gcsDestination(let v)? = destination {return v}
      return Google_Cloud_Translation_V3_GcsDestination()
    }
    set {destination = .gcsDestination(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The destination of output. The destination directory provided must exist
  /// and be empty.
  enum OneOf_Destination: Equatable, Sendable {
    /// Google Cloud Storage destination for output content.
    /// For every single input document (for example, gs://a/b/c.[extension]), we
    /// generate at most 2 * n output files. (n is the # of target_language_codes
    /// in the BatchTranslateDocumentRequest).
    ///
    /// While the input documents are being processed, we write/update an index
    /// file `index.csv` under `gcs_destination.output_uri_prefix` (for example,
    /// gs://translation_output/index.csv) The index file is generated/updated as
    /// new files are being translated. The format is:
    ///
    /// input_document,target_language_code,translation_output,error_output,
    /// glossary_translation_output,glossary_error_output
    ///
    /// `input_document` is one file we matched using gcs_source.input_uri.
    /// `target_language_code` is provided in the request.
    /// `translation_output` contains the translations. (details provided below)
    /// `error_output` contains the error message during processing of the file.
    /// Both translations_file and errors_file could be empty strings if we have
    /// no content to output.
    /// `glossary_translation_output` and `glossary_error_output` are the
    /// translated output/error when we apply glossaries. They could also be
    /// empty if we have no content to output.
    ///
    /// Once a row is present in index.csv, the input/output matching never
    /// changes. Callers should also expect all the content in input_file are
    /// processed and ready to be consumed (that is, no partial output file is
    /// written).
    ///
    /// Since index.csv will be keeping updated during the process, please make
    /// sure there is no custom retention policy applied on the output bucket
    /// that may avoid file updating.
    /// (https://cloud.google.com/storage/docs/bucket-lock#retention-policy)
    ///
    /// The naming format of translation output files follows (for target
    /// language code [trg]): `translation_output`:
    /// `gs://translation_output/a_b_c_[trg]_translation.[extension]`
    /// `glossary_translation_output`:
    /// `gs://translation_test/a_b_c_[trg]_glossary_translation.[extension]`. The
    /// output document will maintain the same file format as the input document.
    ///
    /// The naming format of error output files follows (for target language code
    /// [trg]): `error_output`: `gs://translation_test/a_b_c_[trg]_errors.txt`
    /// `glossary_error_output`:
    /// `gs://translation_test/a_b_c_[trg]_glossary_translation.txt`. The error
    /// output is a txt file containing error details.
    case gcsDestination(Google_Cloud_Translation_V3_GcsDestination)

  }

  init() {}
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by BatchTranslateDocument if at least one document is
/// translated successfully.
struct Google_Cloud_Translation_V3_BatchTranslateDocumentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total number of pages to translate in all documents. Documents without
  /// clear page definition (such as XLSX) are not counted.
  var totalPages: Int64 = 0

  /// Number of successfully translated pages in all documents. Documents without
  /// clear page definition (such as XLSX) are not counted.
  var translatedPages: Int64 = 0

  /// Number of pages that failed to process in all documents. Documents without
  /// clear page definition (such as XLSX) are not counted.
  var failedPages: Int64 = 0

  /// Number of billable pages in documents with clear page definition (such as
  /// PDF, DOCX, PPTX)
  var totalBillablePages: Int64 = 0

  /// Total number of characters (Unicode codepoints) in all documents.
  var totalCharacters: Int64 = 0

  /// Number of successfully translated characters (Unicode codepoints) in all
  /// documents.
  var translatedCharacters: Int64 = 0

  /// Number of characters that have failed to process (Unicode codepoints) in
  /// all documents.
  var failedCharacters: Int64 = 0

  /// Number of billable characters (Unicode codepoints) in documents without
  /// clear page definition, such as XLSX.
  var totalBillableCharacters: Int64 = 0

  /// Time when the operation was submitted.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  /// The time when the operation is finished and
  /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
  /// set to true.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// State metadata for the batch translation operation.
struct Google_Cloud_Translation_V3_BatchTranslateDocumentMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The state of the operation.
  var state: Google_Cloud_Translation_V3_BatchTranslateDocumentMetadata.State = .unspecified

  /// Total number of pages to translate in all documents so far. Documents
  /// without clear page definition (such as XLSX) are not counted.
  var totalPages: Int64 = 0

  /// Number of successfully translated pages in all documents so far. Documents
  /// without clear page definition (such as XLSX) are not counted.
  var translatedPages: Int64 = 0

  /// Number of pages that failed to process in all documents so far. Documents
  /// without clear page definition (such as XLSX) are not counted.
  var failedPages: Int64 = 0

  /// Number of billable pages in documents with clear page definition (such as
  /// PDF, DOCX, PPTX) so far.
  var totalBillablePages: Int64 = 0

  /// Total number of characters (Unicode codepoints) in all documents so far.
  var totalCharacters: Int64 = 0

  /// Number of successfully translated characters (Unicode codepoints) in all
  /// documents so far.
  var translatedCharacters: Int64 = 0

  /// Number of characters that have failed to process (Unicode codepoints) in
  /// all documents so far.
  var failedCharacters: Int64 = 0

  /// Number of billable characters (Unicode codepoints) in documents without
  /// clear page definition (such as XLSX) so far.
  var totalBillableCharacters: Int64 = 0

  /// Time when the operation was submitted.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// State of the job.
  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Invalid.
    case unspecified // = 0

    /// Request is being processed.
    case running // = 1

    /// The batch is processed, and at least one item was successfully processed.
    case succeeded // = 2

    /// The batch is done and no item was successfully processed.
    case failed // = 3

    /// Request is in the process of being canceled after caller invoked
    /// longrunning.Operations.CancelOperation on the request id.
    case cancelling // = 4

    /// The batch is done after the user has called the
    /// longrunning.Operations.CancelOperation. Any records processed before the
    /// cancel command are output as specified in the request.
    case cancelled // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .succeeded
      case 3: self = .failed
      case 4: self = .cancelling
      case 5: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .succeeded: return 2
      case .failed: return 3
      case .cancelling: return 4
      case .cancelled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Cloud_Translation_V3_BatchTranslateDocumentMetadata.State] = [
      .unspecified,
      .running,
      .succeeded,
      .failed,
      .cancelling,
      .cancelled,
    ]

  }

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Configures which glossary is used for a specific target language and defines
/// options for applying that glossary.
struct Google_Cloud_Translation_V3_TranslateTextGlossaryConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The `glossary` to be applied for this translation.
  ///
  /// The format depends on the glossary:
  ///
  /// - User-provided custom glossary:
  ///   `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
  var glossary: String = String()

  /// Optional. Indicates match is case insensitive. The default value is `false`
  /// if missing.
  var ignoreCase: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.translation.v3"

extension Google_Cloud_Translation_V3_TransliterationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransliterationConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_transliteration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableTransliteration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableTransliteration != false {
      try visitor.visitSingularBoolField(value: self.enableTransliteration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_TransliterationConfig, rhs: Google_Cloud_Translation_V3_TransliterationConfig) -> Bool {
    if lhs.enableTransliteration != rhs.enableTransliteration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_TranslateTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranslateTextRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
    3: .standard(proto: "mime_type"),
    4: .standard(proto: "source_language_code"),
    5: .standard(proto: "target_language_code"),
    8: .same(proto: "parent"),
    6: .same(proto: "model"),
    7: .standard(proto: "glossary_config"),
    13: .standard(proto: "transliteration_config"),
    10: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.contents) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.targetLanguageCode) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._glossaryConfig) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._transliterationConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.contents, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 4)
    }
    if !self.targetLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.targetLanguageCode, fieldNumber: 5)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 6)
    }
    try { if let v = self._glossaryConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 8)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 10)
    }
    try { if let v = self._transliterationConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_TranslateTextRequest, rhs: Google_Cloud_Translation_V3_TranslateTextRequest) -> Bool {
    if lhs.contents != rhs.contents {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.targetLanguageCode != rhs.targetLanguageCode {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.model != rhs.model {return false}
    if lhs._glossaryConfig != rhs._glossaryConfig {return false}
    if lhs._transliterationConfig != rhs._transliterationConfig {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_TranslateTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranslateTextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "translations"),
    3: .standard(proto: "glossary_translations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.translations) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.glossaryTranslations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.translations, fieldNumber: 1)
    }
    if !self.glossaryTranslations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.glossaryTranslations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_TranslateTextResponse, rhs: Google_Cloud_Translation_V3_TranslateTextResponse) -> Bool {
    if lhs.translations != rhs.translations {return false}
    if lhs.glossaryTranslations != rhs.glossaryTranslations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_Translation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Translation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "translated_text"),
    2: .same(proto: "model"),
    4: .standard(proto: "detected_language_code"),
    3: .standard(proto: "glossary_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.translatedText) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._glossaryConfig) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.detectedLanguageCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.translatedText.isEmpty {
      try visitor.visitSingularStringField(value: self.translatedText, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    try { if let v = self._glossaryConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.detectedLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.detectedLanguageCode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_Translation, rhs: Google_Cloud_Translation_V3_Translation) -> Bool {
    if lhs.translatedText != rhs.translatedText {return false}
    if lhs.model != rhs.model {return false}
    if lhs.detectedLanguageCode != rhs.detectedLanguageCode {return false}
    if lhs._glossaryConfig != rhs._glossaryConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_RomanizeTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RomanizeTextRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "parent"),
    1: .same(proto: "contents"),
    2: .standard(proto: "source_language_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.contents) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.contents, fieldNumber: 1)
    }
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_RomanizeTextRequest, rhs: Google_Cloud_Translation_V3_RomanizeTextRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_Romanization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Romanization"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "romanized_text"),
    2: .standard(proto: "detected_language_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.romanizedText) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.detectedLanguageCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.romanizedText.isEmpty {
      try visitor.visitSingularStringField(value: self.romanizedText, fieldNumber: 1)
    }
    if !self.detectedLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.detectedLanguageCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_Romanization, rhs: Google_Cloud_Translation_V3_Romanization) -> Bool {
    if lhs.romanizedText != rhs.romanizedText {return false}
    if lhs.detectedLanguageCode != rhs.detectedLanguageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_RomanizeTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RomanizeTextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "romanizations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.romanizations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.romanizations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.romanizations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_RomanizeTextResponse, rhs: Google_Cloud_Translation_V3_RomanizeTextResponse) -> Bool {
    if lhs.romanizations != rhs.romanizations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DetectLanguageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetectLanguageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "parent"),
    4: .same(proto: "model"),
    1: .same(proto: "content"),
    3: .standard(proto: "mime_type"),
    6: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .content(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .content(let v)? = self.source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 4)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 5)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DetectLanguageRequest, rhs: Google_Cloud_Translation_V3_DetectLanguageRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.model != rhs.model {return false}
    if lhs.source != rhs.source {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DetectedLanguage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetectedLanguage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "language_code"),
    2: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    if self.confidence.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.confidence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DetectedLanguage, rhs: Google_Cloud_Translation_V3_DetectedLanguage) -> Bool {
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DetectLanguageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DetectLanguageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "languages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.languages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.languages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DetectLanguageResponse, rhs: Google_Cloud_Translation_V3_DetectLanguageResponse) -> Bool {
    if lhs.languages != rhs.languages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GetSupportedLanguagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSupportedLanguagesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "parent"),
    1: .standard(proto: "display_language_code"),
    2: .same(proto: "model"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayLanguageCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.displayLanguageCode, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GetSupportedLanguagesRequest, rhs: Google_Cloud_Translation_V3_GetSupportedLanguagesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.displayLanguageCode != rhs.displayLanguageCode {return false}
    if lhs.model != rhs.model {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_SupportedLanguages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupportedLanguages"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "languages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.languages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.languages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_SupportedLanguages, rhs: Google_Cloud_Translation_V3_SupportedLanguages) -> Bool {
    if lhs.languages != rhs.languages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_SupportedLanguage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupportedLanguage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "language_code"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "support_source"),
    4: .standard(proto: "support_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.supportSource) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.supportTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if self.supportSource != false {
      try visitor.visitSingularBoolField(value: self.supportSource, fieldNumber: 3)
    }
    if self.supportTarget != false {
      try visitor.visitSingularBoolField(value: self.supportTarget, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_SupportedLanguage, rhs: Google_Cloud_Translation_V3_SupportedLanguage) -> Bool {
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.supportSource != rhs.supportSource {return false}
    if lhs.supportTarget != rhs.supportTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GcsSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GcsSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inputUri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputUri.isEmpty {
      try visitor.visitSingularStringField(value: self.inputUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GcsSource, rhs: Google_Cloud_Translation_V3_GcsSource) -> Bool {
    if lhs.inputUri != rhs.inputUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_InputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InputConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .standard(proto: "gcs_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 2: try {
        var v: Google_Cloud_Translation_V3_GcsSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .gcsSource(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 1)
    }
    try { if case .gcsSource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_InputConfig, rhs: Google_Cloud_Translation_V3_InputConfig) -> Bool {
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GcsDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GcsDestination"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_uri_prefix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outputUriPrefix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputUriPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.outputUriPrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GcsDestination, rhs: Google_Cloud_Translation_V3_GcsDestination) -> Bool {
    if lhs.outputUriPrefix != rhs.outputUriPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_OutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutputConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Translation_V3_GcsDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .gcsDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .gcsDestination(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .gcsDestination(let v)? = self.destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_OutputConfig, rhs: Google_Cloud_Translation_V3_OutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DocumentInputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentInputConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .standard(proto: "gcs_source"),
    4: .standard(proto: "mime_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .content(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Translation_V3_GcsSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .gcsSource(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.source {
    case .content?: try {
      guard case .content(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .gcsSource?: try {
      guard case .gcsSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DocumentInputConfig, rhs: Google_Cloud_Translation_V3_DocumentInputConfig) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DocumentOutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentOutputConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_destination"),
    3: .standard(proto: "mime_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Translation_V3_GcsDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .gcsDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .gcsDestination(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .gcsDestination(let v)? = self.destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DocumentOutputConfig, rhs: Google_Cloud_Translation_V3_DocumentOutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_TranslateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranslateDocumentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "source_language_code"),
    3: .standard(proto: "target_language_code"),
    4: .standard(proto: "document_input_config"),
    5: .standard(proto: "document_output_config"),
    6: .same(proto: "model"),
    7: .standard(proto: "glossary_config"),
    8: .same(proto: "labels"),
    10: .standard(proto: "customized_attribution"),
    11: .standard(proto: "is_translate_native_pdf_only"),
    12: .standard(proto: "enable_shadow_removal_native_pdf"),
    13: .standard(proto: "enable_rotation_correction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetLanguageCode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._documentInputConfig) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._documentOutputConfig) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._glossaryConfig) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.customizedAttribution) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isTranslateNativePdfOnly) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.enableShadowRemovalNativePdf) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.enableRotationCorrection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 2)
    }
    if !self.targetLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.targetLanguageCode, fieldNumber: 3)
    }
    try { if let v = self._documentInputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._documentOutputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 6)
    }
    try { if let v = self._glossaryConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 8)
    }
    if !self.customizedAttribution.isEmpty {
      try visitor.visitSingularStringField(value: self.customizedAttribution, fieldNumber: 10)
    }
    if self.isTranslateNativePdfOnly != false {
      try visitor.visitSingularBoolField(value: self.isTranslateNativePdfOnly, fieldNumber: 11)
    }
    if self.enableShadowRemovalNativePdf != false {
      try visitor.visitSingularBoolField(value: self.enableShadowRemovalNativePdf, fieldNumber: 12)
    }
    if self.enableRotationCorrection != false {
      try visitor.visitSingularBoolField(value: self.enableRotationCorrection, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_TranslateDocumentRequest, rhs: Google_Cloud_Translation_V3_TranslateDocumentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.targetLanguageCode != rhs.targetLanguageCode {return false}
    if lhs._documentInputConfig != rhs._documentInputConfig {return false}
    if lhs._documentOutputConfig != rhs._documentOutputConfig {return false}
    if lhs.model != rhs.model {return false}
    if lhs._glossaryConfig != rhs._glossaryConfig {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.customizedAttribution != rhs.customizedAttribution {return false}
    if lhs.isTranslateNativePdfOnly != rhs.isTranslateNativePdfOnly {return false}
    if lhs.enableShadowRemovalNativePdf != rhs.enableShadowRemovalNativePdf {return false}
    if lhs.enableRotationCorrection != rhs.enableRotationCorrection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DocumentTranslation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentTranslation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "byte_stream_outputs"),
    2: .standard(proto: "mime_type"),
    3: .standard(proto: "detected_language_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.byteStreamOutputs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.detectedLanguageCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.byteStreamOutputs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.byteStreamOutputs, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if !self.detectedLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.detectedLanguageCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DocumentTranslation, rhs: Google_Cloud_Translation_V3_DocumentTranslation) -> Bool {
    if lhs.byteStreamOutputs != rhs.byteStreamOutputs {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.detectedLanguageCode != rhs.detectedLanguageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_TranslateDocumentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranslateDocumentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_translation"),
    2: .standard(proto: "glossary_document_translation"),
    3: .same(proto: "model"),
    4: .standard(proto: "glossary_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._documentTranslation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._glossaryDocumentTranslation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._glossaryConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentTranslation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._glossaryDocumentTranslation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 3)
    }
    try { if let v = self._glossaryConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_TranslateDocumentResponse, rhs: Google_Cloud_Translation_V3_TranslateDocumentResponse) -> Bool {
    if lhs._documentTranslation != rhs._documentTranslation {return false}
    if lhs._glossaryDocumentTranslation != rhs._glossaryDocumentTranslation {return false}
    if lhs.model != rhs.model {return false}
    if lhs._glossaryConfig != rhs._glossaryConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchTranslateTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTranslateTextRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "source_language_code"),
    3: .standard(proto: "target_language_codes"),
    4: .same(proto: "models"),
    5: .standard(proto: "input_configs"),
    6: .standard(proto: "output_config"),
    7: .same(proto: "glossaries"),
    9: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.targetLanguageCodes) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.models) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.inputConfigs) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Translation_V3_TranslateTextGlossaryConfig>.self, value: &self.glossaries) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 2)
    }
    if !self.targetLanguageCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetLanguageCodes, fieldNumber: 3)
    }
    if !self.models.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.models, fieldNumber: 4)
    }
    if !self.inputConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputConfigs, fieldNumber: 5)
    }
    try { if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.glossaries.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Translation_V3_TranslateTextGlossaryConfig>.self, value: self.glossaries, fieldNumber: 7)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchTranslateTextRequest, rhs: Google_Cloud_Translation_V3_BatchTranslateTextRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.targetLanguageCodes != rhs.targetLanguageCodes {return false}
    if lhs.models != rhs.models {return false}
    if lhs.inputConfigs != rhs.inputConfigs {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs.glossaries != rhs.glossaries {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchTranslateMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTranslateMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "translated_characters"),
    3: .standard(proto: "failed_characters"),
    4: .standard(proto: "total_characters"),
    5: .standard(proto: "submit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.translatedCharacters) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.failedCharacters) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalCharacters) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.translatedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.translatedCharacters, fieldNumber: 2)
    }
    if self.failedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.failedCharacters, fieldNumber: 3)
    }
    if self.totalCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCharacters, fieldNumber: 4)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchTranslateMetadata, rhs: Google_Cloud_Translation_V3_BatchTranslateMetadata) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.translatedCharacters != rhs.translatedCharacters {return false}
    if lhs.failedCharacters != rhs.failedCharacters {return false}
    if lhs.totalCharacters != rhs.totalCharacters {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchTranslateMetadata.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "SUCCEEDED"),
    3: .same(proto: "FAILED"),
    4: .same(proto: "CANCELLING"),
    5: .same(proto: "CANCELLED"),
  ]
}

extension Google_Cloud_Translation_V3_BatchTranslateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTranslateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_characters"),
    2: .standard(proto: "translated_characters"),
    3: .standard(proto: "failed_characters"),
    4: .standard(proto: "submit_time"),
    5: .standard(proto: "end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.totalCharacters) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.translatedCharacters) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.failedCharacters) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.totalCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCharacters, fieldNumber: 1)
    }
    if self.translatedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.translatedCharacters, fieldNumber: 2)
    }
    if self.failedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.failedCharacters, fieldNumber: 3)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchTranslateResponse, rhs: Google_Cloud_Translation_V3_BatchTranslateResponse) -> Bool {
    if lhs.totalCharacters != rhs.totalCharacters {return false}
    if lhs.translatedCharacters != rhs.translatedCharacters {return false}
    if lhs.failedCharacters != rhs.failedCharacters {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GlossaryInputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlossaryInputConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Translation_V3_GcsSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .gcsSource(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .gcsSource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GlossaryInputConfig, rhs: Google_Cloud_Translation_V3_GlossaryInputConfig) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_Glossary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Glossary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "language_pair"),
    4: .standard(proto: "language_codes_set"),
    5: .standard(proto: "input_config"),
    6: .standard(proto: "entry_count"),
    7: .standard(proto: "submit_time"),
    8: .standard(proto: "end_time"),
    9: .standard(proto: "display_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try {
        var v: Google_Cloud_Translation_V3_Glossary.LanguageCodePair?
        var hadOneofValue = false
        if let current = self.languages {
          hadOneofValue = true
          if case .languagePair(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.languages = .languagePair(v)
        }
      }()
      case 4: try {
        var v: Google_Cloud_Translation_V3_Glossary.LanguageCodesSet?
        var hadOneofValue = false
        if let current = self.languages {
          hadOneofValue = true
          if case .languageCodesSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.languages = .languageCodesSet(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._inputConfig) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.entryCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.languages {
    case .languagePair?: try {
      guard case .languagePair(let v)? = self.languages else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .languageCodesSet?: try {
      guard case .languageCodesSet(let v)? = self.languages else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._inputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.entryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.entryCount, fieldNumber: 6)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_Glossary, rhs: Google_Cloud_Translation_V3_Glossary) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.languages != rhs.languages {return false}
    if lhs._inputConfig != rhs._inputConfig {return false}
    if lhs.entryCount != rhs.entryCount {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_Glossary.LanguageCodePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Translation_V3_Glossary.protoMessageName + ".LanguageCodePair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_language_code"),
    2: .standard(proto: "target_language_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetLanguageCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 1)
    }
    if !self.targetLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.targetLanguageCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_Glossary.LanguageCodePair, rhs: Google_Cloud_Translation_V3_Glossary.LanguageCodePair) -> Bool {
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.targetLanguageCode != rhs.targetLanguageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_Glossary.LanguageCodesSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Translation_V3_Glossary.protoMessageName + ".LanguageCodesSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "language_codes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.languageCodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.languageCodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_Glossary.LanguageCodesSet, rhs: Google_Cloud_Translation_V3_Glossary.LanguageCodesSet) -> Bool {
    if lhs.languageCodes != rhs.languageCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_CreateGlossaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateGlossaryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "glossary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._glossary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._glossary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_CreateGlossaryRequest, rhs: Google_Cloud_Translation_V3_CreateGlossaryRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._glossary != rhs._glossary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_UpdateGlossaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateGlossaryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "glossary"),
    2: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._glossary) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._glossary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_UpdateGlossaryRequest, rhs: Google_Cloud_Translation_V3_UpdateGlossaryRequest) -> Bool {
    if lhs._glossary != rhs._glossary {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GetGlossaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGlossaryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GetGlossaryRequest, rhs: Google_Cloud_Translation_V3_GetGlossaryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DeleteGlossaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteGlossaryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DeleteGlossaryRequest, rhs: Google_Cloud_Translation_V3_DeleteGlossaryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListGlossariesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGlossariesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListGlossariesRequest, rhs: Google_Cloud_Translation_V3_ListGlossariesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListGlossariesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGlossariesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "glossaries"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.glossaries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.glossaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.glossaries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListGlossariesResponse, rhs: Google_Cloud_Translation_V3_ListGlossariesResponse) -> Bool {
    if lhs.glossaries != rhs.glossaries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_GetGlossaryEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGlossaryEntryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_GetGlossaryEntryRequest, rhs: Google_Cloud_Translation_V3_GetGlossaryEntryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DeleteGlossaryEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteGlossaryEntryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DeleteGlossaryEntryRequest, rhs: Google_Cloud_Translation_V3_DeleteGlossaryEntryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListGlossaryEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGlossaryEntriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListGlossaryEntriesRequest, rhs: Google_Cloud_Translation_V3_ListGlossaryEntriesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_ListGlossaryEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGlossaryEntriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "glossary_entries"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.glossaryEntries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.glossaryEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.glossaryEntries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_ListGlossaryEntriesResponse, rhs: Google_Cloud_Translation_V3_ListGlossaryEntriesResponse) -> Bool {
    if lhs.glossaryEntries != rhs.glossaryEntries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_CreateGlossaryEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateGlossaryEntryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "glossary_entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._glossaryEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._glossaryEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_CreateGlossaryEntryRequest, rhs: Google_Cloud_Translation_V3_CreateGlossaryEntryRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._glossaryEntry != rhs._glossaryEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_UpdateGlossaryEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateGlossaryEntryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "glossary_entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._glossaryEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._glossaryEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_UpdateGlossaryEntryRequest, rhs: Google_Cloud_Translation_V3_UpdateGlossaryEntryRequest) -> Bool {
    if lhs._glossaryEntry != rhs._glossaryEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_CreateGlossaryMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateGlossaryMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "state"),
    3: .standard(proto: "submit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_CreateGlossaryMetadata, rhs: Google_Cloud_Translation_V3_CreateGlossaryMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.state != rhs.state {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_CreateGlossaryMetadata.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "SUCCEEDED"),
    3: .same(proto: "FAILED"),
    4: .same(proto: "CANCELLING"),
    5: .same(proto: "CANCELLED"),
  ]
}

extension Google_Cloud_Translation_V3_UpdateGlossaryMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateGlossaryMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "glossary"),
    2: .same(proto: "state"),
    3: .standard(proto: "submit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._glossary) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._glossary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_UpdateGlossaryMetadata, rhs: Google_Cloud_Translation_V3_UpdateGlossaryMetadata) -> Bool {
    if lhs._glossary != rhs._glossary {return false}
    if lhs.state != rhs.state {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_UpdateGlossaryMetadata.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "SUCCEEDED"),
    3: .same(proto: "FAILED"),
    4: .same(proto: "CANCELLING"),
    5: .same(proto: "CANCELLED"),
  ]
}

extension Google_Cloud_Translation_V3_DeleteGlossaryMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteGlossaryMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "state"),
    3: .standard(proto: "submit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DeleteGlossaryMetadata, rhs: Google_Cloud_Translation_V3_DeleteGlossaryMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.state != rhs.state {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_DeleteGlossaryMetadata.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "SUCCEEDED"),
    3: .same(proto: "FAILED"),
    4: .same(proto: "CANCELLING"),
    5: .same(proto: "CANCELLED"),
  ]
}

extension Google_Cloud_Translation_V3_DeleteGlossaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteGlossaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "submit_time"),
    3: .standard(proto: "end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_DeleteGlossaryResponse, rhs: Google_Cloud_Translation_V3_DeleteGlossaryResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchTranslateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTranslateDocumentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "source_language_code"),
    3: .standard(proto: "target_language_codes"),
    4: .standard(proto: "input_configs"),
    5: .standard(proto: "output_config"),
    6: .same(proto: "models"),
    7: .same(proto: "glossaries"),
    8: .standard(proto: "format_conversions"),
    10: .standard(proto: "customized_attribution"),
    11: .standard(proto: "enable_shadow_removal_native_pdf"),
    12: .standard(proto: "enable_rotation_correction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceLanguageCode) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.targetLanguageCodes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inputConfigs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.models) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Translation_V3_TranslateTextGlossaryConfig>.self, value: &self.glossaries) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.formatConversions) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.customizedAttribution) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.enableShadowRemovalNativePdf) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.enableRotationCorrection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.sourceLanguageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceLanguageCode, fieldNumber: 2)
    }
    if !self.targetLanguageCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetLanguageCodes, fieldNumber: 3)
    }
    if !self.inputConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputConfigs, fieldNumber: 4)
    }
    try { if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.models.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.models, fieldNumber: 6)
    }
    if !self.glossaries.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Translation_V3_TranslateTextGlossaryConfig>.self, value: self.glossaries, fieldNumber: 7)
    }
    if !self.formatConversions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.formatConversions, fieldNumber: 8)
    }
    if !self.customizedAttribution.isEmpty {
      try visitor.visitSingularStringField(value: self.customizedAttribution, fieldNumber: 10)
    }
    if self.enableShadowRemovalNativePdf != false {
      try visitor.visitSingularBoolField(value: self.enableShadowRemovalNativePdf, fieldNumber: 11)
    }
    if self.enableRotationCorrection != false {
      try visitor.visitSingularBoolField(value: self.enableRotationCorrection, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchTranslateDocumentRequest, rhs: Google_Cloud_Translation_V3_BatchTranslateDocumentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.sourceLanguageCode != rhs.sourceLanguageCode {return false}
    if lhs.targetLanguageCodes != rhs.targetLanguageCodes {return false}
    if lhs.inputConfigs != rhs.inputConfigs {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs.models != rhs.models {return false}
    if lhs.glossaries != rhs.glossaries {return false}
    if lhs.formatConversions != rhs.formatConversions {return false}
    if lhs.customizedAttribution != rhs.customizedAttribution {return false}
    if lhs.enableShadowRemovalNativePdf != rhs.enableShadowRemovalNativePdf {return false}
    if lhs.enableRotationCorrection != rhs.enableRotationCorrection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchDocumentInputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchDocumentInputConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Translation_V3_GcsSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .gcsSource(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .gcsSource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchDocumentInputConfig, rhs: Google_Cloud_Translation_V3_BatchDocumentInputConfig) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchDocumentOutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchDocumentOutputConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Translation_V3_GcsDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .gcsDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .gcsDestination(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .gcsDestination(let v)? = self.destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchDocumentOutputConfig, rhs: Google_Cloud_Translation_V3_BatchDocumentOutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchTranslateDocumentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTranslateDocumentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_pages"),
    2: .standard(proto: "translated_pages"),
    3: .standard(proto: "failed_pages"),
    4: .standard(proto: "total_billable_pages"),
    5: .standard(proto: "total_characters"),
    6: .standard(proto: "translated_characters"),
    7: .standard(proto: "failed_characters"),
    8: .standard(proto: "total_billable_characters"),
    9: .standard(proto: "submit_time"),
    10: .standard(proto: "end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.totalPages) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.translatedPages) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.failedPages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalBillablePages) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalCharacters) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.translatedCharacters) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.failedCharacters) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.totalBillableCharacters) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.totalPages != 0 {
      try visitor.visitSingularInt64Field(value: self.totalPages, fieldNumber: 1)
    }
    if self.translatedPages != 0 {
      try visitor.visitSingularInt64Field(value: self.translatedPages, fieldNumber: 2)
    }
    if self.failedPages != 0 {
      try visitor.visitSingularInt64Field(value: self.failedPages, fieldNumber: 3)
    }
    if self.totalBillablePages != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBillablePages, fieldNumber: 4)
    }
    if self.totalCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCharacters, fieldNumber: 5)
    }
    if self.translatedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.translatedCharacters, fieldNumber: 6)
    }
    if self.failedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.failedCharacters, fieldNumber: 7)
    }
    if self.totalBillableCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBillableCharacters, fieldNumber: 8)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchTranslateDocumentResponse, rhs: Google_Cloud_Translation_V3_BatchTranslateDocumentResponse) -> Bool {
    if lhs.totalPages != rhs.totalPages {return false}
    if lhs.translatedPages != rhs.translatedPages {return false}
    if lhs.failedPages != rhs.failedPages {return false}
    if lhs.totalBillablePages != rhs.totalBillablePages {return false}
    if lhs.totalCharacters != rhs.totalCharacters {return false}
    if lhs.translatedCharacters != rhs.translatedCharacters {return false}
    if lhs.failedCharacters != rhs.failedCharacters {return false}
    if lhs.totalBillableCharacters != rhs.totalBillableCharacters {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchTranslateDocumentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTranslateDocumentMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "total_pages"),
    3: .standard(proto: "translated_pages"),
    4: .standard(proto: "failed_pages"),
    5: .standard(proto: "total_billable_pages"),
    6: .standard(proto: "total_characters"),
    7: .standard(proto: "translated_characters"),
    8: .standard(proto: "failed_characters"),
    9: .standard(proto: "total_billable_characters"),
    10: .standard(proto: "submit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalPages) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.translatedPages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.failedPages) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalBillablePages) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalCharacters) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.translatedCharacters) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.failedCharacters) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.totalBillableCharacters) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.totalPages != 0 {
      try visitor.visitSingularInt64Field(value: self.totalPages, fieldNumber: 2)
    }
    if self.translatedPages != 0 {
      try visitor.visitSingularInt64Field(value: self.translatedPages, fieldNumber: 3)
    }
    if self.failedPages != 0 {
      try visitor.visitSingularInt64Field(value: self.failedPages, fieldNumber: 4)
    }
    if self.totalBillablePages != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBillablePages, fieldNumber: 5)
    }
    if self.totalCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCharacters, fieldNumber: 6)
    }
    if self.translatedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.translatedCharacters, fieldNumber: 7)
    }
    if self.failedCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.failedCharacters, fieldNumber: 8)
    }
    if self.totalBillableCharacters != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBillableCharacters, fieldNumber: 9)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_BatchTranslateDocumentMetadata, rhs: Google_Cloud_Translation_V3_BatchTranslateDocumentMetadata) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.totalPages != rhs.totalPages {return false}
    if lhs.translatedPages != rhs.translatedPages {return false}
    if lhs.failedPages != rhs.failedPages {return false}
    if lhs.totalBillablePages != rhs.totalBillablePages {return false}
    if lhs.totalCharacters != rhs.totalCharacters {return false}
    if lhs.translatedCharacters != rhs.translatedCharacters {return false}
    if lhs.failedCharacters != rhs.failedCharacters {return false}
    if lhs.totalBillableCharacters != rhs.totalBillableCharacters {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Translation_V3_BatchTranslateDocumentMetadata.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "SUCCEEDED"),
    3: .same(proto: "FAILED"),
    4: .same(proto: "CANCELLING"),
    5: .same(proto: "CANCELLED"),
  ]
}

extension Google_Cloud_Translation_V3_TranslateTextGlossaryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranslateTextGlossaryConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "glossary"),
    2: .standard(proto: "ignore_case"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.glossary) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ignoreCase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.glossary.isEmpty {
      try visitor.visitSingularStringField(value: self.glossary, fieldNumber: 1)
    }
    if self.ignoreCase != false {
      try visitor.visitSingularBoolField(value: self.ignoreCase, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig, rhs: Google_Cloud_Translation_V3_TranslateTextGlossaryConfig) -> Bool {
    if lhs.glossary != rhs.glossary {return false}
    if lhs.ignoreCase != rhs.ignoreCase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
