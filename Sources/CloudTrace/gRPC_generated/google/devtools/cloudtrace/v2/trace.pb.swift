// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/cloudtrace/v2/trace.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A span represents a single operation within a trace. Spans can be
/// nested to form a trace tree. Often, a trace contains a root span
/// that describes the end-to-end latency, and one or more subspans for
/// its sub-operations. A trace can also contain multiple root spans,
/// or none at all. Spans do not need to be contiguous&mdash;there may be
/// gaps or overlaps between spans in a trace.
struct Google_Devtools_Cloudtrace_V2_Span {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the span in the following format:
  ///
  ///     projects/[PROJECT_ID]/traces/[TRACE_ID]/spans/[SPAN_ID]
  ///
  /// [TRACE_ID] is a unique identifier for a trace within a project;
  /// it is a 32-character hexadecimal encoding of a 16-byte array.
  ///
  /// [SPAN_ID] is a unique identifier for a span within a trace; it
  /// is a 16-character hexadecimal encoding of an 8-byte array.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. The [SPAN_ID] portion of the span's resource name.
  var spanID: String {
    get {return _storage._spanID}
    set {_uniqueStorage()._spanID = newValue}
  }

  /// The [SPAN_ID] of this span's parent span. If this is a root span,
  /// then this field must be empty.
  var parentSpanID: String {
    get {return _storage._parentSpanID}
    set {_uniqueStorage()._parentSpanID = newValue}
  }

  /// Required. A description of the span's operation (up to 128 bytes).
  /// Stackdriver Trace displays the description in the
  /// Google Cloud Platform Console.
  /// For example, the display name can be a qualified method name or a file name
  /// and a line number where the operation is called. A best practice is to use
  /// the same display name within an application and at the same call point.
  /// This makes it easier to correlate spans in different traces.
  var displayName: Google_Devtools_Cloudtrace_V2_TruncatableString {
    get {return _storage._displayName ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
    set {_uniqueStorage()._displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  var hasDisplayName: Bool {return _storage._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  mutating func clearDisplayName() {_uniqueStorage()._displayName = nil}

  /// Required. The start time of the span. On the client side, this is the time kept by
  /// the local machine where the span execution starts. On the server side, this
  /// is the time when the server's application handler starts running.
  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Required. The end time of the span. On the client side, this is the time kept by
  /// the local machine where the span execution ends. On the server side, this
  /// is the time when the server application handler stops running.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// A set of attributes on the span. You can have up to 32 attributes per
  /// span.
  var attributes: Google_Devtools_Cloudtrace_V2_Span.Attributes {
    get {return _storage._attributes ?? Google_Devtools_Cloudtrace_V2_Span.Attributes()}
    set {_uniqueStorage()._attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return _storage._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

  /// Stack trace captured at the start of the span.
  var stackTrace: Google_Devtools_Cloudtrace_V2_StackTrace {
    get {return _storage._stackTrace ?? Google_Devtools_Cloudtrace_V2_StackTrace()}
    set {_uniqueStorage()._stackTrace = newValue}
  }
  /// Returns true if `stackTrace` has been explicitly set.
  var hasStackTrace: Bool {return _storage._stackTrace != nil}
  /// Clears the value of `stackTrace`. Subsequent reads from it will return its default value.
  mutating func clearStackTrace() {_uniqueStorage()._stackTrace = nil}

  /// A set of time events. You can have up to 32 annotations and 128 message
  /// events per span.
  var timeEvents: Google_Devtools_Cloudtrace_V2_Span.TimeEvents {
    get {return _storage._timeEvents ?? Google_Devtools_Cloudtrace_V2_Span.TimeEvents()}
    set {_uniqueStorage()._timeEvents = newValue}
  }
  /// Returns true if `timeEvents` has been explicitly set.
  var hasTimeEvents: Bool {return _storage._timeEvents != nil}
  /// Clears the value of `timeEvents`. Subsequent reads from it will return its default value.
  mutating func clearTimeEvents() {_uniqueStorage()._timeEvents = nil}

  /// Links associated with the span. You can have up to 128 links per Span.
  var links: Google_Devtools_Cloudtrace_V2_Span.Links {
    get {return _storage._links ?? Google_Devtools_Cloudtrace_V2_Span.Links()}
    set {_uniqueStorage()._links = newValue}
  }
  /// Returns true if `links` has been explicitly set.
  var hasLinks: Bool {return _storage._links != nil}
  /// Clears the value of `links`. Subsequent reads from it will return its default value.
  mutating func clearLinks() {_uniqueStorage()._links = nil}

  /// Optional. The final status for this span.
  var status: Google_Rpc_Status {
    get {return _storage._status ?? Google_Rpc_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Optional. Set this parameter to indicate whether this span is in
  /// the same process as its parent. If you do not set this parameter,
  /// Stackdriver Trace is unable to take advantage of this helpful
  /// information.
  var sameProcessAsParentSpan: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._sameProcessAsParentSpan ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._sameProcessAsParentSpan = newValue}
  }
  /// Returns true if `sameProcessAsParentSpan` has been explicitly set.
  var hasSameProcessAsParentSpan: Bool {return _storage._sameProcessAsParentSpan != nil}
  /// Clears the value of `sameProcessAsParentSpan`. Subsequent reads from it will return its default value.
  mutating func clearSameProcessAsParentSpan() {_uniqueStorage()._sameProcessAsParentSpan = nil}

  /// Optional. The number of child spans that were generated while this span
  /// was active. If set, allows implementation to detect missing child spans.
  var childSpanCount: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._childSpanCount ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._childSpanCount = newValue}
  }
  /// Returns true if `childSpanCount` has been explicitly set.
  var hasChildSpanCount: Bool {return _storage._childSpanCount != nil}
  /// Clears the value of `childSpanCount`. Subsequent reads from it will return its default value.
  mutating func clearChildSpanCount() {_uniqueStorage()._childSpanCount = nil}

  /// Optional. Distinguishes between spans generated in a particular context. For example,
  /// two spans with the same name may be distinguished using `CLIENT` (caller)
  /// and `SERVER` (callee) to identify an RPC call.
  var spanKind: Google_Devtools_Cloudtrace_V2_Span.SpanKind {
    get {return _storage._spanKind}
    set {_uniqueStorage()._spanKind = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of span. Can be used to specify additional relationships between spans
  /// in addition to a parent/child relationship.
  enum SpanKind: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unspecified. Do NOT use as default.
    /// Implementations MAY assume SpanKind.INTERNAL to be default.
    case unspecified // = 0

    /// Indicates that the span is used internally. Default value.
    case `internal` // = 1

    /// Indicates that the span covers server-side handling of an RPC or other
    /// remote network request.
    case server // = 2

    /// Indicates that the span covers the client-side wrapper around an RPC or
    /// other remote request.
    case client // = 3

    /// Indicates that the span describes producer sending a message to a broker.
    /// Unlike client and  server, there is no direct critical path latency
    /// relationship between producer and consumer spans (e.g. publishing a
    /// message to a pubsub service).
    case producer // = 4

    /// Indicates that the span describes consumer receiving a message from a
    /// broker. Unlike client and  server, there is no direct critical path
    /// latency relationship between producer and consumer spans (e.g. receiving
    /// a message from a pubsub service subscription).
    case consumer // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .server
      case 3: self = .client
      case 4: self = .producer
      case 5: self = .consumer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .server: return 2
      case .client: return 3
      case .producer: return 4
      case .consumer: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A set of attributes, each in the format `[KEY]:[VALUE]`.
  struct Attributes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of attributes. Each attribute's key can be up to 128 bytes
    /// long. The value can be a string up to 256 bytes, a signed 64-bit integer,
    /// or the Boolean values `true` and `false`. For example:
    ///
    ///     "/instance_id": { "string_value": { "value": "my-instance" } }
    ///     "/http/request_bytes": { "int_value": 300 }
    ///     "abc.com/myattribute": { "bool_value": false }
    var attributeMap: Dictionary<String,Google_Devtools_Cloudtrace_V2_AttributeValue> = [:]

    /// The number of attributes that were discarded. Attributes can be discarded
    /// because their keys are too long or because there are too many attributes.
    /// If this value is 0 then all attributes are valid.
    var droppedAttributesCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A time-stamped annotation or message event in the Span.
  struct TimeEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The timestamp indicating the time the event occurred.
    var time: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() {self._time = nil}

    /// A `TimeEvent` can contain either an `Annotation` object or a
    /// `MessageEvent` object, but not both.
    var value: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.OneOf_Value? = nil

    /// Text annotation with a set of attributes.
    var annotation: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation {
      get {
        if case .annotation(let v)? = value {return v}
        return Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation()
      }
      set {value = .annotation(newValue)}
    }

    /// An event describing a message sent/received between Spans.
    var messageEvent: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent {
      get {
        if case .messageEvent(let v)? = value {return v}
        return Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent()
      }
      set {value = .messageEvent(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A `TimeEvent` can contain either an `Annotation` object or a
    /// `MessageEvent` object, but not both.
    enum OneOf_Value: Equatable {
      /// Text annotation with a set of attributes.
      case annotation(Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation)
      /// An event describing a message sent/received between Spans.
      case messageEvent(Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent)

    #if !swift(>=4.1)
      static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.OneOf_Value, rhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.OneOf_Value) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.annotation, .annotation): return {
          guard case .annotation(let l) = lhs, case .annotation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.messageEvent, .messageEvent): return {
          guard case .messageEvent(let l) = lhs, case .messageEvent(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Text annotation with a set of attributes.
    struct Annotation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A user-supplied message describing the event. The maximum length for
      /// the description is 256 bytes.
      var description_p: Google_Devtools_Cloudtrace_V2_TruncatableString {
        get {return _description_p ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
        set {_description_p = newValue}
      }
      /// Returns true if `description_p` has been explicitly set.
      var hasDescription_p: Bool {return self._description_p != nil}
      /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
      mutating func clearDescription_p() {self._description_p = nil}

      /// A set of attributes on the annotation. You can have up to 4 attributes
      /// per Annotation.
      var attributes: Google_Devtools_Cloudtrace_V2_Span.Attributes {
        get {return _attributes ?? Google_Devtools_Cloudtrace_V2_Span.Attributes()}
        set {_attributes = newValue}
      }
      /// Returns true if `attributes` has been explicitly set.
      var hasAttributes: Bool {return self._attributes != nil}
      /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
      mutating func clearAttributes() {self._attributes = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _description_p: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
      fileprivate var _attributes: Google_Devtools_Cloudtrace_V2_Span.Attributes? = nil
    }

    /// An event describing a message sent/received between Spans.
    struct MessageEvent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Type of MessageEvent. Indicates whether the message was sent or
      /// received.
      var type: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent.TypeEnum = .unspecified

      /// An identifier for the MessageEvent's message that can be used to match
      /// SENT and RECEIVED MessageEvents. It is recommended to be unique within
      /// a Span.
      var id: Int64 = 0

      /// The number of uncompressed bytes sent or received.
      var uncompressedSizeBytes: Int64 = 0

      /// The number of compressed bytes sent or received. If missing assumed to
      /// be the same size as uncompressed.
      var compressedSizeBytes: Int64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Indicates whether the message was sent or received.
      enum TypeEnum: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// Unknown event type.
        case unspecified // = 0

        /// Indicates a sent message.
        case sent // = 1

        /// Indicates a received message.
        case received // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unspecified
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .sent
          case 2: self = .received
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .sent: return 1
          case .received: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    init() {}

    fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  /// A collection of `TimeEvent`s. A `TimeEvent` is a time-stamped annotation
  /// on the span, consisting of either user-supplied key:value pairs, or
  /// details of a message sent/received between Spans.
  struct TimeEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A collection of `TimeEvent`s.
    var timeEvent: [Google_Devtools_Cloudtrace_V2_Span.TimeEvent] = []

    /// The number of dropped annotations in all the included time events.
    /// If the value is 0, then no annotations were dropped.
    var droppedAnnotationsCount: Int32 = 0

    /// The number of dropped message events in all the included time events.
    /// If the value is 0, then no message events were dropped.
    var droppedMessageEventsCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A pointer from the current span to another span in the same trace or in a
  /// different trace. For example, this can be used in batching operations,
  /// where a single batch handler processes multiple requests from different
  /// traces or when the handler receives a request from a different project.
  struct Link {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The [TRACE_ID] for a trace within a project.
    var traceID: String = String()

    /// The [SPAN_ID] for a span within a trace.
    var spanID: String = String()

    /// The relationship of the current span relative to the linked span.
    var type: Google_Devtools_Cloudtrace_V2_Span.Link.TypeEnum = .unspecified

    /// A set of attributes on the link. You have have up to  32 attributes per
    /// link.
    var attributes: Google_Devtools_Cloudtrace_V2_Span.Attributes {
      get {return _attributes ?? Google_Devtools_Cloudtrace_V2_Span.Attributes()}
      set {_attributes = newValue}
    }
    /// Returns true if `attributes` has been explicitly set.
    var hasAttributes: Bool {return self._attributes != nil}
    /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
    mutating func clearAttributes() {self._attributes = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The relationship of the current span relative to the linked span: child,
    /// parent, or unspecified.
    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// The relationship of the two spans is unknown.
      case unspecified // = 0

      /// The linked span is a child of the current span.
      case childLinkedSpan // = 1

      /// The linked span is a parent of the current span.
      case parentLinkedSpan // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .childLinkedSpan
        case 2: self = .parentLinkedSpan
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .childLinkedSpan: return 1
        case .parentLinkedSpan: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _attributes: Google_Devtools_Cloudtrace_V2_Span.Attributes? = nil
  }

  /// A collection of links, which are references from this span to a span
  /// in the same or different trace.
  struct Links {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A collection of links.
    var link: [Google_Devtools_Cloudtrace_V2_Span.Link] = []

    /// The number of dropped links after the maximum size was enforced. If
    /// this value is 0, then no links were dropped.
    var droppedLinksCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Devtools_Cloudtrace_V2_Span.SpanKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Google_Devtools_Cloudtrace_V2_Span.SpanKind] = [
    .unspecified,
    .internal,
    .server,
    .client,
    .producer,
    .consumer,
  ]
}

extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent.TypeEnum] = [
    .unspecified,
    .sent,
    .received,
  ]
}

extension Google_Devtools_Cloudtrace_V2_Span.Link.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Google_Devtools_Cloudtrace_V2_Span.Link.TypeEnum] = [
    .unspecified,
    .childLinkedSpan,
    .parentLinkedSpan,
  ]
}

#endif  // swift(>=4.2)

/// The allowed types for [VALUE] in a `[KEY]:[VALUE]` attribute.
struct Google_Devtools_Cloudtrace_V2_AttributeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the value.
  var value: Google_Devtools_Cloudtrace_V2_AttributeValue.OneOf_Value? = nil

  /// A string up to 256 bytes long.
  var stringValue: Google_Devtools_Cloudtrace_V2_TruncatableString {
    get {
      if case .stringValue(let v)? = value {return v}
      return Google_Devtools_Cloudtrace_V2_TruncatableString()
    }
    set {value = .stringValue(newValue)}
  }

  /// A 64-bit signed integer.
  var intValue: Int64 {
    get {
      if case .intValue(let v)? = value {return v}
      return 0
    }
    set {value = .intValue(newValue)}
  }

  /// A Boolean value represented by `true` or `false`.
  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of the value.
  enum OneOf_Value: Equatable {
    /// A string up to 256 bytes long.
    case stringValue(Google_Devtools_Cloudtrace_V2_TruncatableString)
    /// A 64-bit signed integer.
    case intValue(Int64)
    /// A Boolean value represented by `true` or `false`.
    case boolValue(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Devtools_Cloudtrace_V2_AttributeValue.OneOf_Value, rhs: Google_Devtools_Cloudtrace_V2_AttributeValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intValue, .intValue): return {
        guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A call stack appearing in a trace.
struct Google_Devtools_Cloudtrace_V2_StackTrace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stack frames in this stack trace. A maximum of 128 frames are allowed.
  var stackFrames: Google_Devtools_Cloudtrace_V2_StackTrace.StackFrames {
    get {return _stackFrames ?? Google_Devtools_Cloudtrace_V2_StackTrace.StackFrames()}
    set {_stackFrames = newValue}
  }
  /// Returns true if `stackFrames` has been explicitly set.
  var hasStackFrames: Bool {return self._stackFrames != nil}
  /// Clears the value of `stackFrames`. Subsequent reads from it will return its default value.
  mutating func clearStackFrames() {self._stackFrames = nil}

  /// The hash ID is used to conserve network bandwidth for duplicate
  /// stack traces within a single trace.
  ///
  /// Often multiple spans will have identical stack traces.
  /// The first occurrence of a stack trace should contain both the
  /// `stackFrame` content and a value in `stackTraceHashId`.
  ///
  /// Subsequent spans within the same request can refer
  /// to that stack trace by only setting `stackTraceHashId`.
  var stackTraceHashID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents a single stack frame in a stack trace.
  struct StackFrame {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The fully-qualified name that uniquely identifies the function or
    /// method that is active in this frame (up to 1024 bytes).
    var functionName: Google_Devtools_Cloudtrace_V2_TruncatableString {
      get {return _functionName ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
      set {_functionName = newValue}
    }
    /// Returns true if `functionName` has been explicitly set.
    var hasFunctionName: Bool {return self._functionName != nil}
    /// Clears the value of `functionName`. Subsequent reads from it will return its default value.
    mutating func clearFunctionName() {self._functionName = nil}

    /// An un-mangled function name, if `function_name` is
    /// [mangled](http://www.avabodh.com/cxxin/namemangling.html). The name can
    /// be fully-qualified (up to 1024 bytes).
    var originalFunctionName: Google_Devtools_Cloudtrace_V2_TruncatableString {
      get {return _originalFunctionName ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
      set {_originalFunctionName = newValue}
    }
    /// Returns true if `originalFunctionName` has been explicitly set.
    var hasOriginalFunctionName: Bool {return self._originalFunctionName != nil}
    /// Clears the value of `originalFunctionName`. Subsequent reads from it will return its default value.
    mutating func clearOriginalFunctionName() {self._originalFunctionName = nil}

    /// The name of the source file where the function call appears (up to 256
    /// bytes).
    var fileName: Google_Devtools_Cloudtrace_V2_TruncatableString {
      get {return _fileName ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
      set {_fileName = newValue}
    }
    /// Returns true if `fileName` has been explicitly set.
    var hasFileName: Bool {return self._fileName != nil}
    /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
    mutating func clearFileName() {self._fileName = nil}

    /// The line number in `file_name` where the function call appears.
    var lineNumber: Int64 = 0

    /// The column number where the function call appears, if available.
    /// This is important in JavaScript because of its anonymous functions.
    var columnNumber: Int64 = 0

    /// The binary module from where the code was loaded.
    var loadModule: Google_Devtools_Cloudtrace_V2_Module {
      get {return _loadModule ?? Google_Devtools_Cloudtrace_V2_Module()}
      set {_loadModule = newValue}
    }
    /// Returns true if `loadModule` has been explicitly set.
    var hasLoadModule: Bool {return self._loadModule != nil}
    /// Clears the value of `loadModule`. Subsequent reads from it will return its default value.
    mutating func clearLoadModule() {self._loadModule = nil}

    /// The version of the deployed source code (up to 128 bytes).
    var sourceVersion: Google_Devtools_Cloudtrace_V2_TruncatableString {
      get {return _sourceVersion ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
      set {_sourceVersion = newValue}
    }
    /// Returns true if `sourceVersion` has been explicitly set.
    var hasSourceVersion: Bool {return self._sourceVersion != nil}
    /// Clears the value of `sourceVersion`. Subsequent reads from it will return its default value.
    mutating func clearSourceVersion() {self._sourceVersion = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _functionName: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
    fileprivate var _originalFunctionName: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
    fileprivate var _fileName: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
    fileprivate var _loadModule: Google_Devtools_Cloudtrace_V2_Module? = nil
    fileprivate var _sourceVersion: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
  }

  /// A collection of stack frames, which can be truncated.
  struct StackFrames {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Stack frames in this call stack.
    var frame: [Google_Devtools_Cloudtrace_V2_StackTrace.StackFrame] = []

    /// The number of stack frames that were dropped because there
    /// were too many stack frames.
    /// If this value is 0, then no stack frames were dropped.
    var droppedFramesCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _stackFrames: Google_Devtools_Cloudtrace_V2_StackTrace.StackFrames? = nil
}

/// Binary module.
struct Google_Devtools_Cloudtrace_V2_Module {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For example: main binary, kernel modules, and dynamic libraries
  /// such as libc.so, sharedlib.so (up to 256 bytes).
  var module: Google_Devtools_Cloudtrace_V2_TruncatableString {
    get {return _module ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
    set {_module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  var hasModule: Bool {return self._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  mutating func clearModule() {self._module = nil}

  /// A unique identifier for the module, usually a hash of its
  /// contents (up to 128 bytes).
  var buildID: Google_Devtools_Cloudtrace_V2_TruncatableString {
    get {return _buildID ?? Google_Devtools_Cloudtrace_V2_TruncatableString()}
    set {_buildID = newValue}
  }
  /// Returns true if `buildID` has been explicitly set.
  var hasBuildID: Bool {return self._buildID != nil}
  /// Clears the value of `buildID`. Subsequent reads from it will return its default value.
  mutating func clearBuildID() {self._buildID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _module: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
  fileprivate var _buildID: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
}

/// Represents a string that might be shortened to a specified length.
struct Google_Devtools_Cloudtrace_V2_TruncatableString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The shortened string. For example, if the original string is 500
  /// bytes long and the limit of the string is 128 bytes, then
  /// `value` contains the first 128 bytes of the 500-byte string.
  ///
  /// Truncation always happens on a UTF8 character boundary. If there
  /// are multi-byte characters in the string, then the length of the
  /// shortened string might be less than the size limit.
  var value: String = String()

  /// The number of bytes removed from the original string. If this
  /// value is 0, then the string was not shortened.
  var truncatedByteCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Devtools_Cloudtrace_V2_Span: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.SpanKind: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.Attributes: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.OneOf_Value: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent.TypeEnum: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.TimeEvents: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.Link: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.Link.TypeEnum: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Span.Links: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_AttributeValue: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_AttributeValue.OneOf_Value: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_StackTrace: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_StackTrace.StackFrame: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_StackTrace.StackFrames: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_Module: @unchecked Sendable {}
extension Google_Devtools_Cloudtrace_V2_TruncatableString: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.cloudtrace.v2"

extension Google_Devtools_Cloudtrace_V2_Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Span"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "span_id"),
    3: .standard(proto: "parent_span_id"),
    4: .standard(proto: "display_name"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "end_time"),
    7: .same(proto: "attributes"),
    8: .standard(proto: "stack_trace"),
    9: .standard(proto: "time_events"),
    10: .same(proto: "links"),
    11: .same(proto: "status"),
    12: .standard(proto: "same_process_as_parent_span"),
    13: .standard(proto: "child_span_count"),
    14: .standard(proto: "span_kind"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _spanID: String = String()
    var _parentSpanID: String = String()
    var _displayName: Google_Devtools_Cloudtrace_V2_TruncatableString? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attributes: Google_Devtools_Cloudtrace_V2_Span.Attributes? = nil
    var _stackTrace: Google_Devtools_Cloudtrace_V2_StackTrace? = nil
    var _timeEvents: Google_Devtools_Cloudtrace_V2_Span.TimeEvents? = nil
    var _links: Google_Devtools_Cloudtrace_V2_Span.Links? = nil
    var _status: Google_Rpc_Status? = nil
    var _sameProcessAsParentSpan: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _childSpanCount: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _spanKind: Google_Devtools_Cloudtrace_V2_Span.SpanKind = .unspecified

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _spanID = source._spanID
      _parentSpanID = source._parentSpanID
      _displayName = source._displayName
      _startTime = source._startTime
      _endTime = source._endTime
      _attributes = source._attributes
      _stackTrace = source._stackTrace
      _timeEvents = source._timeEvents
      _links = source._links
      _status = source._status
      _sameProcessAsParentSpan = source._sameProcessAsParentSpan
      _childSpanCount = source._childSpanCount
      _spanKind = source._spanKind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._spanID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._parentSpanID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._displayName) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._attributes) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._stackTrace) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._timeEvents) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._links) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._sameProcessAsParentSpan) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._childSpanCount) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._spanKind) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._spanID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spanID, fieldNumber: 2)
      }
      if !_storage._parentSpanID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentSpanID, fieldNumber: 3)
      }
      try { if let v = _storage._displayName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._stackTrace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._timeEvents {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._links {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._sameProcessAsParentSpan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._childSpanCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._spanKind != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._spanKind, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span, rhs: Google_Devtools_Cloudtrace_V2_Span) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._spanID != rhs_storage._spanID {return false}
        if _storage._parentSpanID != rhs_storage._parentSpanID {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._stackTrace != rhs_storage._stackTrace {return false}
        if _storage._timeEvents != rhs_storage._timeEvents {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._sameProcessAsParentSpan != rhs_storage._sameProcessAsParentSpan {return false}
        if _storage._childSpanCount != rhs_storage._childSpanCount {return false}
        if _storage._spanKind != rhs_storage._spanKind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Span.SpanKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAN_KIND_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
    2: .same(proto: "SERVER"),
    3: .same(proto: "CLIENT"),
    4: .same(proto: "PRODUCER"),
    5: .same(proto: "CONSUMER"),
  ]
}

extension Google_Devtools_Cloudtrace_V2_Span.Attributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_Span.protoMessageName + ".Attributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_map"),
    2: .standard(proto: "dropped_attributes_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Devtools_Cloudtrace_V2_AttributeValue>.self, value: &self.attributeMap) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedAttributesCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attributeMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Devtools_Cloudtrace_V2_AttributeValue>.self, value: self.attributeMap, fieldNumber: 1)
    }
    if self.droppedAttributesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedAttributesCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.Attributes, rhs: Google_Devtools_Cloudtrace_V2_Span.Attributes) -> Bool {
    if lhs.attributeMap != rhs.attributeMap {return false}
    if lhs.droppedAttributesCount != rhs.droppedAttributesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_Span.protoMessageName + ".TimeEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "annotation"),
    3: .standard(proto: "message_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try {
        var v: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .annotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .annotation(v)
        }
      }()
      case 3: try {
        var v: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .messageEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .messageEvent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.value {
    case .annotation?: try {
      guard case .annotation(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .messageEvent?: try {
      guard case .messageEvent(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent, rhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_Span.TimeEvent.protoMessageName + ".Annotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation, rhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.Annotation) -> Bool {
    if lhs._description_p != rhs._description_p {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_Span.TimeEvent.protoMessageName + ".MessageEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "uncompressed_size_bytes"),
    4: .standard(proto: "compressed_size_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.uncompressedSizeBytes) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.compressedSizeBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.uncompressedSizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.uncompressedSizeBytes, fieldNumber: 3)
    }
    if self.compressedSizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.compressedSizeBytes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent, rhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.uncompressedSizeBytes != rhs.uncompressedSizeBytes {return false}
    if lhs.compressedSizeBytes != rhs.compressedSizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Span.TimeEvent.MessageEvent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "SENT"),
    2: .same(proto: "RECEIVED"),
  ]
}

extension Google_Devtools_Cloudtrace_V2_Span.TimeEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_Span.protoMessageName + ".TimeEvents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_event"),
    2: .standard(proto: "dropped_annotations_count"),
    3: .standard(proto: "dropped_message_events_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timeEvent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedAnnotationsCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.droppedMessageEventsCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timeEvent.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeEvent, fieldNumber: 1)
    }
    if self.droppedAnnotationsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedAnnotationsCount, fieldNumber: 2)
    }
    if self.droppedMessageEventsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedMessageEventsCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvents, rhs: Google_Devtools_Cloudtrace_V2_Span.TimeEvents) -> Bool {
    if lhs.timeEvent != rhs.timeEvent {return false}
    if lhs.droppedAnnotationsCount != rhs.droppedAnnotationsCount {return false}
    if lhs.droppedMessageEventsCount != rhs.droppedMessageEventsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Span.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_Span.protoMessageName + ".Link"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "span_id"),
    3: .same(proto: "type"),
    4: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.spanID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.traceID.isEmpty {
      try visitor.visitSingularStringField(value: self.traceID, fieldNumber: 1)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularStringField(value: self.spanID, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.Link, rhs: Google_Devtools_Cloudtrace_V2_Span.Link) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.type != rhs.type {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Span.Link.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "CHILD_LINKED_SPAN"),
    2: .same(proto: "PARENT_LINKED_SPAN"),
  ]
}

extension Google_Devtools_Cloudtrace_V2_Span.Links: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_Span.protoMessageName + ".Links"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "link"),
    2: .standard(proto: "dropped_links_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.link) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedLinksCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.link.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.link, fieldNumber: 1)
    }
    if self.droppedLinksCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedLinksCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Span.Links, rhs: Google_Devtools_Cloudtrace_V2_Span.Links) -> Bool {
    if lhs.link != rhs.link {return false}
    if lhs.droppedLinksCount != rhs.droppedLinksCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_AttributeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttributeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_value"),
    2: .standard(proto: "int_value"),
    3: .standard(proto: "bool_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Devtools_Cloudtrace_V2_TruncatableString?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .stringValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .intValue(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_AttributeValue, rhs: Google_Devtools_Cloudtrace_V2_AttributeValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_StackTrace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StackTrace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stack_frames"),
    2: .standard(proto: "stack_trace_hash_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stackFrames) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.stackTraceHashID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stackFrames {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.stackTraceHashID != 0 {
      try visitor.visitSingularInt64Field(value: self.stackTraceHashID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_StackTrace, rhs: Google_Devtools_Cloudtrace_V2_StackTrace) -> Bool {
    if lhs._stackFrames != rhs._stackFrames {return false}
    if lhs.stackTraceHashID != rhs.stackTraceHashID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_StackTrace.StackFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_StackTrace.protoMessageName + ".StackFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_name"),
    2: .standard(proto: "original_function_name"),
    3: .standard(proto: "file_name"),
    4: .standard(proto: "line_number"),
    5: .standard(proto: "column_number"),
    6: .standard(proto: "load_module"),
    7: .standard(proto: "source_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._functionName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._originalFunctionName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fileName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lineNumber) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.columnNumber) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._loadModule) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._sourceVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._functionName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._originalFunctionName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.lineNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lineNumber, fieldNumber: 4)
    }
    if self.columnNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.columnNumber, fieldNumber: 5)
    }
    try { if let v = self._loadModule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._sourceVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_StackTrace.StackFrame, rhs: Google_Devtools_Cloudtrace_V2_StackTrace.StackFrame) -> Bool {
    if lhs._functionName != rhs._functionName {return false}
    if lhs._originalFunctionName != rhs._originalFunctionName {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs.lineNumber != rhs.lineNumber {return false}
    if lhs.columnNumber != rhs.columnNumber {return false}
    if lhs._loadModule != rhs._loadModule {return false}
    if lhs._sourceVersion != rhs._sourceVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_StackTrace.StackFrames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Devtools_Cloudtrace_V2_StackTrace.protoMessageName + ".StackFrames"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frame"),
    2: .standard(proto: "dropped_frames_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.frame) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedFramesCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frame.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frame, fieldNumber: 1)
    }
    if self.droppedFramesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedFramesCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_StackTrace.StackFrames, rhs: Google_Devtools_Cloudtrace_V2_StackTrace.StackFrames) -> Bool {
    if lhs.frame != rhs.frame {return false}
    if lhs.droppedFramesCount != rhs.droppedFramesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_Module: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Module"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .standard(proto: "build_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._module) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._buildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._module {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buildID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_Module, rhs: Google_Devtools_Cloudtrace_V2_Module) -> Bool {
    if lhs._module != rhs._module {return false}
    if lhs._buildID != rhs._buildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V2_TruncatableString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TruncatableString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "truncated_byte_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.truncatedByteCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.truncatedByteCount != 0 {
      try visitor.visitSingularInt32Field(value: self.truncatedByteCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Devtools_Cloudtrace_V2_TruncatableString, rhs: Google_Devtools_Cloudtrace_V2_TruncatableString) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.truncatedByteCount != rhs.truncatedByteCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
