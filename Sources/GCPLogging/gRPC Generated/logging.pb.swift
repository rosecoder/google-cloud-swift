// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/logging/v2/logging.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The parameters to DeleteLog.
struct Google_Logging_V2_DeleteLogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the log to delete:
  ///
  ///     "projects/[PROJECT_ID]/logs/[LOG_ID]"
  ///     "organizations/[ORGANIZATION_ID]/logs/[LOG_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]"
  ///     "folders/[FOLDER_ID]/logs/[LOG_ID]"
  ///
  /// `[LOG_ID]` must be URL-encoded. For example,
  /// `"projects/my-project-id/logs/syslog"`,
  /// `"organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
  /// For more information about log names, see
  /// [LogEntry][google.logging.v2.LogEntry].
  var logName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to WriteLogEntries.
struct Google_Logging_V2_WriteLogEntriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A default log resource name that is assigned to all log entries
  /// in `entries` that do not specify a value for `log_name`:
  ///
  ///     "projects/[PROJECT_ID]/logs/[LOG_ID]"
  ///     "organizations/[ORGANIZATION_ID]/logs/[LOG_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]"
  ///     "folders/[FOLDER_ID]/logs/[LOG_ID]"
  ///
  /// `[LOG_ID]` must be URL-encoded. For example:
  ///
  ///     "projects/my-project-id/logs/syslog"
  ///     "organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity"
  ///
  /// The permission `logging.logEntries.create` is needed on each project,
  /// organization, billing account, or folder that is receiving new log
  /// entries, whether the resource is specified in `logName` or in an
  /// individual log entry.
  var logName: String = String()

  /// Optional. A default monitored resource object that is assigned to all log
  /// entries in `entries` that do not specify a value for `resource`. Example:
  ///
  ///     { "type": "gce_instance",
  ///       "labels": {
  ///         "zone": "us-central1-a", "instance_id": "00000000000000000000" }}
  ///
  /// See [LogEntry][google.logging.v2.LogEntry].
  var resource: Google_Api_MonitoredResource {
    get {return _resource ?? Google_Api_MonitoredResource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// Optional. Default labels that are added to the `labels` field of all log
  /// entries in `entries`. If a log entry already has a label with the same key
  /// as a label in this parameter, then the log entry's label is not changed.
  /// See [LogEntry][google.logging.v2.LogEntry].
  var labels: Dictionary<String,String> = [:]

  /// Required. The log entries to send to Logging. The order of log
  /// entries in this list does not matter. Values supplied in this method's
  /// `log_name`, `resource`, and `labels` fields are copied into those log
  /// entries in this list that do not include values for their corresponding
  /// fields. For more information, see the
  /// [LogEntry][google.logging.v2.LogEntry] type.
  ///
  /// If the `timestamp` or `insert_id` fields are missing in log entries, then
  /// this method supplies the current time or a unique identifier, respectively.
  /// The supplied values are chosen so that, among the log entries that did not
  /// supply their own values, the entries earlier in the list will sort before
  /// the entries later in the list. See the `entries.list` method.
  ///
  /// Log entries with timestamps that are more than the
  /// [logs retention period](https://cloud.google.com/logging/quota-policy) in
  /// the past or more than 24 hours in the future will not be available when
  /// calling `entries.list`. However, those log entries can still be [exported
  /// with
  /// LogSinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
  ///
  /// To improve throughput and to avoid exceeding the
  /// [quota limit](https://cloud.google.com/logging/quota-policy) for calls to
  /// `entries.write`, you should try to include several log entries in this
  /// list, rather than calling this method for each individual log entry.
  var entries: [Google_Logging_V2_LogEntry] = []

  /// Optional. Whether valid entries should be written even if some other
  /// entries fail due to INVALID_ARGUMENT or PERMISSION_DENIED errors. If any
  /// entry is not written, then the response status is the error associated
  /// with one of the failed entries and the response includes error details
  /// keyed by the entries' zero-based index in the `entries.write` method.
  var partialSuccess: Bool = false

  /// Optional. If true, the request should expect normal response, but the
  /// entries won't be persisted nor exported. Useful for checking whether the
  /// logging API endpoints are working properly before sending valuable data.
  var dryRun: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resource: Google_Api_MonitoredResource? = nil
}

/// Result returned from WriteLogEntries.
struct Google_Logging_V2_WriteLogEntriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Error details for WriteLogEntries with partial success.
struct Google_Logging_V2_WriteLogEntriesPartialErrors {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When `WriteLogEntriesRequest.partial_success` is true, records the error
  /// status for entries that were not written due to a permanent error, keyed
  /// by the entry's zero-based index in `WriteLogEntriesRequest.entries`.
  ///
  /// Failed requests for which no entries are written will not include
  /// per-entry errors.
  var logEntryErrors: Dictionary<Int32,Google_Rpc_Status> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `ListLogEntries`.
struct Google_Logging_V2_ListLogEntriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Names of one or more parent resources from which to
  /// retrieve log entries:
  ///
  ///     "projects/[PROJECT_ID]"
  ///     "organizations/[ORGANIZATION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
  ///     "folders/[FOLDER_ID]"
  ///
  ///
  /// Projects listed in the `project_ids` field are added to this list.
  var resourceNames: [String] = []

  /// Optional. A filter that chooses which log entries to return.  See [Advanced
  /// Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries).
  /// Only log entries that match the filter are returned.  An empty filter
  /// matches all log entries in the resources listed in `resource_names`.
  /// Referencing a parent resource that is not listed in `resource_names` will
  /// cause the filter to return no results. The maximum length of the filter is
  /// 20000 characters.
  var filter: String = String()

  /// Optional. How the results should be sorted.  Presently, the only permitted
  /// values are `"timestamp asc"` (default) and `"timestamp desc"`. The first
  /// option returns entries in order of increasing values of
  /// `LogEntry.timestamp` (oldest first), and the second option returns entries
  /// in order of decreasing timestamps (newest first).  Entries with equal
  /// timestamps are returned in order of their `insert_id` values.
  var orderBy: String = String()

  /// Optional. The maximum number of results to return from this request.
  /// Default is 50. If the value is negative or exceeds 1000,
  /// the request is rejected. The presence of `next_page_token` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method.  `page_token` must be the value of
  /// `next_page_token` from the previous response.  The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from `ListLogEntries`.
struct Google_Logging_V2_ListLogEntriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of log entries.  If `entries` is empty, `nextPageToken` may still be
  /// returned, indicating that more entries may exist.  See `nextPageToken` for
  /// more information.
  var entries: [Google_Logging_V2_LogEntry] = []

  /// If there might be more results than those appearing in this response, then
  /// `nextPageToken` is included.  To get the next set of results, call this
  /// method again using the value of `nextPageToken` as `pageToken`.
  ///
  /// If a value for `next_page_token` appears and the `entries` field is empty,
  /// it means that the search found no log entries so far but it did not have
  /// time to search all the possible log entries.  Retry the method with this
  /// value for `page_token` to continue the search.  Alternatively, consider
  /// speeding up the search by changing your filter to specify a single log name
  /// or resource type, or to narrow the time range of the search.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to ListMonitoredResourceDescriptors
struct Google_Logging_V2_ListMonitoredResourceDescriptorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The maximum number of results to return from this request.
  /// Non-positive values are ignored.  The presence of `nextPageToken` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method.  `pageToken` must be the value of
  /// `nextPageToken` from the previous response.  The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from ListMonitoredResourceDescriptors.
struct Google_Logging_V2_ListMonitoredResourceDescriptorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of resource descriptors.
  var resourceDescriptors: [Google_Api_MonitoredResourceDescriptor] = []

  /// If there might be more results than those appearing in this response, then
  /// `nextPageToken` is included.  To get the next set of results, call this
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to ListLogs.
struct Google_Logging_V2_ListLogsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name that owns the logs:
  ///
  ///     "projects/[PROJECT_ID]"
  ///     "organizations/[ORGANIZATION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
  ///     "folders/[FOLDER_ID]"
  var parent: String = String()

  /// Optional. The maximum number of results to return from this request.
  /// Non-positive values are ignored.  The presence of `nextPageToken` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method.  `pageToken` must be the value of
  /// `nextPageToken` from the previous response.  The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from ListLogs.
struct Google_Logging_V2_ListLogsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of log names. For example,
  /// `"projects/my-project/logs/syslog"` or
  /// `"organizations/123/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
  var logNames: [String] = []

  /// If there might be more results than those appearing in this response, then
  /// `nextPageToken` is included.  To get the next set of results, call this
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.logging.v2"

extension Google_Logging_V2_DeleteLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteLogRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logName.isEmpty {
      try visitor.visitSingularStringField(value: self.logName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_DeleteLogRequest, rhs: Google_Logging_V2_DeleteLogRequest) -> Bool {
    if lhs.logName != rhs.logName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_WriteLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteLogEntriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_name"),
    2: .same(proto: "resource"),
    3: .same(proto: "labels"),
    4: .same(proto: "entries"),
    5: .standard(proto: "partial_success"),
    6: .standard(proto: "dry_run"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.partialSuccess) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.logName.isEmpty {
      try visitor.visitSingularStringField(value: self.logName, fieldNumber: 1)
    }
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 4)
    }
    if self.partialSuccess != false {
      try visitor.visitSingularBoolField(value: self.partialSuccess, fieldNumber: 5)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_WriteLogEntriesRequest, rhs: Google_Logging_V2_WriteLogEntriesRequest) -> Bool {
    if lhs.logName != rhs.logName {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.partialSuccess != rhs.partialSuccess {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_WriteLogEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteLogEntriesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_WriteLogEntriesResponse, rhs: Google_Logging_V2_WriteLogEntriesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_WriteLogEntriesPartialErrors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteLogEntriesPartialErrors"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_entry_errors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Google_Rpc_Status>.self, value: &self.logEntryErrors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logEntryErrors.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Google_Rpc_Status>.self, value: self.logEntryErrors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_WriteLogEntriesPartialErrors, rhs: Google_Logging_V2_WriteLogEntriesPartialErrors) -> Bool {
    if lhs.logEntryErrors != rhs.logEntryErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogEntriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "resource_names"),
    2: .same(proto: "filter"),
    3: .standard(proto: "order_by"),
    4: .standard(proto: "page_size"),
    5: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.resourceNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 5)
    }
    if !self.resourceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resourceNames, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogEntriesRequest, rhs: Google_Logging_V2_ListLogEntriesRequest) -> Bool {
    if lhs.resourceNames != rhs.resourceNames {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogEntriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogEntriesResponse, rhs: Google_Logging_V2_ListLogEntriesResponse) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListMonitoredResourceDescriptorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMonitoredResourceDescriptorsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListMonitoredResourceDescriptorsRequest, rhs: Google_Logging_V2_ListMonitoredResourceDescriptorsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListMonitoredResourceDescriptorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMonitoredResourceDescriptorsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_descriptors"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceDescriptors) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceDescriptors, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListMonitoredResourceDescriptorsResponse, rhs: Google_Logging_V2_ListMonitoredResourceDescriptorsResponse) -> Bool {
    if lhs.resourceDescriptors != rhs.resourceDescriptors {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogsRequest, rhs: Google_Logging_V2_ListLogsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "log_names"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.logNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.logNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logNames, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogsResponse, rhs: Google_Logging_V2_ListLogsResponse) -> Bool {
    if lhs.logNames != rhs.logNames {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
