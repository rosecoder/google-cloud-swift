// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/metric.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines a metric type and its schema. Once a metric descriptor is created,
/// deleting or altering it stops data collection and makes the metric type's
/// existing data unusable.
///
/// The following are specific rules for service defined Monitoring metric
/// descriptors:
///
/// * `type`, `metric_kind`, `value_type`, `description`, `display_name`,
///   `launch_stage` fields are all required. The `unit` field must be specified
///   if the `value_type` is any of DOUBLE, INT64, DISTRIBUTION.
/// * Maximum of default 500 metric descriptors per service is allowed.
/// * Maximum of default 10 labels per metric descriptor is allowed.
///
/// The default maximum limit can be overridden. Please follow
/// https://cloud.google.com/monitoring/quotas
struct Google_Api_MetricDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the metric descriptor.
  var name: String = String()

  /// The metric type, including its DNS name prefix. The type is not
  /// URL-encoded.
  ///
  /// All service defined metrics must be prefixed with the service name, in the
  /// format of `{service name}/{relative metric name}`, such as
  /// `cloudsql.googleapis.com/database/cpu/utilization`. The relative metric
  /// name must follow:
  ///
  /// * Only upper and lower-case letters, digits, '/' and underscores '_' are
  ///   allowed.
  /// * The maximum number of characters allowed for the relative_metric_name is
  ///   100.
  ///
  /// All user-defined metric types have the DNS name
  /// `custom.googleapis.com`, `external.googleapis.com`, or
  /// `logging.googleapis.com/user/`.
  ///
  /// Metric types should use a natural hierarchical grouping. For example:
  ///
  ///     "custom.googleapis.com/invoice/paid/amount"
  ///     "external.googleapis.com/prometheus/up"
  ///     "appengine.googleapis.com/http/server/response_latencies"
  var type: String = String()

  /// The set of labels that can be used to describe a specific
  /// instance of this metric type.
  ///
  /// The label key name must follow:
  ///
  /// * Only upper and lower-case letters, digits and underscores (_) are
  ///   allowed.
  /// * Label name must start with a letter or digit.
  /// * The maximum length of a label name is 100 characters.
  ///
  /// For example, the
  /// `appengine.googleapis.com/http/server/response_latencies` metric
  /// type has a label for the HTTP response code, `response_code`, so
  /// you can look at latencies for successful responses or just
  /// for responses that failed.
  var labels: [Google_Api_LabelDescriptor] = []

  /// Whether the metric records instantaneous values, changes to a value, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  var metricKind: Google_Api_MetricDescriptor.MetricKind = .unspecified

  /// Whether the measurement is an integer, a floating-point number, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  var valueType: Google_Api_MetricDescriptor.ValueType = .unspecified

  /// The units in which the metric value is reported. It is only applicable
  /// if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
  /// defines the representation of the stored metric values.
  ///
  /// Different systems may scale the values to be more easily displayed (so a
  /// value of `0.02KBy` _might_ be displayed as `20By`, and a value of
  /// `3523KBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is
  /// `KBy`, then the value of the metric is always in thousands of bytes, no
  /// matter how it may be displayed..
  ///
  /// If you want a custom metric to record the exact number of CPU-seconds used
  /// by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is
  /// `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005
  /// CPU-seconds, then the value is written as `12005`.
  ///
  /// Alternatively, if you want a custom metric to record data in a more
  /// granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is
  /// `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`),
  /// or use `Kis{CPU}` and write `11.723` (which is `12005/1024`).
  ///
  /// The supported units are a subset of [The Unified Code for Units of
  /// Measure](http://unitsofmeasure.org/ucum.html) standard:
  ///
  /// **Basic units (UNIT)**
  ///
  /// * `bit`   bit
  /// * `By`    byte
  /// * `s`     second
  /// * `min`   minute
  /// * `h`     hour
  /// * `d`     day
  /// * `1`     dimensionless
  ///
  /// **Prefixes (PREFIX)**
  ///
  /// * `k`     kilo    (10^3)
  /// * `M`     mega    (10^6)
  /// * `G`     giga    (10^9)
  /// * `T`     tera    (10^12)
  /// * `P`     peta    (10^15)
  /// * `E`     exa     (10^18)
  /// * `Z`     zetta   (10^21)
  /// * `Y`     yotta   (10^24)
  ///
  /// * `m`     milli   (10^-3)
  /// * `u`     micro   (10^-6)
  /// * `n`     nano    (10^-9)
  /// * `p`     pico    (10^-12)
  /// * `f`     femto   (10^-15)
  /// * `a`     atto    (10^-18)
  /// * `z`     zepto   (10^-21)
  /// * `y`     yocto   (10^-24)
  ///
  /// * `Ki`    kibi    (2^10)
  /// * `Mi`    mebi    (2^20)
  /// * `Gi`    gibi    (2^30)
  /// * `Ti`    tebi    (2^40)
  /// * `Pi`    pebi    (2^50)
  ///
  /// **Grammar**
  ///
  /// The grammar also includes these connectors:
  ///
  /// * `/`    division or ratio (as an infix operator). For examples,
  ///          `kBy/{email}` or `MiBy/10ms` (although you should almost never
  ///          have `/s` in a metric `unit`; rates should always be computed at
  ///          query time from the underlying cumulative or delta value).
  /// * `.`    multiplication or composition (as an infix operator). For
  ///          examples, `GBy.d` or `k{watt}.h`.
  ///
  /// The grammar for a unit is as follows:
  ///
  ///     Expression = Component { "." Component } { "/" Component } ;
  ///
  ///     Component = ( [ PREFIX ] UNIT | "%" ) [ Annotation ]
  ///               | Annotation
  ///               | "1"
  ///               ;
  ///
  ///     Annotation = "{" NAME "}" ;
  ///
  /// Notes:
  ///
  /// * `Annotation` is just a comment if it follows a `UNIT`. If the annotation
  ///    is used alone, then the unit is equivalent to `1`. For examples,
  ///    `{request}/s == 1/s`, `By{transmitted}/s == By/s`.
  /// * `NAME` is a sequence of non-blank printable ASCII characters not
  ///    containing `{` or `}`.
  /// * `1` represents a unitary [dimensionless
  ///    unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such
  ///    as in `1/s`. It is typically used when none of the basic units are
  ///    appropriate. For example, "new users per day" can be represented as
  ///    `1/d` or `{new-users}/d` (and a metric value `5` would mean "5 new
  ///    users). Alternatively, "thousands of page views per day" would be
  ///    represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric
  ///    value of `5.3` would mean "5300 page views per day").
  /// * `%` represents dimensionless value of 1/100, and annotates values giving
  ///    a percentage (so the metric values are typically in the range of 0..100,
  ///    and a metric value `3` means "3 percent").
  /// * `10^2.%` indicates a metric contains a ratio, typically in the range
  ///    0..1, that will be multiplied by 100 and displayed as a percentage
  ///    (so a metric value `0.03` means "3 percent").
  var unit: String = String()

  /// A detailed description of the metric, which can be used in documentation.
  var description_p: String = String()

  /// A concise name for the metric, which can be displayed in user interfaces.
  /// Use sentence case without an ending period, for example "Request count".
  /// This field is optional but it is recommended to be set for any metrics
  /// associated with user-visible concepts, such as Quota.
  var displayName: String = String()

  /// Optional. Metadata which can be used to guide usage of the metric.
  var metadata: Google_Api_MetricDescriptor.MetricDescriptorMetadata {
    get {return _metadata ?? Google_Api_MetricDescriptor.MetricDescriptorMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Optional. The launch stage of the metric definition.
  var launchStage: Google_Api_LaunchStage = .unspecified

  /// Read-only. If present, then a [time
  /// series][google.monitoring.v3.TimeSeries], which is identified partially by
  /// a metric type and a [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor], that is associated
  /// with this metric type can only be associated with one of the monitored
  /// resource types listed here.
  var monitoredResourceTypes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of measurement. It describes how the data is reported.
  enum MetricKind: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Do not use this default value.
    case unspecified // = 0

    /// An instantaneous measurement of a value.
    case gauge // = 1

    /// The change in a value during a time interval.
    case delta // = 2

    /// A value accumulated over a time interval.  Cumulative
    /// measurements in a time series should have the same start time
    /// and increasing end times, until an event resets the cumulative
    /// value to zero and sets a new start time for the following
    /// points.
    case cumulative // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .gauge
      case 2: self = .delta
      case 3: self = .cumulative
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .gauge: return 1
      case .delta: return 2
      case .cumulative: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The value type of a metric.
  enum ValueType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Do not use this default value.
    case unspecified // = 0

    /// The value is a boolean.
    /// This value type can be used only if the metric kind is `GAUGE`.
    case bool // = 1

    /// The value is a signed 64-bit integer.
    case int64 // = 2

    /// The value is a double precision floating point number.
    case double // = 3

    /// The value is a text string.
    /// This value type can be used only if the metric kind is `GAUGE`.
    case string // = 4

    /// The value is a [`Distribution`][google.api.Distribution].
    case distribution // = 5

    /// The value is money.
    case money // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bool
      case 2: self = .int64
      case 3: self = .double
      case 4: self = .string
      case 5: self = .distribution
      case 6: self = .money
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bool: return 1
      case .int64: return 2
      case .double: return 3
      case .string: return 4
      case .distribution: return 5
      case .money: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Additional annotations that can be used to guide the usage of a metric.
  struct MetricDescriptorMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Deprecated. Must use the [MetricDescriptor.launch_stage][google.api.MetricDescriptor.launch_stage] instead.
    var launchStage: Google_Api_LaunchStage = .unspecified

    /// The sampling period of metric data points. For metrics which are written
    /// periodically, consecutive data points are stored at this time interval,
    /// excluding data loss due to errors. Metrics with a higher granularity have
    /// a smaller sampling period.
    var samplePeriod: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _samplePeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_samplePeriod = newValue}
    }
    /// Returns true if `samplePeriod` has been explicitly set.
    var hasSamplePeriod: Bool {return self._samplePeriod != nil}
    /// Clears the value of `samplePeriod`. Subsequent reads from it will return its default value.
    mutating func clearSamplePeriod() {self._samplePeriod = nil}

    /// The delay of data points caused by ingestion. Data points older than this
    /// age are guaranteed to be ingested and available to be read, excluding
    /// data loss due to errors.
    var ingestDelay: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _ingestDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_ingestDelay = newValue}
    }
    /// Returns true if `ingestDelay` has been explicitly set.
    var hasIngestDelay: Bool {return self._ingestDelay != nil}
    /// Clears the value of `ingestDelay`. Subsequent reads from it will return its default value.
    mutating func clearIngestDelay() {self._ingestDelay = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _samplePeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _ingestDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  init() {}

  fileprivate var _metadata: Google_Api_MetricDescriptor.MetricDescriptorMetadata? = nil
}

#if swift(>=4.2)

extension Google_Api_MetricDescriptor.MetricKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Api_MetricDescriptor.MetricKind] = [
    .unspecified,
    .gauge,
    .delta,
    .cumulative,
  ]
}

extension Google_Api_MetricDescriptor.ValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Api_MetricDescriptor.ValueType] = [
    .unspecified,
    .bool,
    .int64,
    .double,
    .string,
    .distribution,
    .money,
  ]
}

#endif  // swift(>=4.2)

/// A specific metric, identified by specifying values for all of the
/// labels of a [`MetricDescriptor`][google.api.MetricDescriptor].
struct Google_Api_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An existing metric type, see [google.api.MetricDescriptor][google.api.MetricDescriptor].
  /// For example, `custom.googleapis.com/invoice/paid/amount`.
  var type: String = String()

  /// The set of label values that uniquely identify this metric. All
  /// labels listed in the `MetricDescriptor` must be assigned values.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api"

extension Google_Api_MetricDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetricDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    8: .same(proto: "type"),
    2: .same(proto: "labels"),
    3: .standard(proto: "metric_kind"),
    4: .standard(proto: "value_type"),
    5: .same(proto: "unit"),
    6: .same(proto: "description"),
    7: .standard(proto: "display_name"),
    10: .same(proto: "metadata"),
    12: .standard(proto: "launch_stage"),
    13: .standard(proto: "monitored_resource_types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.metricKind) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.valueType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.launchStage) }()
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.monitoredResourceTypes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 2)
    }
    if self.metricKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.metricKind, fieldNumber: 3)
    }
    if self.valueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.valueType, fieldNumber: 4)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 7)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 8)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.launchStage != .unspecified {
      try visitor.visitSingularEnumField(value: self.launchStage, fieldNumber: 12)
    }
    if !self.monitoredResourceTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.monitoredResourceTypes, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_MetricDescriptor, rhs: Google_Api_MetricDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.metricKind != rhs.metricKind {return false}
    if lhs.valueType != rhs.valueType {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.launchStage != rhs.launchStage {return false}
    if lhs.monitoredResourceTypes != rhs.monitoredResourceTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_MetricDescriptor.MetricKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METRIC_KIND_UNSPECIFIED"),
    1: .same(proto: "GAUGE"),
    2: .same(proto: "DELTA"),
    3: .same(proto: "CUMULATIVE"),
  ]
}

extension Google_Api_MetricDescriptor.ValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALUE_TYPE_UNSPECIFIED"),
    1: .same(proto: "BOOL"),
    2: .same(proto: "INT64"),
    3: .same(proto: "DOUBLE"),
    4: .same(proto: "STRING"),
    5: .same(proto: "DISTRIBUTION"),
    6: .same(proto: "MONEY"),
  ]
}

extension Google_Api_MetricDescriptor.MetricDescriptorMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Api_MetricDescriptor.protoMessageName + ".MetricDescriptorMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "launch_stage"),
    2: .standard(proto: "sample_period"),
    3: .standard(proto: "ingest_delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.launchStage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._samplePeriod) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ingestDelay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.launchStage != .unspecified {
      try visitor.visitSingularEnumField(value: self.launchStage, fieldNumber: 1)
    }
    try { if let v = self._samplePeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ingestDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_MetricDescriptor.MetricDescriptorMetadata, rhs: Google_Api_MetricDescriptor.MetricDescriptorMetadata) -> Bool {
    if lhs.launchStage != rhs.launchStage {return false}
    if lhs._samplePeriod != rhs._samplePeriod {return false}
    if lhs._ingestDelay != rhs._ingestDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metric"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "type"),
    2: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Metric, rhs: Google_Api_Metric) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
