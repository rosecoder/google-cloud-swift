// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/logging/v2/logging.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The parameters to DeleteLog.
struct Google_Logging_V2_DeleteLogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the log to delete:
  ///
  /// * `projects/[PROJECT_ID]/logs/[LOG_ID]`
  /// * `organizations/[ORGANIZATION_ID]/logs/[LOG_ID]`
  /// * `billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]`
  /// * `folders/[FOLDER_ID]/logs/[LOG_ID]`
  ///
  /// `[LOG_ID]` must be URL-encoded. For example,
  /// `"projects/my-project-id/logs/syslog"`,
  /// `"organizations/123/logs/cloudaudit.googleapis.com%2Factivity"`.
  ///
  /// For more information about log names, see
  /// [LogEntry][google.logging.v2.LogEntry].
  var logName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to WriteLogEntries.
struct Google_Logging_V2_WriteLogEntriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A default log resource name that is assigned to all log entries
  /// in `entries` that do not specify a value for `log_name`:
  ///
  /// * `projects/[PROJECT_ID]/logs/[LOG_ID]`
  /// * `organizations/[ORGANIZATION_ID]/logs/[LOG_ID]`
  /// * `billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]`
  /// * `folders/[FOLDER_ID]/logs/[LOG_ID]`
  ///
  /// `[LOG_ID]` must be URL-encoded. For example:
  ///
  ///     "projects/my-project-id/logs/syslog"
  ///     "organizations/123/logs/cloudaudit.googleapis.com%2Factivity"
  ///
  /// The permission `logging.logEntries.create` is needed on each project,
  /// organization, billing account, or folder that is receiving new log
  /// entries, whether the resource is specified in `logName` or in an
  /// individual log entry.
  var logName: String = String()

  /// Optional. A default monitored resource object that is assigned to all log
  /// entries in `entries` that do not specify a value for `resource`. Example:
  ///
  ///     { "type": "gce_instance",
  ///       "labels": {
  ///         "zone": "us-central1-a", "instance_id": "00000000000000000000" }}
  ///
  /// See [LogEntry][google.logging.v2.LogEntry].
  var resource: Google_Api_MonitoredResource {
    get {return _resource ?? Google_Api_MonitoredResource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// Optional. Default labels that are added to the `labels` field of all log
  /// entries in `entries`. If a log entry already has a label with the same key
  /// as a label in this parameter, then the log entry's label is not changed.
  /// See [LogEntry][google.logging.v2.LogEntry].
  var labels: Dictionary<String,String> = [:]

  /// Required. The log entries to send to Logging. The order of log
  /// entries in this list does not matter. Values supplied in this method's
  /// `log_name`, `resource`, and `labels` fields are copied into those log
  /// entries in this list that do not include values for their corresponding
  /// fields. For more information, see the
  /// [LogEntry][google.logging.v2.LogEntry] type.
  ///
  /// If the `timestamp` or `insert_id` fields are missing in log entries, then
  /// this method supplies the current time or a unique identifier, respectively.
  /// The supplied values are chosen so that, among the log entries that did not
  /// supply their own values, the entries earlier in the list will sort before
  /// the entries later in the list. See the `entries.list` method.
  ///
  /// Log entries with timestamps that are more than the
  /// [logs retention period](https://cloud.google.com/logging/quotas) in
  /// the past or more than 24 hours in the future will not be available when
  /// calling `entries.list`. However, those log entries can still be [exported
  /// with
  /// LogSinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
  ///
  /// To improve throughput and to avoid exceeding the
  /// [quota limit](https://cloud.google.com/logging/quotas) for calls to
  /// `entries.write`, you should try to include several log entries in this
  /// list, rather than calling this method for each individual log entry.
  var entries: [Google_Logging_V2_LogEntry] = []

  /// Optional. Whether a batch's valid entries should be written even if some
  /// other entry failed due to a permanent error such as INVALID_ARGUMENT or
  /// PERMISSION_DENIED. If any entry failed, then the response status is the
  /// response status of one of the failed entries. The response will include
  /// error details in `WriteLogEntriesPartialErrors.log_entry_errors` keyed by
  /// the entries' zero-based index in the `entries`. Failed requests for which
  /// no entries are written will not include per-entry errors.
  var partialSuccess: Bool = false

  /// Optional. If true, the request should expect normal response, but the
  /// entries won't be persisted nor exported. Useful for checking whether the
  /// logging API endpoints are working properly before sending valuable data.
  var dryRun: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resource: Google_Api_MonitoredResource? = nil
}

/// Result returned from WriteLogEntries.
struct Google_Logging_V2_WriteLogEntriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Error details for WriteLogEntries with partial success.
struct Google_Logging_V2_WriteLogEntriesPartialErrors: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When `WriteLogEntriesRequest.partial_success` is true, records the error
  /// status for entries that were not written due to a permanent error, keyed
  /// by the entry's zero-based index in `WriteLogEntriesRequest.entries`.
  ///
  /// Failed requests for which no entries are written will not include
  /// per-entry errors.
  var logEntryErrors: Dictionary<Int32,Google_Rpc_Status> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `ListLogEntries`.
struct Google_Logging_V2_ListLogEntriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Names of one or more parent resources from which to
  /// retrieve log entries:
  ///
  /// *  `projects/[PROJECT_ID]`
  /// *  `organizations/[ORGANIZATION_ID]`
  /// *  `billingAccounts/[BILLING_ACCOUNT_ID]`
  /// *  `folders/[FOLDER_ID]`
  ///
  /// May alternatively be one or more views:
  ///
  ///  * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///
  /// Projects listed in the `project_ids` field are added to this list.
  /// A maximum of 100 resources may be specified in a single request.
  var resourceNames: [String] = []

  /// Optional. Only log entries that match the filter are returned.  An empty
  /// filter matches all log entries in the resources listed in `resource_names`.
  /// Referencing a parent resource that is not listed in `resource_names` will
  /// cause the filter to return no results. The maximum length of a filter is
  /// 20,000 characters.
  var filter: String = String()

  /// Optional. How the results should be sorted.  Presently, the only permitted
  /// values are `"timestamp asc"` (default) and `"timestamp desc"`. The first
  /// option returns entries in order of increasing values of
  /// `LogEntry.timestamp` (oldest first), and the second option returns entries
  /// in order of decreasing timestamps (newest first).  Entries with equal
  /// timestamps are returned in order of their `insert_id` values.
  var orderBy: String = String()

  /// Optional. The maximum number of results to return from this request.
  /// Default is 50. If the value is negative or exceeds 1000, the request is
  /// rejected. The presence of `next_page_token` in the response indicates that
  /// more results might be available.
  var pageSize: Int32 = 0

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method.  `page_token` must be the value of
  /// `next_page_token` from the previous response.  The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from `ListLogEntries`.
struct Google_Logging_V2_ListLogEntriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of log entries.  If `entries` is empty, `nextPageToken` may still be
  /// returned, indicating that more entries may exist.  See `nextPageToken` for
  /// more information.
  var entries: [Google_Logging_V2_LogEntry] = []

  /// If there might be more results than those appearing in this response, then
  /// `nextPageToken` is included.  To get the next set of results, call this
  /// method again using the value of `nextPageToken` as `pageToken`.
  ///
  /// If a value for `next_page_token` appears and the `entries` field is empty,
  /// it means that the search found no log entries so far but it did not have
  /// time to search all the possible log entries.  Retry the method with this
  /// value for `page_token` to continue the search.  Alternatively, consider
  /// speeding up the search by changing your filter to specify a single log name
  /// or resource type, or to narrow the time range of the search.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to ListMonitoredResourceDescriptors
struct Google_Logging_V2_ListMonitoredResourceDescriptorsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The maximum number of results to return from this request.
  /// Non-positive values are ignored.  The presence of `nextPageToken` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method.  `pageToken` must be the value of
  /// `nextPageToken` from the previous response.  The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from ListMonitoredResourceDescriptors.
struct Google_Logging_V2_ListMonitoredResourceDescriptorsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of resource descriptors.
  var resourceDescriptors: [Google_Api_MonitoredResourceDescriptor] = []

  /// If there might be more results than those appearing in this response, then
  /// `nextPageToken` is included.  To get the next set of results, call this
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to ListLogs.
struct Google_Logging_V2_ListLogsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name to list logs for:
  ///
  /// *  `projects/[PROJECT_ID]`
  /// *  `organizations/[ORGANIZATION_ID]`
  /// *  `billingAccounts/[BILLING_ACCOUNT_ID]`
  /// *  `folders/[FOLDER_ID]`
  var parent: String = String()

  /// Optional. List of resource names to list logs for:
  ///
  ///  * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///
  /// To support legacy queries, it could also be:
  ///
  /// *  `projects/[PROJECT_ID]`
  /// *  `organizations/[ORGANIZATION_ID]`
  /// *  `billingAccounts/[BILLING_ACCOUNT_ID]`
  /// *  `folders/[FOLDER_ID]`
  ///
  /// The resource name in the `parent` field is added to this list.
  var resourceNames: [String] = []

  /// Optional. The maximum number of results to return from this request.
  /// Non-positive values are ignored.  The presence of `nextPageToken` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method.  `pageToken` must be the value of
  /// `nextPageToken` from the previous response.  The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from ListLogs.
struct Google_Logging_V2_ListLogsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of log names. For example,
  /// `"projects/my-project/logs/syslog"` or
  /// `"organizations/123/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
  var logNames: [String] = []

  /// If there might be more results than those appearing in this response, then
  /// `nextPageToken` is included.  To get the next set of results, call this
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `TailLogEntries`.
struct Google_Logging_V2_TailLogEntriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of a parent resource from which to retrieve log entries:
  ///
  /// *  `projects/[PROJECT_ID]`
  /// *  `organizations/[ORGANIZATION_ID]`
  /// *  `billingAccounts/[BILLING_ACCOUNT_ID]`
  /// *  `folders/[FOLDER_ID]`
  ///
  /// May alternatively be one or more views:
  ///
  ///  * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  ///  * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
  var resourceNames: [String] = []

  /// Optional. Only log entries that match the filter are returned.  An empty
  /// filter matches all log entries in the resources listed in `resource_names`.
  /// Referencing a parent resource that is not listed in `resource_names` will
  /// cause the filter to return no results. The maximum length of a filter is
  /// 20,000 characters.
  var filter: String = String()

  /// Optional. The amount of time to buffer log entries at the server before
  /// being returned to prevent out of order results due to late arriving log
  /// entries. Valid values are between 0-60000 milliseconds. Defaults to 2000
  /// milliseconds.
  var bufferWindow: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _bufferWindow ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_bufferWindow = newValue}
  }
  /// Returns true if `bufferWindow` has been explicitly set.
  var hasBufferWindow: Bool {return self._bufferWindow != nil}
  /// Clears the value of `bufferWindow`. Subsequent reads from it will return its default value.
  mutating func clearBufferWindow() {self._bufferWindow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bufferWindow: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Result returned from `TailLogEntries`.
struct Google_Logging_V2_TailLogEntriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of log entries. Each response in the stream will order entries with
  /// increasing values of `LogEntry.timestamp`. Ordering is not guaranteed
  /// between separate responses.
  var entries: [Google_Logging_V2_LogEntry] = []

  /// If entries that otherwise would have been included in the session were not
  /// sent back to the client, counts of relevant entries omitted from the
  /// session with the reason that they were not included. There will be at most
  /// one of each reason per response. The counts represent the number of
  /// suppressed entries since the last streamed response.
  var suppressionInfo: [Google_Logging_V2_TailLogEntriesResponse.SuppressionInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information about entries that were omitted from the session.
  struct SuppressionInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The reason that entries were omitted from the session.
    var reason: Google_Logging_V2_TailLogEntriesResponse.SuppressionInfo.Reason = .unspecified

    /// A lower bound on the count of entries omitted due to `reason`.
    var suppressedCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An indicator of why entries were omitted.
    enum Reason: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int

      /// Unexpected default.
      case unspecified // = 0

      /// Indicates suppression occurred due to relevant entries being
      /// received in excess of rate limits. For quotas and limits, see
      /// [Logging API quotas and
      /// limits](https://cloud.google.com/logging/quotas#api-limits).
      case rateLimit // = 1

      /// Indicates suppression occurred due to the client not consuming
      /// responses quickly enough.
      case notConsumed // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .rateLimit
        case 2: self = .notConsumed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .rateLimit: return 1
        case .notConsumed: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Google_Logging_V2_TailLogEntriesResponse.SuppressionInfo.Reason] = [
        .unspecified,
        .rateLimit,
        .notConsumed,
      ]

    }

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.logging.v2"

extension Google_Logging_V2_DeleteLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteLogRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logName.isEmpty {
      try visitor.visitSingularStringField(value: self.logName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_DeleteLogRequest, rhs: Google_Logging_V2_DeleteLogRequest) -> Bool {
    if lhs.logName != rhs.logName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_WriteLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteLogEntriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_name"),
    2: .same(proto: "resource"),
    3: .same(proto: "labels"),
    4: .same(proto: "entries"),
    5: .standard(proto: "partial_success"),
    6: .standard(proto: "dry_run"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.partialSuccess) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.logName.isEmpty {
      try visitor.visitSingularStringField(value: self.logName, fieldNumber: 1)
    }
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 4)
    }
    if self.partialSuccess != false {
      try visitor.visitSingularBoolField(value: self.partialSuccess, fieldNumber: 5)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_WriteLogEntriesRequest, rhs: Google_Logging_V2_WriteLogEntriesRequest) -> Bool {
    if lhs.logName != rhs.logName {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.partialSuccess != rhs.partialSuccess {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_WriteLogEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteLogEntriesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_WriteLogEntriesResponse, rhs: Google_Logging_V2_WriteLogEntriesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_WriteLogEntriesPartialErrors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteLogEntriesPartialErrors"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_entry_errors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Google_Rpc_Status>.self, value: &self.logEntryErrors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logEntryErrors.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Google_Rpc_Status>.self, value: self.logEntryErrors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_WriteLogEntriesPartialErrors, rhs: Google_Logging_V2_WriteLogEntriesPartialErrors) -> Bool {
    if lhs.logEntryErrors != rhs.logEntryErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogEntriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "resource_names"),
    2: .same(proto: "filter"),
    3: .standard(proto: "order_by"),
    4: .standard(proto: "page_size"),
    5: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.resourceNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 5)
    }
    if !self.resourceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resourceNames, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogEntriesRequest, rhs: Google_Logging_V2_ListLogEntriesRequest) -> Bool {
    if lhs.resourceNames != rhs.resourceNames {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogEntriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogEntriesResponse, rhs: Google_Logging_V2_ListLogEntriesResponse) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListMonitoredResourceDescriptorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMonitoredResourceDescriptorsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListMonitoredResourceDescriptorsRequest, rhs: Google_Logging_V2_ListMonitoredResourceDescriptorsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListMonitoredResourceDescriptorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMonitoredResourceDescriptorsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_descriptors"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceDescriptors) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceDescriptors, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListMonitoredResourceDescriptorsResponse, rhs: Google_Logging_V2_ListMonitoredResourceDescriptorsResponse) -> Bool {
    if lhs.resourceDescriptors != rhs.resourceDescriptors {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    8: .standard(proto: "resource_names"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.resourceNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.resourceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resourceNames, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogsRequest, rhs: Google_Logging_V2_ListLogsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.resourceNames != rhs.resourceNames {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListLogsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLogsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "log_names"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.logNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.logNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logNames, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListLogsResponse, rhs: Google_Logging_V2_ListLogsResponse) -> Bool {
    if lhs.logNames != rhs.logNames {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_TailLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TailLogEntriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_names"),
    2: .same(proto: "filter"),
    3: .standard(proto: "buffer_window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.resourceNames) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bufferWindow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.resourceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resourceNames, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    try { if let v = self._bufferWindow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_TailLogEntriesRequest, rhs: Google_Logging_V2_TailLogEntriesRequest) -> Bool {
    if lhs.resourceNames != rhs.resourceNames {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs._bufferWindow != rhs._bufferWindow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_TailLogEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TailLogEntriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .standard(proto: "suppression_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.suppressionInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    if !self.suppressionInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suppressionInfo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_TailLogEntriesResponse, rhs: Google_Logging_V2_TailLogEntriesResponse) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.suppressionInfo != rhs.suppressionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_TailLogEntriesResponse.SuppressionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Logging_V2_TailLogEntriesResponse.protoMessageName + ".SuppressionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .standard(proto: "suppressed_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.suppressedCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unspecified {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if self.suppressedCount != 0 {
      try visitor.visitSingularInt32Field(value: self.suppressedCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_TailLogEntriesResponse.SuppressionInfo, rhs: Google_Logging_V2_TailLogEntriesResponse.SuppressionInfo) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.suppressedCount != rhs.suppressedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_TailLogEntriesResponse.SuppressionInfo.Reason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REASON_UNSPECIFIED"),
    1: .same(proto: "RATE_LIMIT"),
    2: .same(proto: "NOT_CONSUMED"),
  ]
}
