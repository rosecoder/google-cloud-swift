// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/logging/v2/logging_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// LogBucket lifecycle states.
enum Google_Logging_V2_LifecycleState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Unspecified state. This is only used/useful for distinguishing unset
  /// values.
  case unspecified // = 0

  /// The normal and active state.
  case active // = 1

  /// The resource has been marked for deletion by the user. For some resources
  /// (e.g. buckets), this can be reversed by an un-delete operation.
  case deleteRequested // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .active
    case 2: self = .deleteRequested
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .active: return 1
    case .deleteRequested: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Logging_V2_LifecycleState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Google_Logging_V2_LifecycleState] = [
    .unspecified,
    .active,
    .deleteRequested,
  ]
}

#endif  // swift(>=4.2)

/// List of different operation states.
/// High level state of the operation. This is used to report the job's
/// current state to the user. Once a long running operation is created,
/// the current state of the operation can be queried even before the
/// operation is finished and the final result is available.
enum Google_Logging_V2_OperationState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Should not be used.
  case unspecified // = 0

  /// The operation is scheduled.
  case scheduled // = 1

  /// Waiting for necessary permissions.
  case waitingForPermissions // = 2

  /// The operation is running.
  case running // = 3

  /// The operation was completed successfully.
  case succeeded // = 4

  /// The operation failed.
  case failed // = 5

  /// The operation was cancelled by the user.
  case cancelled // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .scheduled
    case 2: self = .waitingForPermissions
    case 3: self = .running
    case 4: self = .succeeded
    case 5: self = .failed
    case 6: self = .cancelled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .scheduled: return 1
    case .waitingForPermissions: return 2
    case .running: return 3
    case .succeeded: return 4
    case .failed: return 5
    case .cancelled: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Logging_V2_OperationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Google_Logging_V2_OperationState] = [
    .unspecified,
    .scheduled,
    .waitingForPermissions,
    .running,
    .succeeded,
    .failed,
    .cancelled,
  ]
}

#endif  // swift(>=4.2)

/// Describes a repository in which log entries are stored.
struct Google_Logging_V2_LogBucket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name of the bucket.
  ///
  /// For example:
  ///
  ///   `projects/my-project/locations/global/buckets/my-bucket`
  ///
  /// For a list of supported locations, see [Supported
  /// Regions](https://cloud.google.com/logging/docs/region-support)
  ///
  /// For the location of `global` it is unspecified where log entries are
  /// actually stored.
  ///
  /// After a bucket has been created, the location cannot be changed.
  var name: String = String()

  /// Describes this bucket.
  var description_p: String = String()

  /// Output only. The creation timestamp of the bucket. This is not set for any of the
  /// default buckets.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last update timestamp of the bucket.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  /// Logs will be retained by default for this amount of time, after which they
  /// will automatically be deleted. The minimum retention period is 1 day. If
  /// this value is set to zero at bucket creation time, the default time of 30
  /// days will be used.
  var retentionDays: Int32 = 0

  /// Whether the bucket is locked.
  ///
  /// The retention period on a locked bucket cannot be changed. Locked buckets
  /// may only be deleted if they are empty.
  var locked: Bool = false

  /// Output only. The bucket lifecycle state.
  var lifecycleState: Google_Logging_V2_LifecycleState = .unspecified

  /// Log entry field paths that are denied access in this bucket.
  ///
  /// The following fields and their children are eligible: `textPayload`,
  /// `jsonPayload`, `protoPayload`, `httpRequest`, `labels`, `sourceLocation`.
  ///
  /// Restricting a repeated field will restrict all values. Adding a parent will
  /// block all child fields. (e.g. `foo.bar` will block `foo.bar.baz`)
  var restrictedFields: [String] = []

  /// The CMEK settings of the log bucket. If present, new log entries written to
  /// this log bucket are encrypted using the CMEK key provided in this
  /// configuration. If a log bucket has CMEK settings, the CMEK settings cannot
  /// be disabled later by updating the log bucket. Changing the KMS key is
  /// allowed.
  var cmekSettings: Google_Logging_V2_CmekSettings {
    get {return _cmekSettings ?? Google_Logging_V2_CmekSettings()}
    set {_cmekSettings = newValue}
  }
  /// Returns true if `cmekSettings` has been explicitly set.
  var hasCmekSettings: Bool {return self._cmekSettings != nil}
  /// Clears the value of `cmekSettings`. Subsequent reads from it will return its default value.
  mutating func clearCmekSettings() {self._cmekSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _cmekSettings: Google_Logging_V2_CmekSettings? = nil
}

/// Describes a view over log entries in a bucket.
struct Google_Logging_V2_LogView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the view.
  ///
  /// For example:
  ///
  ///   `projects/my-project/locations/global/buckets/my-bucket/views/my-view`
  var name: String = String()

  /// Describes this view.
  var description_p: String = String()

  /// Output only. The creation timestamp of the view.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last update timestamp of the view.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  /// Filter that restricts which log entries in a bucket are visible in this
  /// view.
  ///
  /// Filters are restricted to be a logical AND of ==/!= of any of the
  /// following:
  ///
  ///   - originating project/folder/organization/billing account.
  ///   - resource type
  ///   - log id
  ///
  /// For example:
  ///
  ///   SOURCE("projects/myproject") AND resource.type = "gce_instance"
  ///                                AND LOG_ID("stdout")
  var filter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Describes a sink used to export log entries to one of the following
/// destinations in any project: a Cloud Storage bucket, a BigQuery dataset, a
/// Pub/Sub topic or a Cloud Logging log bucket. A logs filter controls which log
/// entries are exported. The sink must be created within a project,
/// organization, billing account, or folder.
struct Google_Logging_V2_LogSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The client-assigned sink identifier, unique within the project.
  ///
  /// For example: `"my-syslog-errors-to-pubsub"`. Sink identifiers are limited
  /// to 100 characters and can include only the following characters: upper and
  /// lower-case alphanumeric characters, underscores, hyphens, and periods.
  /// First character has to be alphanumeric.
  var name: String = String()

  /// Required. The export destination:
  ///
  ///     "storage.googleapis.com/[GCS_BUCKET]"
  ///     "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]"
  ///     "pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]"
  ///
  /// The sink's `writer_identity`, set when the sink is created, must have
  /// permission to write to the destination or else the log entries are not
  /// exported. For more information, see
  /// [Exporting Logs with
  /// Sinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
  var destination: String = String()

  /// Optional. An [advanced logs
  /// filter](https://cloud.google.com/logging/docs/view/advanced-queries). The
  /// only exported log entries are those that are in the resource owning the
  /// sink and that match the filter.
  ///
  /// For example:
  ///
  ///   `logName="projects/[PROJECT_ID]/logs/[LOG_ID]" AND severity>=ERROR`
  var filter: String = String()

  /// Optional. A description of this sink.
  ///
  /// The maximum length of the description is 8000 characters.
  var description_p: String = String()

  /// Optional. If set to true, then this sink is disabled and it does not export any log
  /// entries.
  var disabled: Bool = false

  /// Optional. Log entries that match any of these exclusion filters will not be exported.
  ///
  /// If a log entry is matched by both `filter` and one of `exclusion_filters`
  /// it will not be exported.
  var exclusions: [Google_Logging_V2_LogExclusion] = []

  /// Deprecated. This field is unused.
  var outputVersionFormat: Google_Logging_V2_LogSink.VersionFormat = .unspecified

  /// Output only. An IAM identity&mdash;a service account or group&mdash;under which Cloud
  /// Logging writes the exported log entries to the sink's destination. This
  /// field is set by
  /// [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink] and
  /// [sinks.update][google.logging.v2.ConfigServiceV2.UpdateSink] based on the
  /// value of `unique_writer_identity` in those methods.
  ///
  /// Until you grant this identity write-access to the destination, log entry
  /// exports from this sink will fail. For more information, see [Granting
  /// Access for a
  /// Resource](https://cloud.google.com/iam/docs/granting-roles-to-service-accounts#granting_access_to_a_service_account_for_a_resource).
  /// Consult the destination service's documentation to determine the
  /// appropriate IAM roles to assign to the identity.
  ///
  /// Sinks that have a destination that is a log bucket in the same project as
  /// the sink do not have a writer_identity and no additional permissions are
  /// required.
  var writerIdentity: String = String()

  /// Optional. This field applies only to sinks owned by organizations and folders. If the
  /// field is false, the default, only the logs owned by the sink's parent
  /// resource are available for export. If the field is true, then log entries
  /// from all the projects, folders, and billing accounts contained in the
  /// sink's parent resource are also available for export. Whether a particular
  /// log entry from the children is exported depends on the sink's filter
  /// expression.
  ///
  /// For example, if this field is true, then the filter
  /// `resource.type=gce_instance` would export all Compute Engine VM instance
  /// log entries from all projects in the sink's parent.
  ///
  /// To only export entries from certain child projects, filter on the project
  /// part of the log name:
  ///
  ///   logName:("projects/test-project1/" OR "projects/test-project2/") AND
  ///   resource.type=gce_instance
  var includeChildren: Bool = false

  /// Destination dependent options.
  var options: Google_Logging_V2_LogSink.OneOf_Options? = nil

  /// Optional. Options that affect sinks exporting data to BigQuery.
  var bigqueryOptions: Google_Logging_V2_BigQueryOptions {
    get {
      if case .bigqueryOptions(let v)? = options {return v}
      return Google_Logging_V2_BigQueryOptions()
    }
    set {options = .bigqueryOptions(newValue)}
  }

  /// Output only. The creation timestamp of the sink.
  ///
  /// This field may not be present for older sinks.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last update timestamp of the sink.
  ///
  /// This field may not be present for older sinks.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Destination dependent options.
  enum OneOf_Options: Equatable {
    /// Optional. Options that affect sinks exporting data to BigQuery.
    case bigqueryOptions(Google_Logging_V2_BigQueryOptions)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Logging_V2_LogSink.OneOf_Options, rhs: Google_Logging_V2_LogSink.OneOf_Options) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.bigqueryOptions, .bigqueryOptions): return {
        guard case .bigqueryOptions(let l) = lhs, case .bigqueryOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Deprecated. This is unused.
  enum VersionFormat: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// An unspecified format version that will default to V2.
    case unspecified // = 0

    /// `LogEntry` version 2 format.
    case v2 // = 1

    /// `LogEntry` version 1 format.
    case v1 // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .v2
      case 2: self = .v1
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .v2: return 1
      case .v1: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Logging_V2_LogSink.VersionFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Google_Logging_V2_LogSink.VersionFormat] = [
    .unspecified,
    .v2,
    .v1,
  ]
}

#endif  // swift(>=4.2)

/// Options that change functionality of a sink exporting data to BigQuery.
struct Google_Logging_V2_BigQueryOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether to use [BigQuery's partition
  /// tables](https://cloud.google.com/bigquery/docs/partitioned-tables). By
  /// default, Cloud Logging creates dated tables based on the log entries'
  /// timestamps, e.g. syslog_20170523. With partitioned tables the date suffix
  /// is no longer present and [special query
  /// syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
  /// has to be used instead. In both cases, tables are sharded based on UTC
  /// timezone.
  var usePartitionedTables: Bool = false

  /// Output only. True if new timestamp column based partitioning is in use, false if legacy
  /// ingestion-time partitioning is in use.
  ///
  /// All new sinks will have this field set true and will use timestamp column
  /// based partitioning. If use_partitioned_tables is false, this value has no
  /// meaning and will be false. Legacy sinks using partitioned tables will have
  /// this field set to false.
  var usesTimestampColumnPartitioning: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `ListBuckets`.
struct Google_Logging_V2_ListBucketsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource whose buckets are to be listed:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
  ///     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]"
  ///     "folders/[FOLDER_ID]/locations/[LOCATION_ID]"
  ///
  /// Note: The locations portion of the resource must be specified, but
  /// supplying the character `-` in place of [LOCATION_ID] will return all
  /// buckets.
  var parent: String = String()

  /// Optional. If present, then retrieve the next batch of results from the preceding call
  /// to this method. `pageToken` must be the value of `nextPageToken` from the
  /// previous response. The values of other method parameters should be
  /// identical to those in the previous call.
  var pageToken: String = String()

  /// Optional. The maximum number of results to return from this request. Non-positive
  /// values are ignored. The presence of `nextPageToken` in the response
  /// indicates that more results might be available.
  var pageSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response from ListBuckets.
struct Google_Logging_V2_ListBucketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of buckets.
  var buckets: [Google_Logging_V2_LogBucket] = []

  /// If there might be more results than appear in this response, then
  /// `nextPageToken` is included. To get the next set of results, call the same
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `CreateBucket`.
struct Google_Logging_V2_CreateBucketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource in which to create the log bucket:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global"`
  var parent: String = String()

  /// Required. A client-assigned identifier such as `"my-bucket"`. Identifiers are limited
  /// to 100 characters and can include only letters, digits, underscores,
  /// hyphens, and periods.
  var bucketID: String = String()

  /// Required. The new bucket. The region specified in the new bucket must be compliant
  /// with any Location Restriction Org Policy. The name field in the bucket is
  /// ignored.
  var bucket: Google_Logging_V2_LogBucket {
    get {return _bucket ?? Google_Logging_V2_LogBucket()}
    set {_bucket = newValue}
  }
  /// Returns true if `bucket` has been explicitly set.
  var hasBucket: Bool {return self._bucket != nil}
  /// Clears the value of `bucket`. Subsequent reads from it will return its default value.
  mutating func clearBucket() {self._bucket = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bucket: Google_Logging_V2_LogBucket? = nil
}

/// The parameters to `UpdateBucket`.
struct Google_Logging_V2_UpdateBucketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name of the bucket to update.
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-bucket"`
  var name: String = String()

  /// Required. The updated bucket.
  var bucket: Google_Logging_V2_LogBucket {
    get {return _bucket ?? Google_Logging_V2_LogBucket()}
    set {_bucket = newValue}
  }
  /// Returns true if `bucket` has been explicitly set.
  var hasBucket: Bool {return self._bucket != nil}
  /// Clears the value of `bucket`. Subsequent reads from it will return its default value.
  mutating func clearBucket() {self._bucket = nil}

  /// Required. Field mask that specifies the fields in `bucket` that need an update. A
  /// bucket field will be overwritten if, and only if, it is in the update mask.
  /// `name` and output only fields cannot be updated.
  ///
  /// For a detailed `FieldMask` definition, see:
  /// https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask
  ///
  /// For example: `updateMask=retention_days`
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bucket: Google_Logging_V2_LogBucket? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The parameters to `GetBucket`.
struct Google_Logging_V2_GetBucketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the bucket:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-bucket"`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `DeleteBucket`.
struct Google_Logging_V2_DeleteBucketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name of the bucket to delete.
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-bucket"`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `UndeleteBucket`.
struct Google_Logging_V2_UndeleteBucketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name of the bucket to undelete.
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-bucket"`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `ListViews`.
struct Google_Logging_V2_ListViewsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The bucket whose views are to be listed:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
  var parent: String = String()

  /// Optional. If present, then retrieve the next batch of results from the preceding call
  /// to this method. `pageToken` must be the value of `nextPageToken` from the
  /// previous response. The values of other method parameters should be
  /// identical to those in the previous call.
  var pageToken: String = String()

  /// Optional. The maximum number of results to return from this request.
  ///
  /// Non-positive values are ignored. The presence of `nextPageToken` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response from ListViews.
struct Google_Logging_V2_ListViewsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of views.
  var views: [Google_Logging_V2_LogView] = []

  /// If there might be more results than appear in this response, then
  /// `nextPageToken` is included. To get the next set of results, call the same
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `CreateView`.
struct Google_Logging_V2_CreateViewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The bucket in which to create the view
  ///
  ///     `"projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"`
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-bucket"`
  var parent: String = String()

  /// Required. The id to use for this view.
  var viewID: String = String()

  /// Required. The new view.
  var view: Google_Logging_V2_LogView {
    get {return _view ?? Google_Logging_V2_LogView()}
    set {_view = newValue}
  }
  /// Returns true if `view` has been explicitly set.
  var hasView: Bool {return self._view != nil}
  /// Clears the value of `view`. Subsequent reads from it will return its default value.
  mutating func clearView() {self._view = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _view: Google_Logging_V2_LogView? = nil
}

/// The parameters to `UpdateView`.
struct Google_Logging_V2_UpdateViewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name of the view to update
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
  var name: String = String()

  /// Required. The updated view.
  var view: Google_Logging_V2_LogView {
    get {return _view ?? Google_Logging_V2_LogView()}
    set {_view = newValue}
  }
  /// Returns true if `view` has been explicitly set.
  var hasView: Bool {return self._view != nil}
  /// Clears the value of `view`. Subsequent reads from it will return its default value.
  mutating func clearView() {self._view = nil}

  /// Optional. Field mask that specifies the fields in `view` that need
  /// an update. A field will be overwritten if, and only if, it is
  /// in the update mask. `name` and output only fields cannot be updated.
  ///
  /// For a detailed `FieldMask` definition, see
  /// https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask
  ///
  /// For example: `updateMask=filter`
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _view: Google_Logging_V2_LogView? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The parameters to `GetView`.
struct Google_Logging_V2_GetViewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the policy:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `DeleteView`.
struct Google_Logging_V2_DeleteViewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name of the view to delete:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
  ///
  /// For example:
  ///
  ///    `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `ListSinks`.
struct Google_Logging_V2_ListSinksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource whose sinks are to be listed:
  ///
  ///     "projects/[PROJECT_ID]"
  ///     "organizations/[ORGANIZATION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
  ///     "folders/[FOLDER_ID]"
  var parent: String = String()

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method. `pageToken` must be the value of
  /// `nextPageToken` from the previous response. The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  /// Optional. The maximum number of results to return from this request.
  /// Non-positive values are ignored. The presence of `nextPageToken` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from `ListSinks`.
struct Google_Logging_V2_ListSinksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of sinks.
  var sinks: [Google_Logging_V2_LogSink] = []

  /// If there might be more results than appear in this response, then
  /// `nextPageToken` is included. To get the next set of results, call the same
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `GetSink`.
struct Google_Logging_V2_GetSinkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the sink:
  ///
  ///     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
  ///     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
  ///     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/sinks/my-sink"`
  var sinkName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `CreateSink`.
struct Google_Logging_V2_CreateSinkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource in which to create the sink:
  ///
  ///     "projects/[PROJECT_ID]"
  ///     "organizations/[ORGANIZATION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
  ///     "folders/[FOLDER_ID]"
  ///
  /// For examples:
  ///
  ///   `"projects/my-project"`
  ///   `"organizations/123456789"`
  var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// Required. The new sink, whose `name` parameter is a sink identifier that
  /// is not already in use.
  var sink: Google_Logging_V2_LogSink {
    get {return _storage._sink ?? Google_Logging_V2_LogSink()}
    set {_uniqueStorage()._sink = newValue}
  }
  /// Returns true if `sink` has been explicitly set.
  var hasSink: Bool {return _storage._sink != nil}
  /// Clears the value of `sink`. Subsequent reads from it will return its default value.
  mutating func clearSink() {_uniqueStorage()._sink = nil}

  /// Optional. Determines the kind of IAM identity returned as `writer_identity`
  /// in the new sink. If this value is omitted or set to false, and if the
  /// sink's parent is a project, then the value returned as `writer_identity` is
  /// the same group or service account used by Cloud Logging before the addition
  /// of writer identities to this API. The sink's destination must be in the
  /// same project as the sink itself.
  ///
  /// If this field is set to true, or if the sink is owned by a non-project
  /// resource such as an organization, then the value of `writer_identity` will
  /// be a unique service account used only for exports from the new sink. For
  /// more information, see `writer_identity` in [LogSink][google.logging.v2.LogSink].
  var uniqueWriterIdentity: Bool {
    get {return _storage._uniqueWriterIdentity}
    set {_uniqueStorage()._uniqueWriterIdentity = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The parameters to `UpdateSink`.
struct Google_Logging_V2_UpdateSinkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name of the sink to update, including the parent
  /// resource and the sink identifier:
  ///
  ///     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
  ///     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
  ///     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/sinks/my-sink"`
  var sinkName: String {
    get {return _storage._sinkName}
    set {_uniqueStorage()._sinkName = newValue}
  }

  /// Required. The updated sink, whose name is the same identifier that appears as part
  /// of `sink_name`.
  var sink: Google_Logging_V2_LogSink {
    get {return _storage._sink ?? Google_Logging_V2_LogSink()}
    set {_uniqueStorage()._sink = newValue}
  }
  /// Returns true if `sink` has been explicitly set.
  var hasSink: Bool {return _storage._sink != nil}
  /// Clears the value of `sink`. Subsequent reads from it will return its default value.
  mutating func clearSink() {_uniqueStorage()._sink = nil}

  /// Optional. See [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink]
  /// for a description of this field. When updating a sink, the effect of this
  /// field on the value of `writer_identity` in the updated sink depends on both
  /// the old and new values of this field:
  ///
  /// +   If the old and new values of this field are both false or both true,
  ///     then there is no change to the sink's `writer_identity`.
  /// +   If the old value is false and the new value is true, then
  ///     `writer_identity` is changed to a unique service account.
  /// +   It is an error if the old value is true and the new value is
  ///     set to false or defaulted to false.
  var uniqueWriterIdentity: Bool {
    get {return _storage._uniqueWriterIdentity}
    set {_uniqueStorage()._uniqueWriterIdentity = newValue}
  }

  /// Optional. Field mask that specifies the fields in `sink` that need
  /// an update. A sink field will be overwritten if, and only if, it is
  /// in the update mask. `name` and output only fields cannot be updated.
  ///
  /// An empty `updateMask` is temporarily treated as using the following mask
  /// for backwards compatibility purposes:
  ///
  ///   `destination,filter,includeChildren`
  ///
  /// At some point in the future, behavior will be removed and specifying an
  /// empty `updateMask` will be an error.
  ///
  /// For a detailed `FieldMask` definition, see
  /// https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask
  ///
  /// For example: `updateMask=filter`
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The parameters to `DeleteSink`.
struct Google_Logging_V2_DeleteSinkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name of the sink to delete, including the parent
  /// resource and the sink identifier:
  ///
  ///     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
  ///     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
  ///     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/sinks/my-sink"`
  var sinkName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Specifies a set of log entries that are filtered out by a sink. If
/// your Google Cloud resource receives a large volume of log entries, you can
/// use exclusions to reduce your chargeable logs. Note that exclusions on
/// organization-level and folder-level sinks don't apply to child resources.
/// Note also that you cannot modify the _Required sink or exclude logs from it.
struct Google_Logging_V2_LogExclusion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A client-assigned identifier, such as `"load-balancer-exclusion"`.
  /// Identifiers are limited to 100 characters and can include only letters,
  /// digits, underscores, hyphens, and periods. First character has to be
  /// alphanumeric.
  var name: String = String()

  /// Optional. A description of this exclusion.
  var description_p: String = String()

  /// Required. An [advanced logs
  /// filter](https://cloud.google.com/logging/docs/view/advanced-queries) that
  /// matches the log entries to be excluded. By using the [sample
  /// function](https://cloud.google.com/logging/docs/view/advanced-queries#sample),
  /// you can exclude less than 100% of the matching log entries.
  ///
  /// For example, the following query matches 99% of low-severity log entries
  /// from Google Cloud Storage buckets:
  ///
  ///   `resource.type=gcs_bucket severity<ERROR sample(insertId, 0.99)`
  var filter: String = String()

  /// Optional. If set to True, then this exclusion is disabled and it does not
  /// exclude any log entries. You can [update an
  /// exclusion][google.logging.v2.ConfigServiceV2.UpdateExclusion] to change the
  /// value of this field.
  var disabled: Bool = false

  /// Output only. The creation timestamp of the exclusion.
  ///
  /// This field may not be present for older exclusions.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last update timestamp of the exclusion.
  ///
  /// This field may not be present for older exclusions.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The parameters to `ListExclusions`.
struct Google_Logging_V2_ListExclusionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource whose exclusions are to be listed.
  ///
  ///     "projects/[PROJECT_ID]"
  ///     "organizations/[ORGANIZATION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
  ///     "folders/[FOLDER_ID]"
  var parent: String = String()

  /// Optional. If present, then retrieve the next batch of results from the
  /// preceding call to this method. `pageToken` must be the value of
  /// `nextPageToken` from the previous response. The values of other method
  /// parameters should be identical to those in the previous call.
  var pageToken: String = String()

  /// Optional. The maximum number of results to return from this request.
  /// Non-positive values are ignored. The presence of `nextPageToken` in the
  /// response indicates that more results might be available.
  var pageSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result returned from `ListExclusions`.
struct Google_Logging_V2_ListExclusionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of exclusions.
  var exclusions: [Google_Logging_V2_LogExclusion] = []

  /// If there might be more results than appear in this response, then
  /// `nextPageToken` is included. To get the next set of results, call the same
  /// method again using the value of `nextPageToken` as `pageToken`.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `GetExclusion`.
struct Google_Logging_V2_GetExclusionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of an existing exclusion:
  ///
  ///     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
  ///     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
  ///     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/exclusions/my-exclusion"`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to `CreateExclusion`.
struct Google_Logging_V2_CreateExclusionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource in which to create the exclusion:
  ///
  ///     "projects/[PROJECT_ID]"
  ///     "organizations/[ORGANIZATION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
  ///     "folders/[FOLDER_ID]"
  ///
  /// For examples:
  ///
  ///   `"projects/my-logging-project"`
  ///   `"organizations/123456789"`
  var parent: String = String()

  /// Required. The new exclusion, whose `name` parameter is an exclusion name
  /// that is not already used in the parent resource.
  var exclusion: Google_Logging_V2_LogExclusion {
    get {return _exclusion ?? Google_Logging_V2_LogExclusion()}
    set {_exclusion = newValue}
  }
  /// Returns true if `exclusion` has been explicitly set.
  var hasExclusion: Bool {return self._exclusion != nil}
  /// Clears the value of `exclusion`. Subsequent reads from it will return its default value.
  mutating func clearExclusion() {self._exclusion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _exclusion: Google_Logging_V2_LogExclusion? = nil
}

/// The parameters to `UpdateExclusion`.
struct Google_Logging_V2_UpdateExclusionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the exclusion to update:
  ///
  ///     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
  ///     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
  ///     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/exclusions/my-exclusion"`
  var name: String = String()

  /// Required. New values for the existing exclusion. Only the fields specified in
  /// `update_mask` are relevant.
  var exclusion: Google_Logging_V2_LogExclusion {
    get {return _exclusion ?? Google_Logging_V2_LogExclusion()}
    set {_exclusion = newValue}
  }
  /// Returns true if `exclusion` has been explicitly set.
  var hasExclusion: Bool {return self._exclusion != nil}
  /// Clears the value of `exclusion`. Subsequent reads from it will return its default value.
  mutating func clearExclusion() {self._exclusion = nil}

  /// Required. A non-empty list of fields to change in the existing exclusion. New values
  /// for the fields are taken from the corresponding fields in the
  /// [LogExclusion][google.logging.v2.LogExclusion] included in this request. Fields not mentioned in
  /// `update_mask` are not changed and are ignored in the request.
  ///
  /// For example, to change the filter and description of an exclusion,
  /// specify an `update_mask` of `"filter,description"`.
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _exclusion: Google_Logging_V2_LogExclusion? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The parameters to `DeleteExclusion`.
struct Google_Logging_V2_DeleteExclusionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of an existing exclusion to delete:
  ///
  ///     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
  ///     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
  ///     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/exclusions/my-exclusion"`
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to
/// [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
struct Google_Logging_V2_GetCmekSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource for which to retrieve CMEK settings.
  ///
  ///     "projects/[PROJECT_ID]/cmekSettings"
  ///     "organizations/[ORGANIZATION_ID]/cmekSettings"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
  ///     "folders/[FOLDER_ID]/cmekSettings"
  ///
  /// For example:
  ///
  ///   `"organizations/12345/cmekSettings"`
  ///
  /// Note: CMEK for the Log Router can be configured for Google Cloud projects,
  /// folders, organizations and billing accounts. Once configured for an
  /// organization, it applies to all projects and folders in the Google Cloud
  /// organization.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to
/// [UpdateCmekSettings][google.logging.v2.ConfigServiceV2.UpdateCmekSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
struct Google_Logging_V2_UpdateCmekSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name for the CMEK settings to update.
  ///
  ///     "projects/[PROJECT_ID]/cmekSettings"
  ///     "organizations/[ORGANIZATION_ID]/cmekSettings"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
  ///     "folders/[FOLDER_ID]/cmekSettings"
  ///
  /// For example:
  ///
  ///   `"organizations/12345/cmekSettings"`
  ///
  /// Note: CMEK for the Log Router can currently only be configured for Google
  /// Cloud organizations. Once configured, it applies to all projects and
  /// folders in the Google Cloud organization.
  var name: String = String()

  /// Required. The CMEK settings to update.
  ///
  /// See [Enabling CMEK for Log
  /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
  /// for more information.
  var cmekSettings: Google_Logging_V2_CmekSettings {
    get {return _cmekSettings ?? Google_Logging_V2_CmekSettings()}
    set {_cmekSettings = newValue}
  }
  /// Returns true if `cmekSettings` has been explicitly set.
  var hasCmekSettings: Bool {return self._cmekSettings != nil}
  /// Clears the value of `cmekSettings`. Subsequent reads from it will return its default value.
  mutating func clearCmekSettings() {self._cmekSettings = nil}

  /// Optional. Field mask identifying which fields from `cmek_settings` should
  /// be updated. A field will be overwritten if and only if it is in the update
  /// mask. Output only fields cannot be updated.
  ///
  /// See [FieldMask][google.protobuf.FieldMask] for more information.
  ///
  /// For example: `"updateMask=kmsKeyName"`
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cmekSettings: Google_Logging_V2_CmekSettings? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Describes the customer-managed encryption key (CMEK) settings associated with
/// a project, folder, organization, billing account, or flexible resource.
///
/// Note: CMEK for the Log Router can currently only be configured for Google
/// Cloud organizations. Once configured, it applies to all projects and folders
/// in the Google Cloud organization.
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
struct Google_Logging_V2_CmekSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name of the CMEK settings.
  var name: String = String()

  /// The resource name for the configured Cloud KMS key.
  ///
  /// KMS key name format:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
  ///
  ///
  ///
  /// To enable CMEK for the Log Router, set this field to a valid
  /// `kms_key_name` for which the associated service account has the required
  /// cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
  ///
  /// The Cloud KMS key used by the Log Router can be updated by changing the
  /// `kms_key_name` to a new valid key name or disabled by setting the key name
  /// to an empty string. Encryption operations that are in progress will be
  /// completed with the key that was in use when they started. Decryption
  /// operations will be completed using the key that was used at the time of
  /// encryption unless access to that key has been revoked.
  ///
  /// To disable CMEK for the Log Router, set this field to an empty string.
  ///
  /// See [Enabling CMEK for Log
  /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
  /// for more information.
  var kmsKeyName: String = String()

  /// Output only. The service account that will be used by the Log Router to access your
  /// Cloud KMS key.
  ///
  /// Before enabling CMEK for Log Router, you must first assign the
  /// cloudkms.cryptoKeyEncrypterDecrypter role to the service account that
  /// the Log Router will use to access your Cloud KMS key. Use
  /// [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings] to
  /// obtain the service account ID.
  ///
  /// See [Enabling CMEK for Log
  /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
  /// for more information.
  var serviceAccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to
/// [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
struct Google_Logging_V2_GetSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource for which to retrieve settings.
  ///
  ///     "projects/[PROJECT_ID]/settings"
  ///     "organizations/[ORGANIZATION_ID]/settings"
  ///     "billingAccounts/[BILLING_ACCOUNT_ID]/settings"
  ///     "folders/[FOLDER_ID]/settings"
  ///
  /// For example:
  ///
  ///   `"organizations/12345/settings"`
  ///
  /// Note: Settings for the Log Router can be get for Google Cloud projects,
  /// folders, organizations and billing accounts. Currently it can only be
  /// configured for organizations. Once configured for an organization, it
  /// applies to all projects and folders in the Google Cloud organization.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to
/// [UpdateSettings][google.logging.v2.ConfigServiceV2.UpdateSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
struct Google_Logging_V2_UpdateSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name for the settings to update.
  ///
  ///     "organizations/[ORGANIZATION_ID]/settings"
  ///
  /// For example:
  ///
  ///   `"organizations/12345/settings"`
  ///
  /// Note: Settings for the Log Router can currently only be configured for
  /// Google Cloud organizations. Once configured, it applies to all projects and
  /// folders in the Google Cloud organization.
  var name: String = String()

  /// Required. The settings to update.
  ///
  /// See [Enabling CMEK for Log
  /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
  /// for more information.
  var settings: Google_Logging_V2_Settings {
    get {return _settings ?? Google_Logging_V2_Settings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {self._settings = nil}

  /// Optional. Field mask identifying which fields from `settings` should
  /// be updated. A field will be overwritten if and only if it is in the update
  /// mask. Output only fields cannot be updated.
  ///
  /// See [FieldMask][google.protobuf.FieldMask] for more information.
  ///
  /// For example: `"updateMask=kmsKeyName"`
  var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _settings: Google_Logging_V2_Settings? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Describes the settings associated with a project, folder, organization,
/// billing account, or flexible resource.
struct Google_Logging_V2_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name of the settings.
  var name: String = String()

  /// Optional. The resource name for the configured Cloud KMS key.
  ///
  /// KMS key name format:
  ///
  ///     "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
  ///
  ///
  ///
  /// To enable CMEK for the Log Router, set this field to a valid
  /// `kms_key_name` for which the associated service account has the required
  /// `roles/cloudkms.cryptoKeyEncrypterDecrypter` role assigned for the key.
  ///
  /// The Cloud KMS key used by the Log Router can be updated by changing the
  /// `kms_key_name` to a new valid key name. Encryption operations that are in
  /// progress will be completed with the key that was in use when they started.
  /// Decryption operations will be completed using the key that was used at the
  /// time of encryption unless access to that key has been revoked.
  ///
  /// To disable CMEK for the Log Router, set this field to an empty string.
  ///
  /// See [Enabling CMEK for Log
  /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
  /// for more information.
  var kmsKeyName: String = String()

  /// Output only. The service account that will be used by the Log Router to access your
  /// Cloud KMS key.
  ///
  /// Before enabling CMEK for Log Router, you must first assign the role
  /// `roles/cloudkms.cryptoKeyEncrypterDecrypter` to the service account that
  /// the Log Router will use to access your Cloud KMS key. Use
  /// [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings] to
  /// obtain the service account ID.
  ///
  /// See [Enabling CMEK for Log
  /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
  /// for more information.
  var kmsServiceAccountID: String = String()

  /// Optional. The Cloud region that will be used for _Default and _Required log buckets
  /// for newly created projects and folders. For example `europe-west1`.
  /// This setting does not affect the location of custom log buckets.
  var storageLocation: String = String()

  /// Optional. If set to true, the _Default sink in newly created projects and folders
  /// will created in a disabled state. This can be used to automatically disable
  /// log ingestion if there is already an aggregated sink configured in the
  /// hierarchy. The _Default sink can be re-enabled manually if needed.
  var disableDefaultSink: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The parameters to CopyLogEntries.
struct Google_Logging_V2_CopyLogEntriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Log bucket from which to copy log entries.
  ///
  /// For example:
  ///
  ///   `"projects/my-project/locations/global/buckets/my-source-bucket"`
  var name: String = String()

  /// Optional. A filter specifying which log entries to copy. The filter must be no more
  /// than 20k characters. An empty filter matches all log entries.
  var filter: String = String()

  /// Required. Destination to which to copy log entries.
  var destination: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Metadata for CopyLogEntries long running operations.
struct Google_Logging_V2_CopyLogEntriesMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The create time of an operation.
  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  /// The end time of an operation.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  /// State of an operation.
  var state: Google_Logging_V2_OperationState = .unspecified

  /// Identifies whether the user has requested cancellation of the operation.
  var cancellationRequested: Bool = false

  /// CopyLogEntries RPC request.
  var request: Google_Logging_V2_CopyLogEntriesRequest {
    get {return _request ?? Google_Logging_V2_CopyLogEntriesRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// Estimated progress of the operation (0 - 100%).
  var progress: Int32 = 0

  /// The IAM identity of a service account that must be granted access to the
  /// destination.
  ///
  /// If the service account is not granted permission to the destination within
  /// an hour, the operation will be cancelled.
  ///
  /// For example: `"serviceAccount:foo@bar.com"`
  var writerIdentity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _request: Google_Logging_V2_CopyLogEntriesRequest? = nil
}

/// Response type for CopyLogEntries long running operations.
struct Google_Logging_V2_CopyLogEntriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of log entries copied.
  var logEntriesCopiedCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Logging_V2_LifecycleState: @unchecked Sendable {}
extension Google_Logging_V2_OperationState: @unchecked Sendable {}
extension Google_Logging_V2_LogBucket: @unchecked Sendable {}
extension Google_Logging_V2_LogView: @unchecked Sendable {}
extension Google_Logging_V2_LogSink: @unchecked Sendable {}
extension Google_Logging_V2_LogSink.OneOf_Options: @unchecked Sendable {}
extension Google_Logging_V2_LogSink.VersionFormat: @unchecked Sendable {}
extension Google_Logging_V2_BigQueryOptions: @unchecked Sendable {}
extension Google_Logging_V2_ListBucketsRequest: @unchecked Sendable {}
extension Google_Logging_V2_ListBucketsResponse: @unchecked Sendable {}
extension Google_Logging_V2_CreateBucketRequest: @unchecked Sendable {}
extension Google_Logging_V2_UpdateBucketRequest: @unchecked Sendable {}
extension Google_Logging_V2_GetBucketRequest: @unchecked Sendable {}
extension Google_Logging_V2_DeleteBucketRequest: @unchecked Sendable {}
extension Google_Logging_V2_UndeleteBucketRequest: @unchecked Sendable {}
extension Google_Logging_V2_ListViewsRequest: @unchecked Sendable {}
extension Google_Logging_V2_ListViewsResponse: @unchecked Sendable {}
extension Google_Logging_V2_CreateViewRequest: @unchecked Sendable {}
extension Google_Logging_V2_UpdateViewRequest: @unchecked Sendable {}
extension Google_Logging_V2_GetViewRequest: @unchecked Sendable {}
extension Google_Logging_V2_DeleteViewRequest: @unchecked Sendable {}
extension Google_Logging_V2_ListSinksRequest: @unchecked Sendable {}
extension Google_Logging_V2_ListSinksResponse: @unchecked Sendable {}
extension Google_Logging_V2_GetSinkRequest: @unchecked Sendable {}
extension Google_Logging_V2_CreateSinkRequest: @unchecked Sendable {}
extension Google_Logging_V2_UpdateSinkRequest: @unchecked Sendable {}
extension Google_Logging_V2_DeleteSinkRequest: @unchecked Sendable {}
extension Google_Logging_V2_LogExclusion: @unchecked Sendable {}
extension Google_Logging_V2_ListExclusionsRequest: @unchecked Sendable {}
extension Google_Logging_V2_ListExclusionsResponse: @unchecked Sendable {}
extension Google_Logging_V2_GetExclusionRequest: @unchecked Sendable {}
extension Google_Logging_V2_CreateExclusionRequest: @unchecked Sendable {}
extension Google_Logging_V2_UpdateExclusionRequest: @unchecked Sendable {}
extension Google_Logging_V2_DeleteExclusionRequest: @unchecked Sendable {}
extension Google_Logging_V2_GetCmekSettingsRequest: @unchecked Sendable {}
extension Google_Logging_V2_UpdateCmekSettingsRequest: @unchecked Sendable {}
extension Google_Logging_V2_CmekSettings: @unchecked Sendable {}
extension Google_Logging_V2_GetSettingsRequest: @unchecked Sendable {}
extension Google_Logging_V2_UpdateSettingsRequest: @unchecked Sendable {}
extension Google_Logging_V2_Settings: @unchecked Sendable {}
extension Google_Logging_V2_CopyLogEntriesRequest: @unchecked Sendable {}
extension Google_Logging_V2_CopyLogEntriesMetadata: @unchecked Sendable {}
extension Google_Logging_V2_CopyLogEntriesResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.logging.v2"

extension Google_Logging_V2_LifecycleState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIFECYCLE_STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "DELETE_REQUESTED"),
  ]
}

extension Google_Logging_V2_OperationState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_STATE_UNSPECIFIED"),
    1: .same(proto: "OPERATION_STATE_SCHEDULED"),
    2: .same(proto: "OPERATION_STATE_WAITING_FOR_PERMISSIONS"),
    3: .same(proto: "OPERATION_STATE_RUNNING"),
    4: .same(proto: "OPERATION_STATE_SUCCEEDED"),
    5: .same(proto: "OPERATION_STATE_FAILED"),
    6: .same(proto: "OPERATION_STATE_CANCELLED"),
  ]
}

extension Google_Logging_V2_LogBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogBucket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
    11: .standard(proto: "retention_days"),
    9: .same(proto: "locked"),
    12: .standard(proto: "lifecycle_state"),
    15: .standard(proto: "restricted_fields"),
    19: .standard(proto: "cmek_settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.locked) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.retentionDays) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.lifecycleState) }()
      case 15: try { try decoder.decodeRepeatedStringField(value: &self.restrictedFields) }()
      case 19: try { try decoder.decodeSingularMessageField(value: &self._cmekSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.locked != false {
      try visitor.visitSingularBoolField(value: self.locked, fieldNumber: 9)
    }
    if self.retentionDays != 0 {
      try visitor.visitSingularInt32Field(value: self.retentionDays, fieldNumber: 11)
    }
    if self.lifecycleState != .unspecified {
      try visitor.visitSingularEnumField(value: self.lifecycleState, fieldNumber: 12)
    }
    if !self.restrictedFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.restrictedFields, fieldNumber: 15)
    }
    try { if let v = self._cmekSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_LogBucket, rhs: Google_Logging_V2_LogBucket) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.retentionDays != rhs.retentionDays {return false}
    if lhs.locked != rhs.locked {return false}
    if lhs.lifecycleState != rhs.lifecycleState {return false}
    if lhs.restrictedFields != rhs.restrictedFields {return false}
    if lhs._cmekSettings != rhs._cmekSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_LogView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogView"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
    7: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_LogView, rhs: Google_Logging_V2_LogView) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_LogSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogSink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "destination"),
    5: .same(proto: "filter"),
    18: .same(proto: "description"),
    19: .same(proto: "disabled"),
    16: .same(proto: "exclusions"),
    6: .standard(proto: "output_version_format"),
    8: .standard(proto: "writer_identity"),
    9: .standard(proto: "include_children"),
    12: .standard(proto: "bigquery_options"),
    13: .standard(proto: "create_time"),
    14: .standard(proto: "update_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.outputVersionFormat) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.writerIdentity) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.includeChildren) }()
      case 12: try {
        var v: Google_Logging_V2_BigQueryOptions?
        var hadOneofValue = false
        if let current = self.options {
          hadOneofValue = true
          if case .bigqueryOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.options = .bigqueryOptions(v)
        }
      }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.exclusions) }()
      case 18: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 19: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    if self.outputVersionFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.outputVersionFormat, fieldNumber: 6)
    }
    if !self.writerIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.writerIdentity, fieldNumber: 8)
    }
    if self.includeChildren != false {
      try visitor.visitSingularBoolField(value: self.includeChildren, fieldNumber: 9)
    }
    try { if case .bigqueryOptions(let v)? = self.options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    if !self.exclusions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exclusions, fieldNumber: 16)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 18)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_LogSink, rhs: Google_Logging_V2_LogSink) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.exclusions != rhs.exclusions {return false}
    if lhs.outputVersionFormat != rhs.outputVersionFormat {return false}
    if lhs.writerIdentity != rhs.writerIdentity {return false}
    if lhs.includeChildren != rhs.includeChildren {return false}
    if lhs.options != rhs.options {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_LogSink.VersionFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION_FORMAT_UNSPECIFIED"),
    1: .same(proto: "V2"),
    2: .same(proto: "V1"),
  ]
}

extension Google_Logging_V2_BigQueryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BigQueryOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_partitioned_tables"),
    3: .standard(proto: "uses_timestamp_column_partitioning"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.usePartitionedTables) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.usesTimestampColumnPartitioning) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usePartitionedTables != false {
      try visitor.visitSingularBoolField(value: self.usePartitionedTables, fieldNumber: 1)
    }
    if self.usesTimestampColumnPartitioning != false {
      try visitor.visitSingularBoolField(value: self.usesTimestampColumnPartitioning, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_BigQueryOptions, rhs: Google_Logging_V2_BigQueryOptions) -> Bool {
    if lhs.usePartitionedTables != rhs.usePartitionedTables {return false}
    if lhs.usesTimestampColumnPartitioning != rhs.usesTimestampColumnPartitioning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListBucketsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListBucketsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListBucketsRequest, rhs: Google_Logging_V2_ListBucketsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListBucketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListBucketsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buckets"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buckets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListBucketsResponse, rhs: Google_Logging_V2_ListBucketsResponse) -> Bool {
    if lhs.buckets != rhs.buckets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CreateBucketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateBucketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "bucket_id"),
    3: .same(proto: "bucket"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bucketID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bucket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.bucketID.isEmpty {
      try visitor.visitSingularStringField(value: self.bucketID, fieldNumber: 2)
    }
    try { if let v = self._bucket {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CreateBucketRequest, rhs: Google_Logging_V2_CreateBucketRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.bucketID != rhs.bucketID {return false}
    if lhs._bucket != rhs._bucket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_UpdateBucketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateBucketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "bucket"),
    4: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bucket) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._bucket {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_UpdateBucketRequest, rhs: Google_Logging_V2_UpdateBucketRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._bucket != rhs._bucket {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_GetBucketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBucketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_GetBucketRequest, rhs: Google_Logging_V2_GetBucketRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_DeleteBucketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteBucketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_DeleteBucketRequest, rhs: Google_Logging_V2_DeleteBucketRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_UndeleteBucketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UndeleteBucketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_UndeleteBucketRequest, rhs: Google_Logging_V2_UndeleteBucketRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListViewsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListViewsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListViewsRequest, rhs: Google_Logging_V2_ListViewsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListViewsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListViewsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "views"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.views) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.views.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.views, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListViewsResponse, rhs: Google_Logging_V2_ListViewsResponse) -> Bool {
    if lhs.views != rhs.views {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CreateViewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateViewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "view_id"),
    3: .same(proto: "view"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._view) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 2)
    }
    try { if let v = self._view {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CreateViewRequest, rhs: Google_Logging_V2_CreateViewRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs._view != rhs._view {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_UpdateViewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateViewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "view"),
    4: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._view) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._view {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_UpdateViewRequest, rhs: Google_Logging_V2_UpdateViewRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._view != rhs._view {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_GetViewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetViewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_GetViewRequest, rhs: Google_Logging_V2_GetViewRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_DeleteViewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteViewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_DeleteViewRequest, rhs: Google_Logging_V2_DeleteViewRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListSinksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSinksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListSinksRequest, rhs: Google_Logging_V2_ListSinksRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListSinksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSinksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sinks"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sinks) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sinks, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListSinksResponse, rhs: Google_Logging_V2_ListSinksResponse) -> Bool {
    if lhs.sinks != rhs.sinks {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_GetSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSinkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sink_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sinkName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sinkName.isEmpty {
      try visitor.visitSingularStringField(value: self.sinkName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_GetSinkRequest, rhs: Google_Logging_V2_GetSinkRequest) -> Bool {
    if lhs.sinkName != rhs.sinkName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CreateSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSinkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "sink"),
    3: .standard(proto: "unique_writer_identity"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _sink: Google_Logging_V2_LogSink? = nil
    var _uniqueWriterIdentity: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _sink = source._sink
      _uniqueWriterIdentity = source._uniqueWriterIdentity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sink) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._uniqueWriterIdentity) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      try { if let v = _storage._sink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._uniqueWriterIdentity != false {
        try visitor.visitSingularBoolField(value: _storage._uniqueWriterIdentity, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CreateSinkRequest, rhs: Google_Logging_V2_CreateSinkRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._sink != rhs_storage._sink {return false}
        if _storage._uniqueWriterIdentity != rhs_storage._uniqueWriterIdentity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_UpdateSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSinkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sink_name"),
    2: .same(proto: "sink"),
    3: .standard(proto: "unique_writer_identity"),
    4: .standard(proto: "update_mask"),
  ]

  fileprivate class _StorageClass {
    var _sinkName: String = String()
    var _sink: Google_Logging_V2_LogSink? = nil
    var _uniqueWriterIdentity: Bool = false
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sinkName = source._sinkName
      _sink = source._sink
      _uniqueWriterIdentity = source._uniqueWriterIdentity
      _updateMask = source._updateMask
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sinkName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sink) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._uniqueWriterIdentity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sinkName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sinkName, fieldNumber: 1)
      }
      try { if let v = _storage._sink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._uniqueWriterIdentity != false {
        try visitor.visitSingularBoolField(value: _storage._uniqueWriterIdentity, fieldNumber: 3)
      }
      try { if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_UpdateSinkRequest, rhs: Google_Logging_V2_UpdateSinkRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sinkName != rhs_storage._sinkName {return false}
        if _storage._sink != rhs_storage._sink {return false}
        if _storage._uniqueWriterIdentity != rhs_storage._uniqueWriterIdentity {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_DeleteSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSinkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sink_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sinkName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sinkName.isEmpty {
      try visitor.visitSingularStringField(value: self.sinkName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_DeleteSinkRequest, rhs: Google_Logging_V2_DeleteSinkRequest) -> Bool {
    if lhs.sinkName != rhs.sinkName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_LogExclusion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogExclusion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "filter"),
    4: .same(proto: "disabled"),
    5: .standard(proto: "create_time"),
    6: .standard(proto: "update_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 3)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 4)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_LogExclusion, rhs: Google_Logging_V2_LogExclusion) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListExclusionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListExclusionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "page_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListExclusionsRequest, rhs: Google_Logging_V2_ListExclusionsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_ListExclusionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListExclusionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exclusions"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exclusions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exclusions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exclusions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_ListExclusionsResponse, rhs: Google_Logging_V2_ListExclusionsResponse) -> Bool {
    if lhs.exclusions != rhs.exclusions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_GetExclusionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetExclusionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_GetExclusionRequest, rhs: Google_Logging_V2_GetExclusionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CreateExclusionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateExclusionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "exclusion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exclusion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._exclusion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CreateExclusionRequest, rhs: Google_Logging_V2_CreateExclusionRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._exclusion != rhs._exclusion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_UpdateExclusionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateExclusionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "exclusion"),
    3: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exclusion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._exclusion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_UpdateExclusionRequest, rhs: Google_Logging_V2_UpdateExclusionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._exclusion != rhs._exclusion {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_DeleteExclusionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteExclusionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_DeleteExclusionRequest, rhs: Google_Logging_V2_DeleteExclusionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_GetCmekSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCmekSettingsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_GetCmekSettingsRequest, rhs: Google_Logging_V2_GetCmekSettingsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_UpdateCmekSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateCmekSettingsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "cmek_settings"),
    3: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cmekSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._cmekSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_UpdateCmekSettingsRequest, rhs: Google_Logging_V2_UpdateCmekSettingsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._cmekSettings != rhs._cmekSettings {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CmekSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CmekSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "kms_key_name"),
    3: .standard(proto: "service_account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kmsKeyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.kmsKeyName.isEmpty {
      try visitor.visitSingularStringField(value: self.kmsKeyName, fieldNumber: 2)
    }
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CmekSettings, rhs: Google_Logging_V2_CmekSettings) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.kmsKeyName != rhs.kmsKeyName {return false}
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_GetSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSettingsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_GetSettingsRequest, rhs: Google_Logging_V2_GetSettingsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_UpdateSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSettingsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "settings"),
    3: .standard(proto: "update_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_UpdateSettingsRequest, rhs: Google_Logging_V2_UpdateSettingsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Settings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "kms_key_name"),
    3: .standard(proto: "kms_service_account_id"),
    4: .standard(proto: "storage_location"),
    5: .standard(proto: "disable_default_sink"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kmsKeyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.kmsServiceAccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.storageLocation) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disableDefaultSink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.kmsKeyName.isEmpty {
      try visitor.visitSingularStringField(value: self.kmsKeyName, fieldNumber: 2)
    }
    if !self.kmsServiceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.kmsServiceAccountID, fieldNumber: 3)
    }
    if !self.storageLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.storageLocation, fieldNumber: 4)
    }
    if self.disableDefaultSink != false {
      try visitor.visitSingularBoolField(value: self.disableDefaultSink, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_Settings, rhs: Google_Logging_V2_Settings) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.kmsKeyName != rhs.kmsKeyName {return false}
    if lhs.kmsServiceAccountID != rhs.kmsServiceAccountID {return false}
    if lhs.storageLocation != rhs.storageLocation {return false}
    if lhs.disableDefaultSink != rhs.disableDefaultSink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CopyLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CopyLogEntriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "filter"),
    4: .same(proto: "destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 3)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CopyLogEntriesRequest, rhs: Google_Logging_V2_CopyLogEntriesRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CopyLogEntriesMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CopyLogEntriesMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "state"),
    4: .standard(proto: "cancellation_requested"),
    5: .same(proto: "request"),
    6: .same(proto: "progress"),
    7: .standard(proto: "writer_identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.cancellationRequested) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.progress) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.writerIdentity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if self.cancellationRequested != false {
      try visitor.visitSingularBoolField(value: self.cancellationRequested, fieldNumber: 4)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.progress != 0 {
      try visitor.visitSingularInt32Field(value: self.progress, fieldNumber: 6)
    }
    if !self.writerIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.writerIdentity, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CopyLogEntriesMetadata, rhs: Google_Logging_V2_CopyLogEntriesMetadata) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.cancellationRequested != rhs.cancellationRequested {return false}
    if lhs._request != rhs._request {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.writerIdentity != rhs.writerIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Logging_V2_CopyLogEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CopyLogEntriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_entries_copied_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.logEntriesCopiedCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logEntriesCopiedCount != 0 {
      try visitor.visitSingularInt64Field(value: self.logEntriesCopiedCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Logging_V2_CopyLogEntriesResponse, rhs: Google_Logging_V2_CopyLogEntriesResponse) -> Bool {
    if lhs.logEntriesCopiedCount != rhs.logEntriesCopiedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
