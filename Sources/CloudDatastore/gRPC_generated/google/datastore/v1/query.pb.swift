// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/datastore/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The result of fetching an entity from Datastore.
struct Google_Datastore_V1_EntityResult: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resulting entity.
  var entity: Google_Datastore_V1_Entity {
    get {return _entity ?? Google_Datastore_V1_Entity()}
    set {_entity = newValue}
  }
  /// Returns true if `entity` has been explicitly set.
  var hasEntity: Bool {return self._entity != nil}
  /// Clears the value of `entity`. Subsequent reads from it will return its default value.
  mutating func clearEntity() {self._entity = nil}

  /// The version of the entity, a strictly positive number that monotonically
  /// increases with changes to the entity.
  ///
  /// This field is set for
  /// [`FULL`][google.datastore.v1.EntityResult.ResultType.FULL] entity results.
  ///
  /// For [missing][google.datastore.v1.LookupResponse.missing] entities in
  /// `LookupResponse`, this is the version of the snapshot that was used to look
  /// up the entity, and it is always set except for eventually consistent reads.
  var version: Int64 = 0

  /// The time at which the entity was created.
  /// This field is set for
  /// [`FULL`][google.datastore.v1.EntityResult.ResultType.FULL] entity results.
  /// If this entity is missing, this field will not be set.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// The time at which the entity was last changed.
  /// This field is set for
  /// [`FULL`][google.datastore.v1.EntityResult.ResultType.FULL] entity results.
  /// If this entity is missing, this field will not be set.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  /// A cursor that points to the position after the result entity.
  /// Set only when the `EntityResult` is part of a `QueryResultBatch` message.
  var cursor: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies what data the 'entity' field contains.
  /// A `ResultType` is either implied (for example, in `LookupResponse.missing`
  /// from `datastore.proto`, it is always `KEY_ONLY`) or specified by context
  /// (for example, in message `QueryResultBatch`, field `entity_result_type`
  /// specifies a `ResultType` for all the values in field `entity_results`).
  enum ResultType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unspecified. This value is never used.
    case unspecified // = 0

    /// The key and properties.
    case full // = 1

    /// A projected subset of properties. The entity may have no key.
    case projection // = 2

    /// Only the key.
    case keyOnly // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .full
      case 2: self = .projection
      case 3: self = .keyOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .full: return 1
      case .projection: return 2
      case .keyOnly: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Datastore_V1_EntityResult.ResultType] = [
      .unspecified,
      .full,
      .projection,
      .keyOnly,
    ]

  }

  init() {}

  fileprivate var _entity: Google_Datastore_V1_Entity? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A query for entities.
struct Google_Datastore_V1_Query: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The projection to return. Defaults to returning all properties.
  var projection: [Google_Datastore_V1_Projection] {
    get {return _storage._projection}
    set {_uniqueStorage()._projection = newValue}
  }

  /// The kinds to query (if empty, returns entities of all kinds).
  /// Currently at most 1 kind may be specified.
  var kind: [Google_Datastore_V1_KindExpression] {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// The filter to apply.
  var filter: Google_Datastore_V1_Filter {
    get {return _storage._filter ?? Google_Datastore_V1_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return _storage._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// The order to apply to the query results (if empty, order is unspecified).
  var order: [Google_Datastore_V1_PropertyOrder] {
    get {return _storage._order}
    set {_uniqueStorage()._order = newValue}
  }

  /// The properties to make distinct. The query results will contain the first
  /// result for each distinct combination of values for the given properties
  /// (if empty, all results are returned).
  ///
  /// Requires:
  ///
  /// * If `order` is specified, the set of distinct on properties must appear
  /// before the non-distinct on properties in `order`.
  var distinctOn: [Google_Datastore_V1_PropertyReference] {
    get {return _storage._distinctOn}
    set {_uniqueStorage()._distinctOn = newValue}
  }

  /// A starting point for the query results. Query cursors are
  /// returned in query result batches and
  /// [can only be used to continue the same
  /// query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
  var startCursor: Data {
    get {return _storage._startCursor}
    set {_uniqueStorage()._startCursor = newValue}
  }

  /// An ending point for the query results. Query cursors are
  /// returned in query result batches and
  /// [can only be used to limit the same
  /// query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
  var endCursor: Data {
    get {return _storage._endCursor}
    set {_uniqueStorage()._endCursor = newValue}
  }

  /// The number of results to skip. Applies before limit, but after all other
  /// constraints. Optional. Must be >= 0 if specified.
  var offset: Int32 {
    get {return _storage._offset}
    set {_uniqueStorage()._offset = newValue}
  }

  /// The maximum number of results to return. Applies after all other
  /// constraints. Optional.
  /// Unspecified is interpreted as no limit.
  /// Must be >= 0 if specified.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Datastore query for running an aggregation over a
/// [Query][google.datastore.v1.Query].
struct Google_Datastore_V1_AggregationQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The base query to aggregate over.
  var queryType: Google_Datastore_V1_AggregationQuery.OneOf_QueryType? = nil

  /// Nested query for aggregation
  var nestedQuery: Google_Datastore_V1_Query {
    get {
      if case .nestedQuery(let v)? = queryType {return v}
      return Google_Datastore_V1_Query()
    }
    set {queryType = .nestedQuery(newValue)}
  }

  /// Optional. Series of aggregations to apply over the results of the
  /// `nested_query`.
  ///
  /// Requires:
  ///
  /// * A minimum of one and maximum of five aggregations per query.
  var aggregations: [Google_Datastore_V1_AggregationQuery.Aggregation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The base query to aggregate over.
  enum OneOf_QueryType: Equatable, Sendable {
    /// Nested query for aggregation
    case nestedQuery(Google_Datastore_V1_Query)

  }

  /// Defines an aggregation that produces a single result.
  struct Aggregation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of aggregation to perform, required.
    var `operator`: Google_Datastore_V1_AggregationQuery.Aggregation.OneOf_Operator? = nil

    /// Count aggregator.
    var count: Google_Datastore_V1_AggregationQuery.Aggregation.Count {
      get {
        if case .count(let v)? = `operator` {return v}
        return Google_Datastore_V1_AggregationQuery.Aggregation.Count()
      }
      set {`operator` = .count(newValue)}
    }

    /// Sum aggregator.
    var sum: Google_Datastore_V1_AggregationQuery.Aggregation.Sum {
      get {
        if case .sum(let v)? = `operator` {return v}
        return Google_Datastore_V1_AggregationQuery.Aggregation.Sum()
      }
      set {`operator` = .sum(newValue)}
    }

    /// Average aggregator.
    var avg: Google_Datastore_V1_AggregationQuery.Aggregation.Avg {
      get {
        if case .avg(let v)? = `operator` {return v}
        return Google_Datastore_V1_AggregationQuery.Aggregation.Avg()
      }
      set {`operator` = .avg(newValue)}
    }

    /// Optional. Optional name of the property to store the result of the
    /// aggregation.
    ///
    /// If not provided, Datastore will pick a default name following the format
    /// `property_<incremental_id++>`. For example:
    ///
    /// ```
    /// AGGREGATE
    ///   COUNT_UP_TO(1) AS count_up_to_1,
    ///   COUNT_UP_TO(2),
    ///   COUNT_UP_TO(3) AS count_up_to_3,
    ///   COUNT(*)
    /// OVER (
    ///   ...
    /// );
    /// ```
    ///
    /// becomes:
    ///
    /// ```
    /// AGGREGATE
    ///   COUNT_UP_TO(1) AS count_up_to_1,
    ///   COUNT_UP_TO(2) AS property_1,
    ///   COUNT_UP_TO(3) AS count_up_to_3,
    ///   COUNT(*) AS property_2
    /// OVER (
    ///   ...
    /// );
    /// ```
    ///
    /// Requires:
    ///
    /// * Must be unique across all aggregation aliases.
    /// * Conform to [entity property
    /// name][google.datastore.v1.Entity.properties] limitations.
    var alias: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of aggregation to perform, required.
    enum OneOf_Operator: Equatable, Sendable {
      /// Count aggregator.
      case count(Google_Datastore_V1_AggregationQuery.Aggregation.Count)
      /// Sum aggregator.
      case sum(Google_Datastore_V1_AggregationQuery.Aggregation.Sum)
      /// Average aggregator.
      case avg(Google_Datastore_V1_AggregationQuery.Aggregation.Avg)

    }

    /// Count of entities that match the query.
    ///
    /// The `COUNT(*)` aggregation function operates on the entire entity
    /// so it does not require a field reference.
    struct Count: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Optional. Optional constraint on the maximum number of entities to
      /// count.
      ///
      /// This provides a way to set an upper bound on the number of entities
      /// to scan, limiting latency, and cost.
      ///
      /// Unspecified is interpreted as no bound.
      ///
      /// If a zero value is provided, a count result of zero should always be
      /// expected.
      ///
      /// High-Level Example:
      ///
      /// ```
      /// AGGREGATE COUNT_UP_TO(1000) OVER ( SELECT * FROM k );
      /// ```
      ///
      /// Requires:
      ///
      /// * Must be non-negative when present.
      var upTo: SwiftProtobuf.Google_Protobuf_Int64Value {
        get {return _upTo ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
        set {_upTo = newValue}
      }
      /// Returns true if `upTo` has been explicitly set.
      var hasUpTo: Bool {return self._upTo != nil}
      /// Clears the value of `upTo`. Subsequent reads from it will return its default value.
      mutating func clearUpTo() {self._upTo = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _upTo: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    }

    /// Sum of the values of the requested property.
    ///
    /// * Only numeric values will be aggregated. All non-numeric values
    /// including `NULL` are skipped.
    ///
    /// * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
    /// follows IEEE-754 standards.
    ///
    /// * If the aggregated value set is empty, returns 0.
    ///
    /// * Returns a 64-bit integer if all aggregated numbers are integers and the
    /// sum result does not overflow. Otherwise, the result is returned as a
    /// double. Note that even if all the aggregated values are integers, the
    /// result is returned as a double if it cannot fit within a 64-bit signed
    /// integer. When this occurs, the returned value will lose precision.
    ///
    /// * When underflow occurs, floating-point aggregation is non-deterministic.
    /// This means that running the same query repeatedly without any changes to
    /// the underlying values could produce slightly different results each
    /// time. In those cases, values should be stored as integers over
    /// floating-point numbers.
    struct Sum: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The property to aggregate on.
      var property: Google_Datastore_V1_PropertyReference {
        get {return _property ?? Google_Datastore_V1_PropertyReference()}
        set {_property = newValue}
      }
      /// Returns true if `property` has been explicitly set.
      var hasProperty: Bool {return self._property != nil}
      /// Clears the value of `property`. Subsequent reads from it will return its default value.
      mutating func clearProperty() {self._property = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
    }

    /// Average of the values of the requested property.
    ///
    /// * Only numeric values will be aggregated. All non-numeric values
    /// including `NULL` are skipped.
    ///
    /// * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
    /// follows IEEE-754 standards.
    ///
    /// * If the aggregated value set is empty, returns `NULL`.
    ///
    /// * Always returns the result as a double.
    struct Avg: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The property to aggregate on.
      var property: Google_Datastore_V1_PropertyReference {
        get {return _property ?? Google_Datastore_V1_PropertyReference()}
        set {_property = newValue}
      }
      /// Returns true if `property` has been explicitly set.
      var hasProperty: Bool {return self._property != nil}
      /// Clears the value of `property`. Subsequent reads from it will return its default value.
      mutating func clearProperty() {self._property = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
    }

    init() {}
  }

  init() {}
}

/// A representation of a kind.
struct Google_Datastore_V1_KindExpression: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the kind.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A reference to a property relative to the kind expressions.
struct Google_Datastore_V1_PropertyReference: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A reference to a property.
  ///
  /// Requires:
  ///
  /// * MUST be a dot-delimited (`.`) string of segments, where each segment
  /// conforms to [entity property name][google.datastore.v1.Entity.properties]
  /// limitations.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A representation of a property in a projection.
struct Google_Datastore_V1_Projection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The property to project.
  var property: Google_Datastore_V1_PropertyReference {
    get {return _property ?? Google_Datastore_V1_PropertyReference()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
}

/// The desired order for a specific property.
struct Google_Datastore_V1_PropertyOrder: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The property to order by.
  var property: Google_Datastore_V1_PropertyReference {
    get {return _property ?? Google_Datastore_V1_PropertyReference()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  /// The direction to order by. Defaults to `ASCENDING`.
  var direction: Google_Datastore_V1_PropertyOrder.Direction = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The sort direction.
  enum Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// Ascending.
    case ascending // = 1

    /// Descending.
    case descending // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ascending
      case 2: self = .descending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ascending: return 1
      case .descending: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Datastore_V1_PropertyOrder.Direction] = [
      .unspecified,
      .ascending,
      .descending,
    ]

  }

  init() {}

  fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
}

/// A holder for any type of filter.
struct Google_Datastore_V1_Filter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of filter.
  var filterType: Google_Datastore_V1_Filter.OneOf_FilterType? = nil

  /// A composite filter.
  var compositeFilter: Google_Datastore_V1_CompositeFilter {
    get {
      if case .compositeFilter(let v)? = filterType {return v}
      return Google_Datastore_V1_CompositeFilter()
    }
    set {filterType = .compositeFilter(newValue)}
  }

  /// A filter on a property.
  var propertyFilter: Google_Datastore_V1_PropertyFilter {
    get {
      if case .propertyFilter(let v)? = filterType {return v}
      return Google_Datastore_V1_PropertyFilter()
    }
    set {filterType = .propertyFilter(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of filter.
  enum OneOf_FilterType: Equatable, Sendable {
    /// A composite filter.
    case compositeFilter(Google_Datastore_V1_CompositeFilter)
    /// A filter on a property.
    case propertyFilter(Google_Datastore_V1_PropertyFilter)

  }

  init() {}
}

/// A filter that merges multiple other filters using the given operator.
struct Google_Datastore_V1_CompositeFilter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operator for combining multiple filters.
  var op: Google_Datastore_V1_CompositeFilter.Operator = .unspecified

  /// The list of filters to combine.
  ///
  /// Requires:
  ///
  /// * At least one filter is present.
  var filters: [Google_Datastore_V1_Filter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A composite filter operator.
  enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// The results are required to satisfy each of the combined filters.
    case and // = 1

    /// Documents are required to satisfy at least one of the combined filters.
    case or // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .and
      case 2: self = .or
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .and: return 1
      case .or: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Datastore_V1_CompositeFilter.Operator] = [
      .unspecified,
      .and,
      .or,
    ]

  }

  init() {}
}

/// A filter on a specific property.
struct Google_Datastore_V1_PropertyFilter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The property to filter by.
  var property: Google_Datastore_V1_PropertyReference {
    get {return _property ?? Google_Datastore_V1_PropertyReference()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  /// The operator to filter by.
  var op: Google_Datastore_V1_PropertyFilter.Operator = .unspecified

  /// The value to compare the property to.
  var value: Google_Datastore_V1_Value {
    get {return _value ?? Google_Datastore_V1_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A property filter operator.
  enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// The given `property` is less than the given `value`.
    ///
    /// Requires:
    ///
    /// * That `property` comes first in `order_by`.
    case lessThan // = 1

    /// The given `property` is less than or equal to the given `value`.
    ///
    /// Requires:
    ///
    /// * That `property` comes first in `order_by`.
    case lessThanOrEqual // = 2

    /// The given `property` is greater than the given `value`.
    ///
    /// Requires:
    ///
    /// * That `property` comes first in `order_by`.
    case greaterThan // = 3

    /// The given `property` is greater than or equal to the given `value`.
    ///
    /// Requires:
    ///
    /// * That `property` comes first in `order_by`.
    case greaterThanOrEqual // = 4

    /// The given `property` is equal to the given `value`.
    case equal // = 5

    /// The given `property` is equal to at least one value in the given array.
    ///
    /// Requires:
    ///
    /// * That `value` is a non-empty `ArrayValue`, subject to disjunction
    ///   limits.
    /// * No `NOT_IN` is in the same query.
    case `in` // = 6

    /// The given `property` is not equal to the given `value`.
    ///
    /// Requires:
    ///
    /// * No other `NOT_EQUAL` or `NOT_IN` is in the same query.
    /// * That `property` comes first in the `order_by`.
    case notEqual // = 9

    /// Limit the result set to the given entity and its descendants.
    ///
    /// Requires:
    ///
    /// * That `value` is an entity key.
    /// * All evaluated disjunctions must have the same `HAS_ANCESTOR` filter.
    case hasAncestor // = 11

    /// The value of the `property` is not in the given array.
    ///
    /// Requires:
    ///
    /// * That `value` is a non-empty `ArrayValue` with at most 10 values.
    /// * No other `OR`, `IN`, `NOT_IN`, `NOT_EQUAL` is in the same query.
    /// * That `field` comes first in the `order_by`.
    case notIn // = 13
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .lessThan
      case 2: self = .lessThanOrEqual
      case 3: self = .greaterThan
      case 4: self = .greaterThanOrEqual
      case 5: self = .equal
      case 6: self = .in
      case 9: self = .notEqual
      case 11: self = .hasAncestor
      case 13: self = .notIn
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .lessThan: return 1
      case .lessThanOrEqual: return 2
      case .greaterThan: return 3
      case .greaterThanOrEqual: return 4
      case .equal: return 5
      case .in: return 6
      case .notEqual: return 9
      case .hasAncestor: return 11
      case .notIn: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Datastore_V1_PropertyFilter.Operator] = [
      .unspecified,
      .lessThan,
      .lessThanOrEqual,
      .greaterThan,
      .greaterThanOrEqual,
      .equal,
      .in,
      .notEqual,
      .hasAncestor,
      .notIn,
    ]

  }

  init() {}

  fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
  fileprivate var _value: Google_Datastore_V1_Value? = nil
}

/// A [GQL
/// query](https://cloud.google.com/datastore/docs/apis/gql/gql_reference).
struct Google_Datastore_V1_GqlQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string of the format described
  /// [here](https://cloud.google.com/datastore/docs/apis/gql/gql_reference).
  var queryString: String = String()

  /// When false, the query string must not contain any literals and instead must
  /// bind all values. For example,
  /// `SELECT * FROM Kind WHERE a = 'string literal'` is not allowed, while
  /// `SELECT * FROM Kind WHERE a = @value` is.
  var allowLiterals: Bool = false

  /// For each non-reserved named binding site in the query string, there must be
  /// a named parameter with that name, but not necessarily the inverse.
  ///
  /// Key must match regex `[A-Za-z_$][A-Za-z_$0-9]*`, must not match regex
  /// `__.*__`, and must not be `""`.
  var namedBindings: Dictionary<String,Google_Datastore_V1_GqlQueryParameter> = [:]

  /// Numbered binding site @1 references the first numbered parameter,
  /// effectively using 1-based indexing, rather than the usual 0.
  ///
  /// For each binding site numbered i in `query_string`, there must be an i-th
  /// numbered parameter. The inverse must also be true.
  var positionalBindings: [Google_Datastore_V1_GqlQueryParameter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A binding parameter for a GQL query.
struct Google_Datastore_V1_GqlQueryParameter: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of parameter.
  var parameterType: Google_Datastore_V1_GqlQueryParameter.OneOf_ParameterType? = nil

  /// A value parameter.
  var value: Google_Datastore_V1_Value {
    get {
      if case .value(let v)? = parameterType {return v}
      return Google_Datastore_V1_Value()
    }
    set {parameterType = .value(newValue)}
  }

  /// A query cursor. Query cursors are returned in query
  /// result batches.
  var cursor: Data {
    get {
      if case .cursor(let v)? = parameterType {return v}
      return Data()
    }
    set {parameterType = .cursor(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of parameter.
  enum OneOf_ParameterType: Equatable, @unchecked Sendable {
    /// A value parameter.
    case value(Google_Datastore_V1_Value)
    /// A query cursor. Query cursors are returned in query
    /// result batches.
    case cursor(Data)

  }

  init() {}
}

/// A batch of results produced by a query.
struct Google_Datastore_V1_QueryResultBatch: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of results skipped, typically because of an offset.
  var skippedResults: Int32 = 0

  /// A cursor that points to the position after the last skipped result.
  /// Will be set when `skipped_results` != 0.
  var skippedCursor: Data = Data()

  /// The result type for every entity in `entity_results`.
  var entityResultType: Google_Datastore_V1_EntityResult.ResultType = .unspecified

  /// The results for this batch.
  var entityResults: [Google_Datastore_V1_EntityResult] = []

  /// A cursor that points to the position after the last result in the batch.
  var endCursor: Data = Data()

  /// The state of the query after the current batch.
  var moreResults: Google_Datastore_V1_QueryResultBatch.MoreResultsType = .unspecified

  /// The version number of the snapshot this batch was returned from.
  /// This applies to the range of results from the query's `start_cursor` (or
  /// the beginning of the query if no cursor was given) to this batch's
  /// `end_cursor` (not the query's `end_cursor`).
  ///
  /// In a single transaction, subsequent query result batches for the same query
  /// can have a greater snapshot version number. Each batch's snapshot version
  /// is valid for all preceding batches.
  /// The value will be zero for eventually consistent queries.
  var snapshotVersion: Int64 = 0

  /// Read timestamp this batch was returned from.
  /// This applies to the range of results from the query's `start_cursor` (or
  /// the beginning of the query if no cursor was given) to this batch's
  /// `end_cursor` (not the query's `end_cursor`).
  ///
  /// In a single transaction, subsequent query result batches for the same query
  /// can have a greater timestamp. Each batch's read timestamp
  /// is valid for all preceding batches.
  /// This value will not be set for eventually consistent queries in Cloud
  /// Datastore.
  var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  mutating func clearReadTime() {self._readTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The possible values for the `more_results` field.
  enum MoreResultsType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unspecified. This value is never used.
    case unspecified // = 0

    /// There may be additional batches to fetch from this query.
    case notFinished // = 1

    /// The query is finished, but there may be more results after the limit.
    case moreResultsAfterLimit // = 2

    /// The query is finished, but there may be more results after the end
    /// cursor.
    case moreResultsAfterCursor // = 4

    /// The query is finished, and there are no more results.
    case noMoreResults // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .notFinished
      case 2: self = .moreResultsAfterLimit
      case 3: self = .noMoreResults
      case 4: self = .moreResultsAfterCursor
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .notFinished: return 1
      case .moreResultsAfterLimit: return 2
      case .noMoreResults: return 3
      case .moreResultsAfterCursor: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Datastore_V1_QueryResultBatch.MoreResultsType] = [
      .unspecified,
      .notFinished,
      .moreResultsAfterLimit,
      .moreResultsAfterCursor,
      .noMoreResults,
    ]

  }

  init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.datastore.v1"

extension Google_Datastore_V1_EntityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    4: .same(proto: "version"),
    6: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
    3: .same(proto: "cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entity) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.cursor) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.cursor, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 4)
    }
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_EntityResult, rhs: Google_Datastore_V1_EntityResult) -> Bool {
    if lhs._entity != rhs._entity {return false}
    if lhs.version != rhs.version {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_EntityResult.ResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_TYPE_UNSPECIFIED"),
    1: .same(proto: "FULL"),
    2: .same(proto: "PROJECTION"),
    3: .same(proto: "KEY_ONLY"),
  ]
}

extension Google_Datastore_V1_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Query"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "projection"),
    3: .same(proto: "kind"),
    4: .same(proto: "filter"),
    5: .same(proto: "order"),
    6: .standard(proto: "distinct_on"),
    7: .standard(proto: "start_cursor"),
    8: .standard(proto: "end_cursor"),
    10: .same(proto: "offset"),
    12: .same(proto: "limit"),
  ]

  fileprivate class _StorageClass {
    var _projection: [Google_Datastore_V1_Projection] = []
    var _kind: [Google_Datastore_V1_KindExpression] = []
    var _filter: Google_Datastore_V1_Filter? = nil
    var _order: [Google_Datastore_V1_PropertyOrder] = []
    var _distinctOn: [Google_Datastore_V1_PropertyReference] = []
    var _startCursor: Data = Data()
    var _endCursor: Data = Data()
    var _offset: Int32 = 0
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _projection = source._projection
      _kind = source._kind
      _filter = source._filter
      _order = source._order
      _distinctOn = source._distinctOn
      _startCursor = source._startCursor
      _endCursor = source._endCursor
      _offset = source._offset
      _limit = source._limit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._projection) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._kind) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._order) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._distinctOn) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._startCursor) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._endCursor) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._offset) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._limit) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._projection.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._projection, fieldNumber: 2)
      }
      if !_storage._kind.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._kind, fieldNumber: 3)
      }
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._order.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._order, fieldNumber: 5)
      }
      if !_storage._distinctOn.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._distinctOn, fieldNumber: 6)
      }
      if !_storage._startCursor.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._startCursor, fieldNumber: 7)
      }
      if !_storage._endCursor.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._endCursor, fieldNumber: 8)
      }
      if _storage._offset != 0 {
        try visitor.visitSingularInt32Field(value: _storage._offset, fieldNumber: 10)
      }
      try { if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_Query, rhs: Google_Datastore_V1_Query) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._projection != rhs_storage._projection {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._order != rhs_storage._order {return false}
        if _storage._distinctOn != rhs_storage._distinctOn {return false}
        if _storage._startCursor != rhs_storage._startCursor {return false}
        if _storage._endCursor != rhs_storage._endCursor {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._limit != rhs_storage._limit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AggregationQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AggregationQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nested_query"),
    3: .same(proto: "aggregations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Datastore_V1_Query?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .nestedQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .nestedQuery(v)
        }
      }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.aggregations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .nestedQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.aggregations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_AggregationQuery, rhs: Google_Datastore_V1_AggregationQuery) -> Bool {
    if lhs.queryType != rhs.queryType {return false}
    if lhs.aggregations != rhs.aggregations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AggregationQuery.Aggregation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Datastore_V1_AggregationQuery.protoMessageName + ".Aggregation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "sum"),
    3: .same(proto: "avg"),
    7: .same(proto: "alias"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Datastore_V1_AggregationQuery.Aggregation.Count?
        var hadOneofValue = false
        if let current = self.`operator` {
          hadOneofValue = true
          if case .count(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`operator` = .count(v)
        }
      }()
      case 2: try {
        var v: Google_Datastore_V1_AggregationQuery.Aggregation.Sum?
        var hadOneofValue = false
        if let current = self.`operator` {
          hadOneofValue = true
          if case .sum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`operator` = .sum(v)
        }
      }()
      case 3: try {
        var v: Google_Datastore_V1_AggregationQuery.Aggregation.Avg?
        var hadOneofValue = false
        if let current = self.`operator` {
          hadOneofValue = true
          if case .avg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`operator` = .avg(v)
        }
      }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.`operator` {
    case .count?: try {
      guard case .count(let v)? = self.`operator` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sum?: try {
      guard case .sum(let v)? = self.`operator` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .avg?: try {
      guard case .avg(let v)? = self.`operator` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_AggregationQuery.Aggregation, rhs: Google_Datastore_V1_AggregationQuery.Aggregation) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AggregationQuery.Aggregation.Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Datastore_V1_AggregationQuery.Aggregation.protoMessageName + ".Count"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "up_to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upTo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_AggregationQuery.Aggregation.Count, rhs: Google_Datastore_V1_AggregationQuery.Aggregation.Count) -> Bool {
    if lhs._upTo != rhs._upTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AggregationQuery.Aggregation.Sum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Datastore_V1_AggregationQuery.Aggregation.protoMessageName + ".Sum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_AggregationQuery.Aggregation.Sum, rhs: Google_Datastore_V1_AggregationQuery.Aggregation.Sum) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AggregationQuery.Aggregation.Avg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Datastore_V1_AggregationQuery.Aggregation.protoMessageName + ".Avg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_AggregationQuery.Aggregation.Avg, rhs: Google_Datastore_V1_AggregationQuery.Aggregation.Avg) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_KindExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KindExpression"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_KindExpression, rhs: Google_Datastore_V1_KindExpression) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_PropertyReference, rhs: Google_Datastore_V1_PropertyReference) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Projection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Projection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_Projection, rhs: Google_Datastore_V1_Projection) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_PropertyOrder, rhs: Google_Datastore_V1_PropertyOrder) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyOrder.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ASCENDING"),
    2: .same(proto: "DESCENDING"),
  ]
}

extension Google_Datastore_V1_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Filter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "composite_filter"),
    2: .standard(proto: "property_filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Datastore_V1_CompositeFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .compositeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .compositeFilter(v)
        }
      }()
      case 2: try {
        var v: Google_Datastore_V1_PropertyFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .propertyFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .propertyFilter(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.filterType {
    case .compositeFilter?: try {
      guard case .compositeFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .propertyFilter?: try {
      guard case .propertyFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_Filter, rhs: Google_Datastore_V1_Filter) -> Bool {
    if lhs.filterType != rhs.filterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CompositeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompositeFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "filters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_CompositeFilter, rhs: Google_Datastore_V1_CompositeFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CompositeFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "AND"),
    2: .same(proto: "OR"),
  ]
}

extension Google_Datastore_V1_PropertyFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "op"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 2)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_PropertyFilter, rhs: Google_Datastore_V1_PropertyFilter) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.op != rhs.op {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "LESS_THAN"),
    2: .same(proto: "LESS_THAN_OR_EQUAL"),
    3: .same(proto: "GREATER_THAN"),
    4: .same(proto: "GREATER_THAN_OR_EQUAL"),
    5: .same(proto: "EQUAL"),
    6: .same(proto: "IN"),
    9: .same(proto: "NOT_EQUAL"),
    11: .same(proto: "HAS_ANCESTOR"),
    13: .same(proto: "NOT_IN"),
  ]
}

extension Google_Datastore_V1_GqlQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GqlQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_string"),
    2: .standard(proto: "allow_literals"),
    5: .standard(proto: "named_bindings"),
    4: .standard(proto: "positional_bindings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.queryString) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowLiterals) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.positionalBindings) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Datastore_V1_GqlQueryParameter>.self, value: &self.namedBindings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queryString.isEmpty {
      try visitor.visitSingularStringField(value: self.queryString, fieldNumber: 1)
    }
    if self.allowLiterals != false {
      try visitor.visitSingularBoolField(value: self.allowLiterals, fieldNumber: 2)
    }
    if !self.positionalBindings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positionalBindings, fieldNumber: 4)
    }
    if !self.namedBindings.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Datastore_V1_GqlQueryParameter>.self, value: self.namedBindings, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_GqlQuery, rhs: Google_Datastore_V1_GqlQuery) -> Bool {
    if lhs.queryString != rhs.queryString {return false}
    if lhs.allowLiterals != rhs.allowLiterals {return false}
    if lhs.namedBindings != rhs.namedBindings {return false}
    if lhs.positionalBindings != rhs.positionalBindings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_GqlQueryParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GqlQueryParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "value"),
    3: .same(proto: "cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Datastore_V1_Value?
        var hadOneofValue = false
        if let current = self.parameterType {
          hadOneofValue = true
          if case .value(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameterType = .value(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.parameterType != nil {try decoder.handleConflictingOneOf()}
          self.parameterType = .cursor(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.parameterType {
    case .value?: try {
      guard case .value(let v)? = self.parameterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cursor?: try {
      guard case .cursor(let v)? = self.parameterType else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_GqlQueryParameter, rhs: Google_Datastore_V1_GqlQueryParameter) -> Bool {
    if lhs.parameterType != rhs.parameterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_QueryResultBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResultBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "skipped_results"),
    3: .standard(proto: "skipped_cursor"),
    1: .standard(proto: "entity_result_type"),
    2: .standard(proto: "entity_results"),
    4: .standard(proto: "end_cursor"),
    5: .standard(proto: "more_results"),
    7: .standard(proto: "snapshot_version"),
    8: .standard(proto: "read_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.entityResultType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entityResults) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.skippedCursor) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.endCursor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.moreResults) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.skippedResults) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.snapshotVersion) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.entityResultType != .unspecified {
      try visitor.visitSingularEnumField(value: self.entityResultType, fieldNumber: 1)
    }
    if !self.entityResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entityResults, fieldNumber: 2)
    }
    if !self.skippedCursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.skippedCursor, fieldNumber: 3)
    }
    if !self.endCursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.endCursor, fieldNumber: 4)
    }
    if self.moreResults != .unspecified {
      try visitor.visitSingularEnumField(value: self.moreResults, fieldNumber: 5)
    }
    if self.skippedResults != 0 {
      try visitor.visitSingularInt32Field(value: self.skippedResults, fieldNumber: 6)
    }
    if self.snapshotVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.snapshotVersion, fieldNumber: 7)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_QueryResultBatch, rhs: Google_Datastore_V1_QueryResultBatch) -> Bool {
    if lhs.skippedResults != rhs.skippedResults {return false}
    if lhs.skippedCursor != rhs.skippedCursor {return false}
    if lhs.entityResultType != rhs.entityResultType {return false}
    if lhs.entityResults != rhs.entityResults {return false}
    if lhs.endCursor != rhs.endCursor {return false}
    if lhs.moreResults != rhs.moreResults {return false}
    if lhs.snapshotVersion != rhs.snapshotVersion {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_QueryResultBatch.MoreResultsType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MORE_RESULTS_TYPE_UNSPECIFIED"),
    1: .same(proto: "NOT_FINISHED"),
    2: .same(proto: "MORE_RESULTS_AFTER_LIMIT"),
    3: .same(proto: "NO_MORE_RESULTS"),
    4: .same(proto: "MORE_RESULTS_AFTER_CURSOR"),
  ]
}
