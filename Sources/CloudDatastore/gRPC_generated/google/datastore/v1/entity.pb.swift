// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/datastore/v1/entity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A partition ID identifies a grouping of entities. The grouping is always
/// by project and namespace, however the namespace ID may be empty.
///
/// A partition ID contains several dimensions:
/// project ID and namespace ID.
///
/// Partition dimensions:
///
/// - May be `""`.
/// - Must be valid UTF-8 bytes.
/// - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
/// If the value of any dimension matches regex `__.*__`, the partition is
/// reserved/read-only.
/// A reserved/read-only partition ID is forbidden in certain documented
/// contexts.
///
/// Foreign partition IDs (in which the project ID does
/// not match the context project ID ) are discouraged.
/// Reads and writes of foreign partition IDs may fail if the project is not in
/// an active state.
package struct Google_Datastore_V1_PartitionId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the project to which the entities belong.
  package var projectID: String = String()

  /// If not empty, the ID of the database to which the entities
  /// belong.
  package var databaseID: String = String()

  /// If not empty, the ID of the namespace to which the entities belong.
  package var namespaceID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// A unique identifier for an entity.
/// If a key's partition ID or any of its path kinds or names are
/// reserved/read-only, the key is reserved/read-only.
/// A reserved/read-only key is forbidden in certain documented contexts.
package struct Google_Datastore_V1_Key: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entities are partitioned into subsets, currently identified by a project
  /// ID and namespace ID.
  /// Queries are scoped to a single partition.
  package var partitionID: Google_Datastore_V1_PartitionId {
    get {return _partitionID ?? Google_Datastore_V1_PartitionId()}
    set {_partitionID = newValue}
  }
  /// Returns true if `partitionID` has been explicitly set.
  package var hasPartitionID: Bool {return self._partitionID != nil}
  /// Clears the value of `partitionID`. Subsequent reads from it will return its default value.
  package mutating func clearPartitionID() {self._partitionID = nil}

  /// The entity path.
  /// An entity path consists of one or more elements composed of a kind and a
  /// string or numerical identifier, which identify entities. The first
  /// element identifies a _root entity_, the second element identifies
  /// a _child_ of the root entity, the third element identifies a child of the
  /// second entity, and so forth. The entities identified by all prefixes of
  /// the path are called the element's _ancestors_.
  ///
  /// An entity path is always fully complete: *all* of the entity's ancestors
  /// are required to be in the path along with the entity identifier itself.
  /// The only exception is that in some documented cases, the identifier in the
  /// last path element (for the entity) itself may be omitted. For example,
  /// the last path element of the key of `Mutation.insert` may have no
  /// identifier.
  ///
  /// A path can never be empty, and a path can have at most 100 elements.
  package var path: [Google_Datastore_V1_Key.PathElement] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A (kind, ID/name) pair used to construct a key path.
  ///
  /// If either name or ID is set, the element is complete.
  /// If neither is set, the element is incomplete.
  package struct PathElement: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The kind of the entity.
    ///
    /// A kind matching regex `__.*__` is reserved/read-only.
    /// A kind must not contain more than 1500 bytes when UTF-8 encoded.
    /// Cannot be `""`.
    ///
    /// Must be valid UTF-8 bytes. Legacy values that are not valid UTF-8 are
    /// encoded as `__bytes<X>__` where `<X>` is the base-64 encoding of the
    /// bytes.
    package var kind: String = String()

    /// The type of ID.
    package var idType: Google_Datastore_V1_Key.PathElement.OneOf_IDType? = nil

    /// The auto-allocated ID of the entity.
    ///
    /// Never equal to zero. Values less than zero are discouraged and may not
    /// be supported in the future.
    package var id: Int64 {
      get {
        if case .id(let v)? = idType {return v}
        return 0
      }
      set {idType = .id(newValue)}
    }

    /// The name of the entity.
    ///
    /// A name matching regex `__.*__` is reserved/read-only.
    /// A name must not be more than 1500 bytes when UTF-8 encoded.
    /// Cannot be `""`.
    ///
    /// Must be valid UTF-8 bytes. Legacy values that are not valid UTF-8 are
    /// encoded as `__bytes<X>__` where `<X>` is the base-64 encoding of the
    /// bytes.
    package var name: String {
      get {
        if case .name(let v)? = idType {return v}
        return String()
      }
      set {idType = .name(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of ID.
    package enum OneOf_IDType: Equatable, Sendable {
      /// The auto-allocated ID of the entity.
      ///
      /// Never equal to zero. Values less than zero are discouraged and may not
      /// be supported in the future.
      case id(Int64)
      /// The name of the entity.
      ///
      /// A name matching regex `__.*__` is reserved/read-only.
      /// A name must not be more than 1500 bytes when UTF-8 encoded.
      /// Cannot be `""`.
      ///
      /// Must be valid UTF-8 bytes. Legacy values that are not valid UTF-8 are
      /// encoded as `__bytes<X>__` where `<X>` is the base-64 encoding of the
      /// bytes.
      case name(String)

    }

    package init() {}
  }

  package init() {}

  fileprivate var _partitionID: Google_Datastore_V1_PartitionId? = nil
}

/// An array value.
package struct Google_Datastore_V1_ArrayValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Values in the array.
  /// The order of values in an array is preserved as long as all values have
  /// identical settings for 'exclude_from_indexes'.
  package var values: [Google_Datastore_V1_Value] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// A message that can hold any of the supported value types and associated
/// metadata.
package struct Google_Datastore_V1_Value: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must have a value set.
  package var valueType: Google_Datastore_V1_Value.OneOf_ValueType? = nil

  /// A null value.
  package var nullValue: SwiftProtobuf.Google_Protobuf_NullValue {
    get {
      if case .nullValue(let v)? = valueType {return v}
      return .nullValue
    }
    set {valueType = .nullValue(newValue)}
  }

  /// A boolean value.
  package var booleanValue: Bool {
    get {
      if case .booleanValue(let v)? = valueType {return v}
      return false
    }
    set {valueType = .booleanValue(newValue)}
  }

  /// An integer value.
  package var integerValue: Int64 {
    get {
      if case .integerValue(let v)? = valueType {return v}
      return 0
    }
    set {valueType = .integerValue(newValue)}
  }

  /// A double value.
  package var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = valueType {return v}
      return 0
    }
    set {valueType = .doubleValue(newValue)}
  }

  /// A timestamp value.
  /// When stored in the Datastore, precise only to microseconds;
  /// any additional precision is rounded down.
  package var timestampValue: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .timestampValue(let v)? = valueType {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {valueType = .timestampValue(newValue)}
  }

  /// A key value.
  package var keyValue: Google_Datastore_V1_Key {
    get {
      if case .keyValue(let v)? = valueType {return v}
      return Google_Datastore_V1_Key()
    }
    set {valueType = .keyValue(newValue)}
  }

  /// A UTF-8 encoded string value.
  /// When `exclude_from_indexes` is false (it is indexed) , may have at most
  /// 1500 bytes. Otherwise, may be set to at most 1,000,000 bytes.
  package var stringValue: String {
    get {
      if case .stringValue(let v)? = valueType {return v}
      return String()
    }
    set {valueType = .stringValue(newValue)}
  }

  /// A blob value.
  /// May have at most 1,000,000 bytes.
  /// When `exclude_from_indexes` is false, may have at most 1500 bytes.
  /// In JSON requests, must be base64-encoded.
  package var blobValue: Data {
    get {
      if case .blobValue(let v)? = valueType {return v}
      return Data()
    }
    set {valueType = .blobValue(newValue)}
  }

  /// A geo point value representing a point on the surface of Earth.
  package var geoPointValue: Google_Type_LatLng {
    get {
      if case .geoPointValue(let v)? = valueType {return v}
      return Google_Type_LatLng()
    }
    set {valueType = .geoPointValue(newValue)}
  }

  /// An entity value.
  ///
  /// - May have no key.
  /// - May have a key with an incomplete key path.
  /// - May have a reserved/read-only key.
  package var entityValue: Google_Datastore_V1_Entity {
    get {
      if case .entityValue(let v)? = valueType {return v}
      return Google_Datastore_V1_Entity()
    }
    set {valueType = .entityValue(newValue)}
  }

  /// An array value.
  /// Cannot contain another array value.
  /// A `Value` instance that sets field `array_value` must not set fields
  /// `meaning` or `exclude_from_indexes`.
  package var arrayValue: Google_Datastore_V1_ArrayValue {
    get {
      if case .arrayValue(let v)? = valueType {return v}
      return Google_Datastore_V1_ArrayValue()
    }
    set {valueType = .arrayValue(newValue)}
  }

  /// The `meaning` field should only be populated for backwards compatibility.
  package var meaning: Int32 = 0

  /// If the value should be excluded from all indexes including those defined
  /// explicitly.
  package var excludeFromIndexes: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Must have a value set.
  package enum OneOf_ValueType: Equatable, @unchecked Sendable {
    /// A null value.
    case nullValue(SwiftProtobuf.Google_Protobuf_NullValue)
    /// A boolean value.
    case booleanValue(Bool)
    /// An integer value.
    case integerValue(Int64)
    /// A double value.
    case doubleValue(Double)
    /// A timestamp value.
    /// When stored in the Datastore, precise only to microseconds;
    /// any additional precision is rounded down.
    case timestampValue(SwiftProtobuf.Google_Protobuf_Timestamp)
    /// A key value.
    case keyValue(Google_Datastore_V1_Key)
    /// A UTF-8 encoded string value.
    /// When `exclude_from_indexes` is false (it is indexed) , may have at most
    /// 1500 bytes. Otherwise, may be set to at most 1,000,000 bytes.
    case stringValue(String)
    /// A blob value.
    /// May have at most 1,000,000 bytes.
    /// When `exclude_from_indexes` is false, may have at most 1500 bytes.
    /// In JSON requests, must be base64-encoded.
    case blobValue(Data)
    /// A geo point value representing a point on the surface of Earth.
    case geoPointValue(Google_Type_LatLng)
    /// An entity value.
    ///
    /// - May have no key.
    /// - May have a key with an incomplete key path.
    /// - May have a reserved/read-only key.
    case entityValue(Google_Datastore_V1_Entity)
    /// An array value.
    /// Cannot contain another array value.
    /// A `Value` instance that sets field `array_value` must not set fields
    /// `meaning` or `exclude_from_indexes`.
    case arrayValue(Google_Datastore_V1_ArrayValue)

  }

  package init() {}
}

/// A Datastore data object.
///
/// Must not exceed 1 MiB - 4 bytes.
package struct Google_Datastore_V1_Entity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The entity's key.
  ///
  /// An entity must have a key, unless otherwise documented (for example,
  /// an entity in `Value.entity_value` may have no key).
  /// An entity's kind is its key path's last element's kind,
  /// or null if it has no key.
  package var key: Google_Datastore_V1_Key {
    get {return _key ?? Google_Datastore_V1_Key()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  package var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  package mutating func clearKey() {self._key = nil}

  /// The entity's properties.
  /// The map's keys are property names.
  /// A property name matching regex `__.*__` is reserved.
  /// A reserved property name is forbidden in certain documented contexts.
  /// The map keys, represented as UTF-8, must not exceed 1,500 bytes and cannot
  /// be empty.
  package var properties: Dictionary<String,Google_Datastore_V1_Value> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _key: Google_Datastore_V1_Key? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.datastore.v1"

extension Google_Datastore_V1_PartitionId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PartitionId"
  package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "project_id"),
    3: .standard(proto: "database_id"),
    4: .standard(proto: "namespace_id"),
  ]

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 3)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Google_Datastore_V1_PartitionId, rhs: Google_Datastore_V1_PartitionId) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Key"
  package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "partition_id"),
    2: .same(proto: "path"),
  ]

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._partitionID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._partitionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Google_Datastore_V1_Key, rhs: Google_Datastore_V1_Key) -> Bool {
    if lhs._partitionID != rhs._partitionID {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Key.PathElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Google_Datastore_V1_Key.protoMessageName + ".PathElement"
  package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
  ]

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.idType != nil {try decoder.handleConflictingOneOf()}
          self.idType = .id(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.idType != nil {try decoder.handleConflictingOneOf()}
          self.idType = .name(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    switch self.idType {
    case .id?: try {
      guard case .id(let v)? = self.idType else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .name?: try {
      guard case .name(let v)? = self.idType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Google_Datastore_V1_Key.PathElement, rhs: Google_Datastore_V1_Key.PathElement) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.idType != rhs.idType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ArrayValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ArrayValue"
  package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Google_Datastore_V1_ArrayValue, rhs: Google_Datastore_V1_ArrayValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Value"
  package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "null_value"),
    1: .standard(proto: "boolean_value"),
    2: .standard(proto: "integer_value"),
    3: .standard(proto: "double_value"),
    10: .standard(proto: "timestamp_value"),
    5: .standard(proto: "key_value"),
    17: .standard(proto: "string_value"),
    18: .standard(proto: "blob_value"),
    8: .standard(proto: "geo_point_value"),
    6: .standard(proto: "entity_value"),
    9: .standard(proto: "array_value"),
    14: .same(proto: "meaning"),
    19: .standard(proto: "exclude_from_indexes"),
  ]

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .booleanValue(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .integerValue(v)
        }
      }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .doubleValue(v)
        }
      }()
      case 5: try {
        var v: Google_Datastore_V1_Key?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .keyValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .keyValue(v)
        }
      }()
      case 6: try {
        var v: Google_Datastore_V1_Entity?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .entityValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .entityValue(v)
        }
      }()
      case 8: try {
        var v: Google_Type_LatLng?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .geoPointValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .geoPointValue(v)
        }
      }()
      case 9: try {
        var v: Google_Datastore_V1_ArrayValue?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .arrayValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .arrayValue(v)
        }
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .timestampValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .timestampValue(v)
        }
      }()
      case 11: try {
        var v: SwiftProtobuf.Google_Protobuf_NullValue?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .nullValue(v)
        }
      }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.meaning) }()
      case 17: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .stringValue(v)
        }
      }()
      case 18: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .blobValue(v)
        }
      }()
      case 19: try { try decoder.decodeSingularBoolField(value: &self.excludeFromIndexes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.valueType {
    case .booleanValue?: try {
      guard case .booleanValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .keyValue?: try {
      guard case .keyValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .entityValue?: try {
      guard case .entityValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .geoPointValue?: try {
      guard case .geoPointValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .arrayValue?: try {
      guard case .arrayValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .timestampValue?: try {
      guard case .timestampValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .nullValue?: try {
      guard case .nullValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    }()
    default: break
    }
    if self.meaning != 0 {
      try visitor.visitSingularInt32Field(value: self.meaning, fieldNumber: 14)
    }
    switch self.valueType {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 17)
    }()
    case .blobValue?: try {
      guard case .blobValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 18)
    }()
    default: break
    }
    if self.excludeFromIndexes != false {
      try visitor.visitSingularBoolField(value: self.excludeFromIndexes, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Google_Datastore_V1_Value, rhs: Google_Datastore_V1_Value) -> Bool {
    if lhs.valueType != rhs.valueType {return false}
    if lhs.meaning != rhs.meaning {return false}
    if lhs.excludeFromIndexes != rhs.excludeFromIndexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Entity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Entity"
  package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    3: .same(proto: "properties"),
  ]

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Datastore_V1_Value>.self, value: &self.properties) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Datastore_V1_Value>.self, value: self.properties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Google_Datastore_V1_Entity, rhs: Google_Datastore_V1_Entity) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
