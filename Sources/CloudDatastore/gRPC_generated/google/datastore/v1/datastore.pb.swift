// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/datastore/v1/datastore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
struct Google_Datastore_V1_LookupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// The options for this lookup request.
  var readOptions: Google_Datastore_V1_ReadOptions {
    get {return _readOptions ?? Google_Datastore_V1_ReadOptions()}
    set {_readOptions = newValue}
  }
  /// Returns true if `readOptions` has been explicitly set.
  var hasReadOptions: Bool {return self._readOptions != nil}
  /// Clears the value of `readOptions`. Subsequent reads from it will return its default value.
  mutating func clearReadOptions() {self._readOptions = nil}

  /// Required. Keys of entities to look up.
  var keys: [Google_Datastore_V1_Key] = []

  /// The properties to return. Defaults to returning all properties.
  ///
  /// If this field is set and an entity has a property not referenced in the
  /// mask, it will be absent from [LookupResponse.found.entity.properties][].
  ///
  /// The entity's key is always returned.
  var propertyMask: Google_Datastore_V1_PropertyMask {
    get {return _propertyMask ?? Google_Datastore_V1_PropertyMask()}
    set {_propertyMask = newValue}
  }
  /// Returns true if `propertyMask` has been explicitly set.
  var hasPropertyMask: Bool {return self._propertyMask != nil}
  /// Clears the value of `propertyMask`. Subsequent reads from it will return its default value.
  mutating func clearPropertyMask() {self._propertyMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _readOptions: Google_Datastore_V1_ReadOptions? = nil
  fileprivate var _propertyMask: Google_Datastore_V1_PropertyMask? = nil
}

/// The response for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
struct Google_Datastore_V1_LookupResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entities found as `ResultType.FULL` entities. The order of results in this
  /// field is undefined and has no relation to the order of the keys in the
  /// input.
  var found: [Google_Datastore_V1_EntityResult] = []

  /// Entities not found as `ResultType.KEY_ONLY` entities. The order of results
  /// in this field is undefined and has no relation to the order of the keys
  /// in the input.
  var missing: [Google_Datastore_V1_EntityResult] = []

  /// A list of keys that were not looked up due to resource constraints. The
  /// order of results in this field is undefined and has no relation to the
  /// order of the keys in the input.
  var deferred: [Google_Datastore_V1_Key] = []

  /// The identifier of the transaction that was started as part of this Lookup
  /// request.
  ///
  /// Set only when
  /// [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
  /// was set in
  /// [LookupRequest.read_options][google.datastore.v1.LookupRequest.read_options].
  var transaction: Data = Data()

  /// The time at which these entities were read or found missing.
  var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  mutating func clearReadTime() {self._readTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
struct Google_Datastore_V1_RunQueryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// Entities are partitioned into subsets, identified by a partition ID.
  /// Queries are scoped to a single partition.
  /// This partition ID is normalized with the standard default context
  /// partition ID.
  var partitionID: Google_Datastore_V1_PartitionId {
    get {return _partitionID ?? Google_Datastore_V1_PartitionId()}
    set {_partitionID = newValue}
  }
  /// Returns true if `partitionID` has been explicitly set.
  var hasPartitionID: Bool {return self._partitionID != nil}
  /// Clears the value of `partitionID`. Subsequent reads from it will return its default value.
  mutating func clearPartitionID() {self._partitionID = nil}

  /// The options for this query.
  var readOptions: Google_Datastore_V1_ReadOptions {
    get {return _readOptions ?? Google_Datastore_V1_ReadOptions()}
    set {_readOptions = newValue}
  }
  /// Returns true if `readOptions` has been explicitly set.
  var hasReadOptions: Bool {return self._readOptions != nil}
  /// Clears the value of `readOptions`. Subsequent reads from it will return its default value.
  mutating func clearReadOptions() {self._readOptions = nil}

  /// The type of query.
  var queryType: Google_Datastore_V1_RunQueryRequest.OneOf_QueryType? = nil

  /// The query to run.
  var query: Google_Datastore_V1_Query {
    get {
      if case .query(let v)? = queryType {return v}
      return Google_Datastore_V1_Query()
    }
    set {queryType = .query(newValue)}
  }

  /// The GQL query to run. This query must be a non-aggregation query.
  var gqlQuery: Google_Datastore_V1_GqlQuery {
    get {
      if case .gqlQuery(let v)? = queryType {return v}
      return Google_Datastore_V1_GqlQuery()
    }
    set {queryType = .gqlQuery(newValue)}
  }

  /// The properties to return.
  /// This field must not be set for a projection query.
  ///
  /// See
  /// [LookupRequest.property_mask][google.datastore.v1.LookupRequest.property_mask].
  var propertyMask: Google_Datastore_V1_PropertyMask {
    get {return _propertyMask ?? Google_Datastore_V1_PropertyMask()}
    set {_propertyMask = newValue}
  }
  /// Returns true if `propertyMask` has been explicitly set.
  var hasPropertyMask: Bool {return self._propertyMask != nil}
  /// Clears the value of `propertyMask`. Subsequent reads from it will return its default value.
  mutating func clearPropertyMask() {self._propertyMask = nil}

  /// Optional. Explain options for the query. If set, additional query
  /// statistics will be returned. If not, only query results will be returned.
  var explainOptions: Google_Datastore_V1_ExplainOptions {
    get {return _explainOptions ?? Google_Datastore_V1_ExplainOptions()}
    set {_explainOptions = newValue}
  }
  /// Returns true if `explainOptions` has been explicitly set.
  var hasExplainOptions: Bool {return self._explainOptions != nil}
  /// Clears the value of `explainOptions`. Subsequent reads from it will return its default value.
  mutating func clearExplainOptions() {self._explainOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of query.
  enum OneOf_QueryType: Equatable, Sendable {
    /// The query to run.
    case query(Google_Datastore_V1_Query)
    /// The GQL query to run. This query must be a non-aggregation query.
    case gqlQuery(Google_Datastore_V1_GqlQuery)

  }

  init() {}

  fileprivate var _partitionID: Google_Datastore_V1_PartitionId? = nil
  fileprivate var _readOptions: Google_Datastore_V1_ReadOptions? = nil
  fileprivate var _propertyMask: Google_Datastore_V1_PropertyMask? = nil
  fileprivate var _explainOptions: Google_Datastore_V1_ExplainOptions? = nil
}

/// The response for
/// [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
struct Google_Datastore_V1_RunQueryResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A batch of query results (always present).
  var batch: Google_Datastore_V1_QueryResultBatch {
    get {return _storage._batch ?? Google_Datastore_V1_QueryResultBatch()}
    set {_uniqueStorage()._batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  var hasBatch: Bool {return _storage._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  mutating func clearBatch() {_uniqueStorage()._batch = nil}

  /// The parsed form of the `GqlQuery` from the request, if it was set.
  var query: Google_Datastore_V1_Query {
    get {return _storage._query ?? Google_Datastore_V1_Query()}
    set {_uniqueStorage()._query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  var hasQuery: Bool {return _storage._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  mutating func clearQuery() {_uniqueStorage()._query = nil}

  /// The identifier of the transaction that was started as part of this
  /// RunQuery request.
  ///
  /// Set only when
  /// [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
  /// was set in
  /// [RunQueryRequest.read_options][google.datastore.v1.RunQueryRequest.read_options].
  var transaction: Data {
    get {return _storage._transaction}
    set {_uniqueStorage()._transaction = newValue}
  }

  /// Query explain metrics. This is only present when the
  /// [RunQueryRequest.explain_options][google.datastore.v1.RunQueryRequest.explain_options]
  /// is provided, and it is sent only once with the last response in the stream.
  var explainMetrics: Google_Datastore_V1_ExplainMetrics {
    get {return _storage._explainMetrics ?? Google_Datastore_V1_ExplainMetrics()}
    set {_uniqueStorage()._explainMetrics = newValue}
  }
  /// Returns true if `explainMetrics` has been explicitly set.
  var hasExplainMetrics: Bool {return _storage._explainMetrics != nil}
  /// Clears the value of `explainMetrics`. Subsequent reads from it will return its default value.
  mutating func clearExplainMetrics() {_uniqueStorage()._explainMetrics = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The request for
/// [Datastore.RunAggregationQuery][google.datastore.v1.Datastore.RunAggregationQuery].
struct Google_Datastore_V1_RunAggregationQueryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// Entities are partitioned into subsets, identified by a partition ID.
  /// Queries are scoped to a single partition.
  /// This partition ID is normalized with the standard default context
  /// partition ID.
  var partitionID: Google_Datastore_V1_PartitionId {
    get {return _partitionID ?? Google_Datastore_V1_PartitionId()}
    set {_partitionID = newValue}
  }
  /// Returns true if `partitionID` has been explicitly set.
  var hasPartitionID: Bool {return self._partitionID != nil}
  /// Clears the value of `partitionID`. Subsequent reads from it will return its default value.
  mutating func clearPartitionID() {self._partitionID = nil}

  /// The options for this query.
  var readOptions: Google_Datastore_V1_ReadOptions {
    get {return _readOptions ?? Google_Datastore_V1_ReadOptions()}
    set {_readOptions = newValue}
  }
  /// Returns true if `readOptions` has been explicitly set.
  var hasReadOptions: Bool {return self._readOptions != nil}
  /// Clears the value of `readOptions`. Subsequent reads from it will return its default value.
  mutating func clearReadOptions() {self._readOptions = nil}

  /// The type of query.
  var queryType: Google_Datastore_V1_RunAggregationQueryRequest.OneOf_QueryType? = nil

  /// The query to run.
  var aggregationQuery: Google_Datastore_V1_AggregationQuery {
    get {
      if case .aggregationQuery(let v)? = queryType {return v}
      return Google_Datastore_V1_AggregationQuery()
    }
    set {queryType = .aggregationQuery(newValue)}
  }

  /// The GQL query to run. This query must be an aggregation query.
  var gqlQuery: Google_Datastore_V1_GqlQuery {
    get {
      if case .gqlQuery(let v)? = queryType {return v}
      return Google_Datastore_V1_GqlQuery()
    }
    set {queryType = .gqlQuery(newValue)}
  }

  /// Optional. Explain options for the query. If set, additional query
  /// statistics will be returned. If not, only query results will be returned.
  var explainOptions: Google_Datastore_V1_ExplainOptions {
    get {return _explainOptions ?? Google_Datastore_V1_ExplainOptions()}
    set {_explainOptions = newValue}
  }
  /// Returns true if `explainOptions` has been explicitly set.
  var hasExplainOptions: Bool {return self._explainOptions != nil}
  /// Clears the value of `explainOptions`. Subsequent reads from it will return its default value.
  mutating func clearExplainOptions() {self._explainOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of query.
  enum OneOf_QueryType: Equatable, Sendable {
    /// The query to run.
    case aggregationQuery(Google_Datastore_V1_AggregationQuery)
    /// The GQL query to run. This query must be an aggregation query.
    case gqlQuery(Google_Datastore_V1_GqlQuery)

  }

  init() {}

  fileprivate var _partitionID: Google_Datastore_V1_PartitionId? = nil
  fileprivate var _readOptions: Google_Datastore_V1_ReadOptions? = nil
  fileprivate var _explainOptions: Google_Datastore_V1_ExplainOptions? = nil
}

/// The response for
/// [Datastore.RunAggregationQuery][google.datastore.v1.Datastore.RunAggregationQuery].
struct Google_Datastore_V1_RunAggregationQueryResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A batch of aggregation results. Always present.
  var batch: Google_Datastore_V1_AggregationResultBatch {
    get {return _batch ?? Google_Datastore_V1_AggregationResultBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  mutating func clearBatch() {self._batch = nil}

  /// The parsed form of the `GqlQuery` from the request, if it was set.
  var query: Google_Datastore_V1_AggregationQuery {
    get {return _query ?? Google_Datastore_V1_AggregationQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  mutating func clearQuery() {self._query = nil}

  /// The identifier of the transaction that was started as part of this
  /// RunAggregationQuery request.
  ///
  /// Set only when
  /// [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
  /// was set in
  /// [RunAggregationQueryRequest.read_options][google.datastore.v1.RunAggregationQueryRequest.read_options].
  var transaction: Data = Data()

  /// Query explain metrics. This is only present when the
  /// [RunAggregationQueryRequest.explain_options][google.datastore.v1.RunAggregationQueryRequest.explain_options]
  /// is provided, and it is sent only once with the last response in the stream.
  var explainMetrics: Google_Datastore_V1_ExplainMetrics {
    get {return _explainMetrics ?? Google_Datastore_V1_ExplainMetrics()}
    set {_explainMetrics = newValue}
  }
  /// Returns true if `explainMetrics` has been explicitly set.
  var hasExplainMetrics: Bool {return self._explainMetrics != nil}
  /// Clears the value of `explainMetrics`. Subsequent reads from it will return its default value.
  mutating func clearExplainMetrics() {self._explainMetrics = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _batch: Google_Datastore_V1_AggregationResultBatch? = nil
  fileprivate var _query: Google_Datastore_V1_AggregationQuery? = nil
  fileprivate var _explainMetrics: Google_Datastore_V1_ExplainMetrics? = nil
}

/// The request for
/// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
struct Google_Datastore_V1_BeginTransactionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// Options for a new transaction.
  var transactionOptions: Google_Datastore_V1_TransactionOptions {
    get {return _transactionOptions ?? Google_Datastore_V1_TransactionOptions()}
    set {_transactionOptions = newValue}
  }
  /// Returns true if `transactionOptions` has been explicitly set.
  var hasTransactionOptions: Bool {return self._transactionOptions != nil}
  /// Clears the value of `transactionOptions`. Subsequent reads from it will return its default value.
  mutating func clearTransactionOptions() {self._transactionOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transactionOptions: Google_Datastore_V1_TransactionOptions? = nil
}

/// The response for
/// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
struct Google_Datastore_V1_BeginTransactionResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction identifier (always present).
  var transaction: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request for [Datastore.Rollback][google.datastore.v1.Datastore.Rollback].
struct Google_Datastore_V1_RollbackRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// Required. The transaction identifier, returned by a call to
  /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
  var transaction: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for
/// [Datastore.Rollback][google.datastore.v1.Datastore.Rollback]. (an empty
/// message).
struct Google_Datastore_V1_RollbackResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
struct Google_Datastore_V1_CommitRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// The type of commit to perform. Defaults to `TRANSACTIONAL`.
  var mode: Google_Datastore_V1_CommitRequest.Mode = .unspecified

  /// Must be set when mode is `TRANSACTIONAL`.
  var transactionSelector: Google_Datastore_V1_CommitRequest.OneOf_TransactionSelector? = nil

  /// The identifier of the transaction associated with the commit. A
  /// transaction identifier is returned by a call to
  /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
  var transaction: Data {
    get {
      if case .transaction(let v)? = transactionSelector {return v}
      return Data()
    }
    set {transactionSelector = .transaction(newValue)}
  }

  /// Options for beginning a new transaction for this request.
  /// The transaction is committed when the request completes. If specified,
  /// [TransactionOptions.mode][google.datastore.v1.TransactionOptions] must be
  /// [TransactionOptions.ReadWrite][google.datastore.v1.TransactionOptions.ReadWrite].
  var singleUseTransaction: Google_Datastore_V1_TransactionOptions {
    get {
      if case .singleUseTransaction(let v)? = transactionSelector {return v}
      return Google_Datastore_V1_TransactionOptions()
    }
    set {transactionSelector = .singleUseTransaction(newValue)}
  }

  /// The mutations to perform.
  ///
  /// When mode is `TRANSACTIONAL`, mutations affecting a single entity are
  /// applied in order. The following sequences of mutations affecting a single
  /// entity are not permitted in a single `Commit` request:
  ///
  /// - `insert` followed by `insert`
  /// - `update` followed by `insert`
  /// - `upsert` followed by `insert`
  /// - `delete` followed by `update`
  ///
  /// When mode is `NON_TRANSACTIONAL`, no two mutations may affect a single
  /// entity.
  var mutations: [Google_Datastore_V1_Mutation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Must be set when mode is `TRANSACTIONAL`.
  enum OneOf_TransactionSelector: Equatable, @unchecked Sendable {
    /// The identifier of the transaction associated with the commit. A
    /// transaction identifier is returned by a call to
    /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
    case transaction(Data)
    /// Options for beginning a new transaction for this request.
    /// The transaction is committed when the request completes. If specified,
    /// [TransactionOptions.mode][google.datastore.v1.TransactionOptions] must be
    /// [TransactionOptions.ReadWrite][google.datastore.v1.TransactionOptions.ReadWrite].
    case singleUseTransaction(Google_Datastore_V1_TransactionOptions)

  }

  /// The modes available for commits.
  enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// Transactional: The mutations are either all applied, or none are applied.
    /// Learn about transactions
    /// [here](https://cloud.google.com/datastore/docs/concepts/transactions).
    case transactional // = 1

    /// Non-transactional: The mutations may not apply as all or none.
    case nonTransactional // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .transactional
      case 2: self = .nonTransactional
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .transactional: return 1
      case .nonTransactional: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Datastore_V1_CommitRequest.Mode] = [
      .unspecified,
      .transactional,
      .nonTransactional,
    ]

  }

  init() {}
}

/// The response for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
struct Google_Datastore_V1_CommitResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result of performing the mutations.
  /// The i-th mutation result corresponds to the i-th mutation in the request.
  var mutationResults: [Google_Datastore_V1_MutationResult] = []

  /// The number of index entries updated during the commit, or zero if none were
  /// updated.
  var indexUpdates: Int32 = 0

  /// The transaction commit timestamp. Not set for non-transactional commits.
  var commitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTime = newValue}
  }
  /// Returns true if `commitTime` has been explicitly set.
  var hasCommitTime: Bool {return self._commitTime != nil}
  /// Clears the value of `commitTime`. Subsequent reads from it will return its default value.
  mutating func clearCommitTime() {self._commitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for
/// [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
struct Google_Datastore_V1_AllocateIdsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// Required. A list of keys with incomplete key paths for which to allocate
  /// IDs. No key may be reserved/read-only.
  var keys: [Google_Datastore_V1_Key] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for
/// [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
struct Google_Datastore_V1_AllocateIdsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The keys specified in the request (in the same order), each with
  /// its key path completed with a newly allocated ID.
  var keys: [Google_Datastore_V1_Key] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request for
/// [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
struct Google_Datastore_V1_ReserveIdsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the project against which to make the request.
  var projectID: String = String()

  /// The ID of the database against which to make the request.
  ///
  /// '(default)' is not allowed; please use empty string '' to refer the default
  /// database.
  var databaseID: String = String()

  /// Required. A list of keys with complete key paths whose numeric IDs should
  /// not be auto-allocated.
  var keys: [Google_Datastore_V1_Key] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for
/// [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
struct Google_Datastore_V1_ReserveIdsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A mutation to apply to an entity.
struct Google_Datastore_V1_Mutation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The mutation operation.
  ///
  /// For `insert`, `update`, and `upsert`:
  /// - The entity's key must not be reserved/read-only.
  /// - No property in the entity may have a reserved name,
  ///   not even a property in an entity in a value.
  /// - No value in the entity may have meaning 18,
  ///   not even a value in an entity in another value.
  var operation: Google_Datastore_V1_Mutation.OneOf_Operation? = nil

  /// The entity to insert. The entity must not already exist.
  /// The entity key's final path element may be incomplete.
  var insert: Google_Datastore_V1_Entity {
    get {
      if case .insert(let v)? = operation {return v}
      return Google_Datastore_V1_Entity()
    }
    set {operation = .insert(newValue)}
  }

  /// The entity to update. The entity must already exist.
  /// Must have a complete key path.
  var update: Google_Datastore_V1_Entity {
    get {
      if case .update(let v)? = operation {return v}
      return Google_Datastore_V1_Entity()
    }
    set {operation = .update(newValue)}
  }

  /// The entity to upsert. The entity may or may not already exist.
  /// The entity key's final path element may be incomplete.
  var upsert: Google_Datastore_V1_Entity {
    get {
      if case .upsert(let v)? = operation {return v}
      return Google_Datastore_V1_Entity()
    }
    set {operation = .upsert(newValue)}
  }

  /// The key of the entity to delete. The entity may or may not already exist.
  /// Must have a complete key path and must not be reserved/read-only.
  var delete: Google_Datastore_V1_Key {
    get {
      if case .delete(let v)? = operation {return v}
      return Google_Datastore_V1_Key()
    }
    set {operation = .delete(newValue)}
  }

  /// When set, the server will detect whether or not this mutation conflicts
  /// with the current version of the entity on the server. Conflicting mutations
  /// are not applied, and are marked as such in MutationResult.
  var conflictDetectionStrategy: Google_Datastore_V1_Mutation.OneOf_ConflictDetectionStrategy? = nil

  /// The version of the entity that this mutation is being applied
  /// to. If this does not match the current version on the server, the
  /// mutation conflicts.
  var baseVersion: Int64 {
    get {
      if case .baseVersion(let v)? = conflictDetectionStrategy {return v}
      return 0
    }
    set {conflictDetectionStrategy = .baseVersion(newValue)}
  }

  /// The update time of the entity that this mutation is being applied
  /// to. If this does not match the current update time on the server, the
  /// mutation conflicts.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .updateTime(let v)? = conflictDetectionStrategy {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {conflictDetectionStrategy = .updateTime(newValue)}
  }

  /// The properties to write in this mutation.
  /// None of the properties in the mask may have a reserved name, except for
  /// `__key__`.
  /// This field is ignored for `delete`.
  ///
  /// If the entity already exists, only properties referenced in the mask are
  /// updated, others are left untouched.
  /// Properties referenced in the mask but not in the entity are deleted.
  var propertyMask: Google_Datastore_V1_PropertyMask {
    get {return _propertyMask ?? Google_Datastore_V1_PropertyMask()}
    set {_propertyMask = newValue}
  }
  /// Returns true if `propertyMask` has been explicitly set.
  var hasPropertyMask: Bool {return self._propertyMask != nil}
  /// Clears the value of `propertyMask`. Subsequent reads from it will return its default value.
  mutating func clearPropertyMask() {self._propertyMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The mutation operation.
  ///
  /// For `insert`, `update`, and `upsert`:
  /// - The entity's key must not be reserved/read-only.
  /// - No property in the entity may have a reserved name,
  ///   not even a property in an entity in a value.
  /// - No value in the entity may have meaning 18,
  ///   not even a value in an entity in another value.
  enum OneOf_Operation: Equatable, Sendable {
    /// The entity to insert. The entity must not already exist.
    /// The entity key's final path element may be incomplete.
    case insert(Google_Datastore_V1_Entity)
    /// The entity to update. The entity must already exist.
    /// Must have a complete key path.
    case update(Google_Datastore_V1_Entity)
    /// The entity to upsert. The entity may or may not already exist.
    /// The entity key's final path element may be incomplete.
    case upsert(Google_Datastore_V1_Entity)
    /// The key of the entity to delete. The entity may or may not already exist.
    /// Must have a complete key path and must not be reserved/read-only.
    case delete(Google_Datastore_V1_Key)

  }

  /// When set, the server will detect whether or not this mutation conflicts
  /// with the current version of the entity on the server. Conflicting mutations
  /// are not applied, and are marked as such in MutationResult.
  enum OneOf_ConflictDetectionStrategy: Equatable, Sendable {
    /// The version of the entity that this mutation is being applied
    /// to. If this does not match the current version on the server, the
    /// mutation conflicts.
    case baseVersion(Int64)
    /// The update time of the entity that this mutation is being applied
    /// to. If this does not match the current update time on the server, the
    /// mutation conflicts.
    case updateTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  }

  init() {}

  fileprivate var _propertyMask: Google_Datastore_V1_PropertyMask? = nil
}

/// The result of applying a mutation.
struct Google_Datastore_V1_MutationResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The automatically allocated key.
  /// Set only when the mutation allocated a key.
  var key: Google_Datastore_V1_Key {
    get {return _key ?? Google_Datastore_V1_Key()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// The version of the entity on the server after processing the mutation. If
  /// the mutation doesn't change anything on the server, then the version will
  /// be the version of the current entity or, if no entity is present, a version
  /// that is strictly greater than the version of any previous entity and less
  /// than the version of any possible future entity.
  var version: Int64 = 0

  /// The create time of the entity. This field will not be set after a 'delete'.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// The update time of the entity on the server after processing the mutation.
  /// If the mutation doesn't change anything on the server, then the timestamp
  /// will be the update timestamp of the current entity. This field will not be
  /// set after a 'delete'.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  /// Whether a conflict was detected for this mutation. Always false when a
  /// conflict detection strategy field is not set in the mutation.
  var conflictDetected: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: Google_Datastore_V1_Key? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The set of arbitrarily nested property paths used to restrict an operation to
/// only a subset of properties in an entity.
struct Google_Datastore_V1_PropertyMask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The paths to the properties covered by this mask.
  ///
  /// A path is a list of property names separated by dots (`.`), for example
  /// `foo.bar` means the property `bar` inside the entity property `foo` inside
  /// the entity associated with this path.
  ///
  /// If a property name contains a dot `.` or a backslash `\`, then that
  /// name must be escaped.
  ///
  /// A path must not be empty, and may not reference a value inside an
  /// [array value][google.datastore.v1.Value.array_value].
  var paths: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The options shared by read requests.
struct Google_Datastore_V1_ReadOptions: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For Cloud Datastore, if read_consistency is not specified, then lookups and
  /// ancestor queries default to `read_consistency`=`STRONG`, global queries
  /// default to `read_consistency`=`EVENTUAL`.
  ///
  /// For Cloud Firestore in Datastore mode, if read_consistency is not specified
  /// then lookups and all queries default to `read_consistency`=`STRONG`.
  ///
  /// Explicitly setting `read_consistency`=`EVENTUAL` will result in eventually
  /// consistent lookups & queries in both Cloud Datastore & Cloud Firestore in
  /// Datastore mode.
  var consistencyType: Google_Datastore_V1_ReadOptions.OneOf_ConsistencyType? = nil

  /// The non-transactional read consistency to use.
  var readConsistency: Google_Datastore_V1_ReadOptions.ReadConsistency {
    get {
      if case .readConsistency(let v)? = consistencyType {return v}
      return .unspecified
    }
    set {consistencyType = .readConsistency(newValue)}
  }

  /// The identifier of the transaction in which to read. A
  /// transaction identifier is returned by a call to
  /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
  var transaction: Data {
    get {
      if case .transaction(let v)? = consistencyType {return v}
      return Data()
    }
    set {consistencyType = .transaction(newValue)}
  }

  /// Options for beginning a new transaction for this request.
  ///
  /// The new transaction identifier will be returned in the corresponding
  /// response as either
  /// [LookupResponse.transaction][google.datastore.v1.LookupResponse.transaction]
  /// or
  /// [RunQueryResponse.transaction][google.datastore.v1.RunQueryResponse.transaction].
  var newTransaction: Google_Datastore_V1_TransactionOptions {
    get {
      if case .newTransaction(let v)? = consistencyType {return v}
      return Google_Datastore_V1_TransactionOptions()
    }
    set {consistencyType = .newTransaction(newValue)}
  }

  /// Reads entities as they were at the given time. This value is only
  /// supported for Cloud Firestore in Datastore mode.
  ///
  /// This must be a microsecond precision timestamp within the past one hour,
  /// or if Point-in-Time Recovery is enabled, can additionally be a whole
  /// minute timestamp within the past 7 days.
  var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencyType {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencyType = .readTime(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// For Cloud Datastore, if read_consistency is not specified, then lookups and
  /// ancestor queries default to `read_consistency`=`STRONG`, global queries
  /// default to `read_consistency`=`EVENTUAL`.
  ///
  /// For Cloud Firestore in Datastore mode, if read_consistency is not specified
  /// then lookups and all queries default to `read_consistency`=`STRONG`.
  ///
  /// Explicitly setting `read_consistency`=`EVENTUAL` will result in eventually
  /// consistent lookups & queries in both Cloud Datastore & Cloud Firestore in
  /// Datastore mode.
  enum OneOf_ConsistencyType: Equatable, @unchecked Sendable {
    /// The non-transactional read consistency to use.
    case readConsistency(Google_Datastore_V1_ReadOptions.ReadConsistency)
    /// The identifier of the transaction in which to read. A
    /// transaction identifier is returned by a call to
    /// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
    case transaction(Data)
    /// Options for beginning a new transaction for this request.
    ///
    /// The new transaction identifier will be returned in the corresponding
    /// response as either
    /// [LookupResponse.transaction][google.datastore.v1.LookupResponse.transaction]
    /// or
    /// [RunQueryResponse.transaction][google.datastore.v1.RunQueryResponse.transaction].
    case newTransaction(Google_Datastore_V1_TransactionOptions)
    /// Reads entities as they were at the given time. This value is only
    /// supported for Cloud Firestore in Datastore mode.
    ///
    /// This must be a microsecond precision timestamp within the past one hour,
    /// or if Point-in-Time Recovery is enabled, can additionally be a whole
    /// minute timestamp within the past 7 days.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  }

  /// The possible values for read consistencies.
  enum ReadConsistency: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// Strong consistency.
    case strong // = 1

    /// Eventual consistency.
    case eventual // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .strong
      case 2: self = .eventual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .strong: return 1
      case .eventual: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Google_Datastore_V1_ReadOptions.ReadConsistency] = [
      .unspecified,
      .strong,
      .eventual,
    ]

  }

  init() {}
}

/// Options for beginning a new transaction.
///
/// Transactions can be created explicitly with calls to
/// [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction]
/// or implicitly by setting
/// [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
/// in read requests.
struct Google_Datastore_V1_TransactionOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `mode` of the transaction, indicating whether write operations are
  /// supported.
  var mode: Google_Datastore_V1_TransactionOptions.OneOf_Mode? = nil

  /// The transaction should allow both reads and writes.
  var readWrite: Google_Datastore_V1_TransactionOptions.ReadWrite {
    get {
      if case .readWrite(let v)? = mode {return v}
      return Google_Datastore_V1_TransactionOptions.ReadWrite()
    }
    set {mode = .readWrite(newValue)}
  }

  /// The transaction should only allow reads.
  var readOnly: Google_Datastore_V1_TransactionOptions.ReadOnly {
    get {
      if case .readOnly(let v)? = mode {return v}
      return Google_Datastore_V1_TransactionOptions.ReadOnly()
    }
    set {mode = .readOnly(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The `mode` of the transaction, indicating whether write operations are
  /// supported.
  enum OneOf_Mode: Equatable, Sendable {
    /// The transaction should allow both reads and writes.
    case readWrite(Google_Datastore_V1_TransactionOptions.ReadWrite)
    /// The transaction should only allow reads.
    case readOnly(Google_Datastore_V1_TransactionOptions.ReadOnly)

  }

  /// Options specific to read / write transactions.
  struct ReadWrite: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The transaction identifier of the transaction being retried.
    var previousTransaction: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Options specific to read-only transactions.
  struct ReadOnly: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Reads entities at the given time.
    ///
    /// This must be a microsecond precision timestamp within the past one hour,
    /// or if Point-in-Time Recovery is enabled, can additionally be a whole
    /// minute timestamp within the past 7 days.
    var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_readTime = newValue}
    }
    /// Returns true if `readTime` has been explicitly set.
    var hasReadTime: Bool {return self._readTime != nil}
    /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
    mutating func clearReadTime() {self._readTime = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.datastore.v1"

extension Google_Datastore_V1_LookupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LookupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    1: .standard(proto: "read_options"),
    3: .same(proto: "keys"),
    5: .standard(proto: "property_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._readOptions) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._propertyMask) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._readOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 3)
    }
    try { if let v = self._propertyMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_LookupRequest, rhs: Google_Datastore_V1_LookupRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs._readOptions != rhs._readOptions {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs._propertyMask != rhs._propertyMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_LookupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LookupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
    3: .same(proto: "deferred"),
    5: .same(proto: "transaction"),
    7: .standard(proto: "read_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.found) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.missing) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.deferred) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.found.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.found, fieldNumber: 1)
    }
    if !self.missing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.missing, fieldNumber: 2)
    }
    if !self.deferred.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deferred, fieldNumber: 3)
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 5)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_LookupResponse, rhs: Google_Datastore_V1_LookupResponse) -> Bool {
    if lhs.found != rhs.found {return false}
    if lhs.missing != rhs.missing {return false}
    if lhs.deferred != rhs.deferred {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RunQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunQueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    2: .standard(proto: "partition_id"),
    1: .standard(proto: "read_options"),
    3: .same(proto: "query"),
    7: .standard(proto: "gql_query"),
    10: .standard(proto: "property_mask"),
    12: .standard(proto: "explain_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._readOptions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._partitionID) }()
      case 3: try {
        var v: Google_Datastore_V1_Query?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .query(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .query(v)
        }
      }()
      case 7: try {
        var v: Google_Datastore_V1_GqlQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .gqlQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .gqlQuery(v)
        }
      }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._propertyMask) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._explainOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._readOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._partitionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.queryType {
    case .query?: try {
      guard case .query(let v)? = self.queryType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .gqlQuery?: try {
      guard case .gqlQuery(let v)? = self.queryType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try { if let v = self._propertyMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._explainOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_RunQueryRequest, rhs: Google_Datastore_V1_RunQueryRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs._partitionID != rhs._partitionID {return false}
    if lhs._readOptions != rhs._readOptions {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs._propertyMask != rhs._propertyMask {return false}
    if lhs._explainOptions != rhs._explainOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RunQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunQueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "query"),
    5: .same(proto: "transaction"),
    9: .standard(proto: "explain_metrics"),
  ]

  fileprivate class _StorageClass {
    var _batch: Google_Datastore_V1_QueryResultBatch? = nil
    var _query: Google_Datastore_V1_Query? = nil
    var _transaction: Data = Data()
    var _explainMetrics: Google_Datastore_V1_ExplainMetrics? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _batch = source._batch
      _query = source._query
      _transaction = source._transaction
      _explainMetrics = source._explainMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._batch) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._transaction) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._explainMetrics) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._batch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._transaction.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._transaction, fieldNumber: 5)
      }
      try { if let v = _storage._explainMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_RunQueryResponse, rhs: Google_Datastore_V1_RunQueryResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._batch != rhs_storage._batch {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._explainMetrics != rhs_storage._explainMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RunAggregationQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAggregationQueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    2: .standard(proto: "partition_id"),
    1: .standard(proto: "read_options"),
    3: .standard(proto: "aggregation_query"),
    7: .standard(proto: "gql_query"),
    11: .standard(proto: "explain_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._readOptions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._partitionID) }()
      case 3: try {
        var v: Google_Datastore_V1_AggregationQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .aggregationQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .aggregationQuery(v)
        }
      }()
      case 7: try {
        var v: Google_Datastore_V1_GqlQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .gqlQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .gqlQuery(v)
        }
      }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._explainOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._readOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._partitionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.queryType {
    case .aggregationQuery?: try {
      guard case .aggregationQuery(let v)? = self.queryType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .gqlQuery?: try {
      guard case .gqlQuery(let v)? = self.queryType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try { if let v = self._explainOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_RunAggregationQueryRequest, rhs: Google_Datastore_V1_RunAggregationQueryRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs._partitionID != rhs._partitionID {return false}
    if lhs._readOptions != rhs._readOptions {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs._explainOptions != rhs._explainOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RunAggregationQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAggregationQueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .same(proto: "query"),
    5: .same(proto: "transaction"),
    9: .standard(proto: "explain_metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._explainMetrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 5)
    }
    try { if let v = self._explainMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_RunAggregationQueryResponse, rhs: Google_Datastore_V1_RunAggregationQueryResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs._query != rhs._query {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs._explainMetrics != rhs._explainMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_BeginTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeginTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    10: .standard(proto: "transaction_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._transactionOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try { if let v = self._transactionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_BeginTransactionRequest, rhs: Google_Datastore_V1_BeginTransactionRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs._transactionOptions != rhs._transactionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_BeginTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeginTransactionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_BeginTransactionResponse, rhs: Google_Datastore_V1_BeginTransactionResponse) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RollbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollbackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    1: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_RollbackRequest, rhs: Google_Datastore_V1_RollbackRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_RollbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollbackResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_RollbackResponse, rhs: Google_Datastore_V1_RollbackResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CommitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    5: .same(proto: "mode"),
    1: .same(proto: "transaction"),
    10: .standard(proto: "single_use_transaction"),
    6: .same(proto: "mutations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.transactionSelector != nil {try decoder.handleConflictingOneOf()}
          self.transactionSelector = .transaction(v)
        }
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.mutations) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      case 10: try {
        var v: Google_Datastore_V1_TransactionOptions?
        var hadOneofValue = false
        if let current = self.transactionSelector {
          hadOneofValue = true
          if case .singleUseTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transactionSelector = .singleUseTransaction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .transaction(let v)? = self.transactionSelector {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 5)
    }
    if !self.mutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutations, fieldNumber: 6)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try { if case .singleUseTransaction(let v)? = self.transactionSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_CommitRequest, rhs: Google_Datastore_V1_CommitRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.transactionSelector != rhs.transactionSelector {return false}
    if lhs.mutations != rhs.mutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CommitRequest.Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_UNSPECIFIED"),
    1: .same(proto: "TRANSACTIONAL"),
    2: .same(proto: "NON_TRANSACTIONAL"),
  ]
}

extension Google_Datastore_V1_CommitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "mutation_results"),
    4: .standard(proto: "index_updates"),
    8: .standard(proto: "commit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mutationResults) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.indexUpdates) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._commitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mutationResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutationResults, fieldNumber: 3)
    }
    if self.indexUpdates != 0 {
      try visitor.visitSingularInt32Field(value: self.indexUpdates, fieldNumber: 4)
    }
    try { if let v = self._commitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_CommitResponse, rhs: Google_Datastore_V1_CommitResponse) -> Bool {
    if lhs.mutationResults != rhs.mutationResults {return false}
    if lhs.indexUpdates != rhs.indexUpdates {return false}
    if lhs._commitTime != rhs._commitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AllocateIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllocateIdsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_AllocateIdsRequest, rhs: Google_Datastore_V1_AllocateIdsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_AllocateIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllocateIdsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_AllocateIdsResponse, rhs: Google_Datastore_V1_AllocateIdsResponse) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReserveIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReserveIdsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "project_id"),
    9: .standard(proto: "database_id"),
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 8)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_ReserveIdsRequest, rhs: Google_Datastore_V1_ReserveIdsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReserveIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReserveIdsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_ReserveIdsResponse, rhs: Google_Datastore_V1_ReserveIdsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Mutation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mutation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "insert"),
    5: .same(proto: "update"),
    6: .same(proto: "upsert"),
    7: .same(proto: "delete"),
    8: .standard(proto: "base_version"),
    11: .standard(proto: "update_time"),
    9: .standard(proto: "property_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: Google_Datastore_V1_Entity?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .insert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .insert(v)
        }
      }()
      case 5: try {
        var v: Google_Datastore_V1_Entity?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .update(v)
        }
      }()
      case 6: try {
        var v: Google_Datastore_V1_Entity?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .upsert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .upsert(v)
        }
      }()
      case 7: try {
        var v: Google_Datastore_V1_Key?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .delete(v)
        }
      }()
      case 8: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.conflictDetectionStrategy != nil {try decoder.handleConflictingOneOf()}
          self.conflictDetectionStrategy = .baseVersion(v)
        }
      }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._propertyMask) }()
      case 11: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.conflictDetectionStrategy {
          hadOneofValue = true
          if case .updateTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conflictDetectionStrategy = .updateTime(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .insert?: try {
      guard case .insert(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .update?: try {
      guard case .update(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .upsert?: try {
      guard case .upsert(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try { if case .baseVersion(let v)? = self.conflictDetectionStrategy {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._propertyMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if case .updateTime(let v)? = self.conflictDetectionStrategy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_Mutation, rhs: Google_Datastore_V1_Mutation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.conflictDetectionStrategy != rhs.conflictDetectionStrategy {return false}
    if lhs._propertyMask != rhs._propertyMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_MutationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MutationResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "key"),
    4: .same(proto: "version"),
    7: .standard(proto: "create_time"),
    6: .standard(proto: "update_time"),
    5: .standard(proto: "conflict_detected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.conflictDetected) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 4)
    }
    if self.conflictDetected != false {
      try visitor.visitSingularBoolField(value: self.conflictDetected, fieldNumber: 5)
    }
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_MutationResult, rhs: Google_Datastore_V1_MutationResult) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.version != rhs.version {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.conflictDetected != rhs.conflictDetected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyMask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyMask"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_PropertyMask, rhs: Google_Datastore_V1_PropertyMask) -> Bool {
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReadOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_consistency"),
    2: .same(proto: "transaction"),
    3: .standard(proto: "new_transaction"),
    4: .standard(proto: "read_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Datastore_V1_ReadOptions.ReadConsistency?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.consistencyType != nil {try decoder.handleConflictingOneOf()}
          self.consistencyType = .readConsistency(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencyType != nil {try decoder.handleConflictingOneOf()}
          self.consistencyType = .transaction(v)
        }
      }()
      case 3: try {
        var v: Google_Datastore_V1_TransactionOptions?
        var hadOneofValue = false
        if let current = self.consistencyType {
          hadOneofValue = true
          if case .newTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencyType = .newTransaction(v)
        }
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencyType {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencyType = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.consistencyType {
    case .readConsistency?: try {
      guard case .readConsistency(let v)? = self.consistencyType else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencyType else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .newTransaction?: try {
      guard case .newTransaction(let v)? = self.consistencyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_ReadOptions, rhs: Google_Datastore_V1_ReadOptions) -> Bool {
    if lhs.consistencyType != rhs.consistencyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_ReadOptions.ReadConsistency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "READ_CONSISTENCY_UNSPECIFIED"),
    1: .same(proto: "STRONG"),
    2: .same(proto: "EVENTUAL"),
  ]
}

extension Google_Datastore_V1_TransactionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_write"),
    2: .standard(proto: "read_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Datastore_V1_TransactionOptions.ReadWrite?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .readWrite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .readWrite(v)
        }
      }()
      case 2: try {
        var v: Google_Datastore_V1_TransactionOptions.ReadOnly?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .readOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .readOnly(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mode {
    case .readWrite?: try {
      guard case .readWrite(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .readOnly?: try {
      guard case .readOnly(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_TransactionOptions, rhs: Google_Datastore_V1_TransactionOptions) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_TransactionOptions.ReadWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Datastore_V1_TransactionOptions.protoMessageName + ".ReadWrite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "previous_transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.previousTransaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.previousTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousTransaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_TransactionOptions.ReadWrite, rhs: Google_Datastore_V1_TransactionOptions.ReadWrite) -> Bool {
    if lhs.previousTransaction != rhs.previousTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_TransactionOptions.ReadOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Datastore_V1_TransactionOptions.protoMessageName + ".ReadOnly"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_TransactionOptions.ReadOnly, rhs: Google_Datastore_V1_TransactionOptions.ReadOnly) -> Bool {
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
