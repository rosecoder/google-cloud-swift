// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/distribution.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// `Distribution` contains summary statistics for a population of values. It
/// optionally contains a histogram representing the distribution of those values
/// across a set of buckets.
///
/// The summary statistics are the count, mean, sum of the squared deviation from
/// the mean, the minimum, and the maximum of the set of population of values.
/// The histogram is based on a sequence of buckets and gives a count of values
/// that fall into each bucket. The boundaries of the buckets are given either
/// explicitly or by formulas for buckets of fixed or exponentially increasing
/// widths.
///
/// Although it is not forbidden, it is generally a bad idea to include
/// non-finite values (infinities or NaNs) in the population of values, as this
/// will render the `mean` and `sum_of_squared_deviation` fields meaningless.
struct Google_Api_Distribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of values in the population. Must be non-negative. This value
  /// must equal the sum of the values in `bucket_counts` if a histogram is
  /// provided.
  var count: Int64 = 0

  /// The arithmetic mean of the values in the population. If `count` is zero
  /// then this field must be zero.
  var mean: Double = 0

  /// The sum of squared deviations from the mean of the values in the
  /// population. For values x_i this is:
  ///
  ///     Sum[i=1..n]((x_i - mean)^2)
  ///
  /// Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition
  /// describes Welford's method for accumulating this sum in one pass.
  ///
  /// If `count` is zero then this field must be zero.
  var sumOfSquaredDeviation: Double = 0

  /// If specified, contains the range of the population values. The field
  /// must not be present if the `count` is zero.
  var range: Google_Api_Distribution.Range {
    get {return _range ?? Google_Api_Distribution.Range()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  mutating func clearRange() {self._range = nil}

  /// Defines the histogram bucket boundaries. If the distribution does not
  /// contain a histogram, then omit this field.
  var bucketOptions: Google_Api_Distribution.BucketOptions {
    get {return _bucketOptions ?? Google_Api_Distribution.BucketOptions()}
    set {_bucketOptions = newValue}
  }
  /// Returns true if `bucketOptions` has been explicitly set.
  var hasBucketOptions: Bool {return self._bucketOptions != nil}
  /// Clears the value of `bucketOptions`. Subsequent reads from it will return its default value.
  mutating func clearBucketOptions() {self._bucketOptions = nil}

  /// The number of values in each bucket of the histogram, as described in
  /// `bucket_options`. If the distribution does not have a histogram, then omit
  /// this field. If there is a histogram, then the sum of the values in
  /// `bucket_counts` must equal the value in the `count` field of the
  /// distribution.
  ///
  /// If present, `bucket_counts` should contain N values, where N is the number
  /// of buckets specified in `bucket_options`. If you supply fewer than N
  /// values, the remaining values are assumed to be 0.
  ///
  /// The order of the values in `bucket_counts` follows the bucket numbering
  /// schemes described for the three bucket types. The first value must be the
  /// count for the underflow bucket (number 0). The next N-2 values are the
  /// counts for the finite buckets (number 1 through N-2). The N'th value in
  /// `bucket_counts` is the count for the overflow bucket (number N-1).
  var bucketCounts: [Int64] = []

  /// Must be in increasing order of `value` field.
  var exemplars: [Google_Api_Distribution.Exemplar] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The range of the population values.
  struct Range {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The minimum of the population values.
    var min: Double = 0

    /// The maximum of the population values.
    var max: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// `BucketOptions` describes the bucket boundaries used to create a histogram
  /// for the distribution. The buckets can be in a linear sequence, an
  /// exponential sequence, or each bucket can be specified explicitly.
  /// `BucketOptions` does not include the number of values in each bucket.
  ///
  /// A bucket has an inclusive lower bound and exclusive upper bound for the
  /// values that are counted for that bucket. The upper bound of a bucket must
  /// be strictly greater than the lower bound. The sequence of N buckets for a
  /// distribution consists of an underflow bucket (number 0), zero or more
  /// finite buckets (number 1 through N - 2) and an overflow bucket (number N -
  /// 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the
  /// same as the upper bound of bucket i - 1. The buckets span the whole range
  /// of finite values: lower bound of the underflow bucket is -infinity and the
  /// upper bound of the overflow bucket is +infinity. The finite buckets are
  /// so-called because both bounds are finite.
  struct BucketOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Exactly one of these three fields must be set.
    var options: Google_Api_Distribution.BucketOptions.OneOf_Options? = nil

    /// The linear bucket.
    var linearBuckets: Google_Api_Distribution.BucketOptions.Linear {
      get {
        if case .linearBuckets(let v)? = options {return v}
        return Google_Api_Distribution.BucketOptions.Linear()
      }
      set {options = .linearBuckets(newValue)}
    }

    /// The exponential buckets.
    var exponentialBuckets: Google_Api_Distribution.BucketOptions.Exponential {
      get {
        if case .exponentialBuckets(let v)? = options {return v}
        return Google_Api_Distribution.BucketOptions.Exponential()
      }
      set {options = .exponentialBuckets(newValue)}
    }

    /// The explicit buckets.
    var explicitBuckets: Google_Api_Distribution.BucketOptions.Explicit {
      get {
        if case .explicitBuckets(let v)? = options {return v}
        return Google_Api_Distribution.BucketOptions.Explicit()
      }
      set {options = .explicitBuckets(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Exactly one of these three fields must be set.
    enum OneOf_Options: Equatable {
      /// The linear bucket.
      case linearBuckets(Google_Api_Distribution.BucketOptions.Linear)
      /// The exponential buckets.
      case exponentialBuckets(Google_Api_Distribution.BucketOptions.Exponential)
      /// The explicit buckets.
      case explicitBuckets(Google_Api_Distribution.BucketOptions.Explicit)

    #if !swift(>=4.1)
      static func ==(lhs: Google_Api_Distribution.BucketOptions.OneOf_Options, rhs: Google_Api_Distribution.BucketOptions.OneOf_Options) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.linearBuckets, .linearBuckets): return {
          guard case .linearBuckets(let l) = lhs, case .linearBuckets(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.exponentialBuckets, .exponentialBuckets): return {
          guard case .exponentialBuckets(let l) = lhs, case .exponentialBuckets(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.explicitBuckets, .explicitBuckets): return {
          guard case .explicitBuckets(let l) = lhs, case .explicitBuckets(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Specifies a linear sequence of buckets that all have the same width
    /// (except overflow and underflow). Each bucket represents a constant
    /// absolute uncertainty on the specific value in the bucket.
    ///
    /// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
    /// following boundaries:
    ///
    ///    Upper bound (0 <= i < N-1):     offset + (width * i).
    ///    Lower bound (1 <= i < N):       offset + (width * (i - 1)).
    struct Linear {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Must be greater than 0.
      var numFiniteBuckets: Int32 = 0

      /// Must be greater than 0.
      var width: Double = 0

      /// Lower bound of the first bucket.
      var offset: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// Specifies an exponential sequence of buckets that have a width that is
    /// proportional to the value of the lower bound. Each bucket represents a
    /// constant relative uncertainty on a specific value in the bucket.
    ///
    /// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
    /// following boundaries:
    ///
    ///    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).
    ///    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).
    struct Exponential {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Must be greater than 0.
      var numFiniteBuckets: Int32 = 0

      /// Must be greater than 1.
      var growthFactor: Double = 0

      /// Must be greater than 0.
      var scale: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// Specifies a set of buckets with arbitrary widths.
    ///
    /// There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following
    /// boundaries:
    ///
    ///    Upper bound (0 <= i < N-1):     bounds[i]
    ///    Lower bound (1 <= i < N);       bounds[i - 1]
    ///
    /// The `bounds` field must contain at least one element. If `bounds` has
    /// only one element, then there are no finite buckets, and that single
    /// element is the common boundary of the overflow and underflow buckets.
    struct Explicit {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The values must be monotonically increasing.
      var bounds: [Double] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  /// Exemplars are example points that may be used to annotate aggregated
  /// distribution values. They are metadata that gives information about a
  /// particular value added to a Distribution bucket, such as a trace ID that
  /// was active when a value was added. They may contain further information,
  /// such as a example values and timestamps, origin, etc.
  struct Exemplar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Value of the exemplar point. This value determines to which bucket the
    /// exemplar belongs.
    var value: Double = 0

    /// The observation (sampling) time of the above value.
    var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    /// Contextual information about the example value. Examples are:
    ///
    ///   Trace: type.googleapis.com/google.monitoring.v3.SpanContext
    ///
    ///   Literal string: type.googleapis.com/google.protobuf.StringValue
    ///
    ///   Labels dropped during aggregation:
    ///     type.googleapis.com/google.monitoring.v3.DroppedLabels
    ///
    /// There may be only a single attachment of any given message type in a
    /// single exemplar, and this is enforced by the system.
    var attachments: [SwiftProtobuf.Google_Protobuf_Any] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  init() {}

  fileprivate var _range: Google_Api_Distribution.Range? = nil
  fileprivate var _bucketOptions: Google_Api_Distribution.BucketOptions? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api"

extension Google_Api_Distribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Distribution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "mean"),
    3: .standard(proto: "sum_of_squared_deviation"),
    4: .same(proto: "range"),
    6: .standard(proto: "bucket_options"),
    7: .standard(proto: "bucket_counts"),
    10: .same(proto: "exemplars"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.mean) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.sumOfSquaredDeviation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._bucketOptions) }()
      case 7: try { try decoder.decodeRepeatedInt64Field(value: &self.bucketCounts) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if self.mean != 0 {
      try visitor.visitSingularDoubleField(value: self.mean, fieldNumber: 2)
    }
    if self.sumOfSquaredDeviation != 0 {
      try visitor.visitSingularDoubleField(value: self.sumOfSquaredDeviation, fieldNumber: 3)
    }
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bucketOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedInt64Field(value: self.bucketCounts, fieldNumber: 7)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Distribution, rhs: Google_Api_Distribution) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.mean != rhs.mean {return false}
    if lhs.sumOfSquaredDeviation != rhs.sumOfSquaredDeviation {return false}
    if lhs._range != rhs._range {return false}
    if lhs._bucketOptions != rhs._bucketOptions {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Api_Distribution.protoMessageName + ".Range"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Distribution.Range, rhs: Google_Api_Distribution.Range) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Api_Distribution.protoMessageName + ".BucketOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linear_buckets"),
    2: .standard(proto: "exponential_buckets"),
    3: .standard(proto: "explicit_buckets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Api_Distribution.BucketOptions.Linear?
        var hadOneofValue = false
        if let current = self.options {
          hadOneofValue = true
          if case .linearBuckets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.options = .linearBuckets(v)
        }
      }()
      case 2: try {
        var v: Google_Api_Distribution.BucketOptions.Exponential?
        var hadOneofValue = false
        if let current = self.options {
          hadOneofValue = true
          if case .exponentialBuckets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.options = .exponentialBuckets(v)
        }
      }()
      case 3: try {
        var v: Google_Api_Distribution.BucketOptions.Explicit?
        var hadOneofValue = false
        if let current = self.options {
          hadOneofValue = true
          if case .explicitBuckets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.options = .explicitBuckets(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.options {
    case .linearBuckets?: try {
      guard case .linearBuckets(let v)? = self.options else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .exponentialBuckets?: try {
      guard case .exponentialBuckets(let v)? = self.options else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .explicitBuckets?: try {
      guard case .explicitBuckets(let v)? = self.options else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Distribution.BucketOptions, rhs: Google_Api_Distribution.BucketOptions) -> Bool {
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions.Linear: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Api_Distribution.BucketOptions.protoMessageName + ".Linear"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_finite_buckets"),
    2: .same(proto: "width"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numFiniteBuckets) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numFiniteBuckets != 0 {
      try visitor.visitSingularInt32Field(value: self.numFiniteBuckets, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Distribution.BucketOptions.Linear, rhs: Google_Api_Distribution.BucketOptions.Linear) -> Bool {
    if lhs.numFiniteBuckets != rhs.numFiniteBuckets {return false}
    if lhs.width != rhs.width {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions.Exponential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Api_Distribution.BucketOptions.protoMessageName + ".Exponential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_finite_buckets"),
    2: .standard(proto: "growth_factor"),
    3: .same(proto: "scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numFiniteBuckets) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.growthFactor) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.scale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numFiniteBuckets != 0 {
      try visitor.visitSingularInt32Field(value: self.numFiniteBuckets, fieldNumber: 1)
    }
    if self.growthFactor != 0 {
      try visitor.visitSingularDoubleField(value: self.growthFactor, fieldNumber: 2)
    }
    if self.scale != 0 {
      try visitor.visitSingularDoubleField(value: self.scale, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Distribution.BucketOptions.Exponential, rhs: Google_Api_Distribution.BucketOptions.Exponential) -> Bool {
    if lhs.numFiniteBuckets != rhs.numFiniteBuckets {return false}
    if lhs.growthFactor != rhs.growthFactor {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions.Explicit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Api_Distribution.BucketOptions.protoMessageName + ".Explicit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bounds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.bounds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.bounds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Distribution.BucketOptions.Explicit, rhs: Google_Api_Distribution.BucketOptions.Explicit) -> Bool {
    if lhs.bounds != rhs.bounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.Exemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Api_Distribution.protoMessageName + ".Exemplar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "attachments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Api_Distribution.Exemplar, rhs: Google_Api_Distribution.Exemplar) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
