// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/datastore/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The result of fetching an entity from Datastore.
struct Google_Datastore_V1_EntityResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resulting entity.
  var entity: Google_Datastore_V1_Entity {
    get {return _entity ?? Google_Datastore_V1_Entity()}
    set {_entity = newValue}
  }
  /// Returns true if `entity` has been explicitly set.
  var hasEntity: Bool {return self._entity != nil}
  /// Clears the value of `entity`. Subsequent reads from it will return its default value.
  mutating func clearEntity() {self._entity = nil}

  /// The version of the entity, a strictly positive number that monotonically
  /// increases with changes to the entity.
  ///
  /// This field is set for [`FULL`][google.datastore.v1.EntityResult.ResultType.FULL] entity
  /// results.
  ///
  /// For [missing][google.datastore.v1.LookupResponse.missing] entities in `LookupResponse`, this
  /// is the version of the snapshot that was used to look up the entity, and it
  /// is always set except for eventually consistent reads.
  var version: Int64 = 0

  /// A cursor that points to the position after the result entity.
  /// Set only when the `EntityResult` is part of a `QueryResultBatch` message.
  var cursor: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies what data the 'entity' field contains.
  /// A `ResultType` is either implied (for example, in `LookupResponse.missing`
  /// from `datastore.proto`, it is always `KEY_ONLY`) or specified by context
  /// (for example, in message `QueryResultBatch`, field `entity_result_type`
  /// specifies a `ResultType` for all the values in field `entity_results`).
  enum ResultType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unspecified. This value is never used.
    case unspecified // = 0

    /// The key and properties.
    case full // = 1

    /// A projected subset of properties. The entity may have no key.
    case projection // = 2

    /// Only the key.
    case keyOnly // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .full
      case 2: self = .projection
      case 3: self = .keyOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .full: return 1
      case .projection: return 2
      case .keyOnly: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _entity: Google_Datastore_V1_Entity? = nil
}

#if swift(>=4.2)

extension Google_Datastore_V1_EntityResult.ResultType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Datastore_V1_EntityResult.ResultType] = [
    .unspecified,
    .full,
    .projection,
    .keyOnly,
  ]
}

#endif  // swift(>=4.2)

/// A query for entities.
struct Google_Datastore_V1_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The projection to return. Defaults to returning all properties.
  var projection: [Google_Datastore_V1_Projection] = []

  /// The kinds to query (if empty, returns entities of all kinds).
  /// Currently at most 1 kind may be specified.
  var kind: [Google_Datastore_V1_KindExpression] = []

  /// The filter to apply.
  var filter: Google_Datastore_V1_Filter {
    get {return _filter ?? Google_Datastore_V1_Filter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  /// The order to apply to the query results (if empty, order is unspecified).
  var order: [Google_Datastore_V1_PropertyOrder] = []

  /// The properties to make distinct. The query results will contain the first
  /// result for each distinct combination of values for the given properties
  /// (if empty, all results are returned).
  var distinctOn: [Google_Datastore_V1_PropertyReference] = []

  /// A starting point for the query results. Query cursors are
  /// returned in query result batches and
  /// [can only be used to continue the same
  /// query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
  var startCursor: Data = Data()

  /// An ending point for the query results. Query cursors are
  /// returned in query result batches and
  /// [can only be used to limit the same
  /// query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
  var endCursor: Data = Data()

  /// The number of results to skip. Applies before limit, but after all other
  /// constraints. Optional. Must be >= 0 if specified.
  var offset: Int32 = 0

  /// The maximum number of results to return. Applies after all other
  /// constraints. Optional.
  /// Unspecified is interpreted as no limit.
  /// Must be >= 0 if specified.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {self._limit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Google_Datastore_V1_Filter? = nil
  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// A representation of a kind.
struct Google_Datastore_V1_KindExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the kind.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A reference to a property relative to the kind expressions.
struct Google_Datastore_V1_PropertyReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the property.
  /// If name includes "."s, it may be interpreted as a property name path.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A representation of a property in a projection.
struct Google_Datastore_V1_Projection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The property to project.
  var property: Google_Datastore_V1_PropertyReference {
    get {return _property ?? Google_Datastore_V1_PropertyReference()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
}

/// The desired order for a specific property.
struct Google_Datastore_V1_PropertyOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The property to order by.
  var property: Google_Datastore_V1_PropertyReference {
    get {return _property ?? Google_Datastore_V1_PropertyReference()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  /// The direction to order by. Defaults to `ASCENDING`.
  var direction: Google_Datastore_V1_PropertyOrder.Direction = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The sort direction.
  enum Direction: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// Ascending.
    case ascending // = 1

    /// Descending.
    case descending // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ascending
      case 2: self = .descending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ascending: return 1
      case .descending: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
}

#if swift(>=4.2)

extension Google_Datastore_V1_PropertyOrder.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Datastore_V1_PropertyOrder.Direction] = [
    .unspecified,
    .ascending,
    .descending,
  ]
}

#endif  // swift(>=4.2)

/// A holder for any type of filter.
struct Google_Datastore_V1_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of filter.
  var filterType: Google_Datastore_V1_Filter.OneOf_FilterType? = nil

  /// A composite filter.
  var compositeFilter: Google_Datastore_V1_CompositeFilter {
    get {
      if case .compositeFilter(let v)? = filterType {return v}
      return Google_Datastore_V1_CompositeFilter()
    }
    set {filterType = .compositeFilter(newValue)}
  }

  /// A filter on a property.
  var propertyFilter: Google_Datastore_V1_PropertyFilter {
    get {
      if case .propertyFilter(let v)? = filterType {return v}
      return Google_Datastore_V1_PropertyFilter()
    }
    set {filterType = .propertyFilter(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of filter.
  enum OneOf_FilterType: Equatable {
    /// A composite filter.
    case compositeFilter(Google_Datastore_V1_CompositeFilter)
    /// A filter on a property.
    case propertyFilter(Google_Datastore_V1_PropertyFilter)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Datastore_V1_Filter.OneOf_FilterType, rhs: Google_Datastore_V1_Filter.OneOf_FilterType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.compositeFilter, .compositeFilter): return {
        guard case .compositeFilter(let l) = lhs, case .compositeFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.propertyFilter, .propertyFilter): return {
        guard case .propertyFilter(let l) = lhs, case .propertyFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A filter that merges multiple other filters using the given operator.
struct Google_Datastore_V1_CompositeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operator for combining multiple filters.
  var op: Google_Datastore_V1_CompositeFilter.Operator = .unspecified

  /// The list of filters to combine.
  /// Must contain at least one filter.
  var filters: [Google_Datastore_V1_Filter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A composite filter operator.
  enum Operator: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// The results are required to satisfy each of the combined filters.
    case and // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .and
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .and: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Google_Datastore_V1_CompositeFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Datastore_V1_CompositeFilter.Operator] = [
    .unspecified,
    .and,
  ]
}

#endif  // swift(>=4.2)

/// A filter on a specific property.
struct Google_Datastore_V1_PropertyFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The property to filter by.
  var property: Google_Datastore_V1_PropertyReference {
    get {return _property ?? Google_Datastore_V1_PropertyReference()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  /// The operator to filter by.
  var op: Google_Datastore_V1_PropertyFilter.Operator = .unspecified

  /// The value to compare the property to.
  var value: Google_Datastore_V1_Value {
    get {return _value ?? Google_Datastore_V1_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A property filter operator.
  enum Operator: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unspecified. This value must not be used.
    case unspecified // = 0

    /// Less than.
    case lessThan // = 1

    /// Less than or equal.
    case lessThanOrEqual // = 2

    /// Greater than.
    case greaterThan // = 3

    /// Greater than or equal.
    case greaterThanOrEqual // = 4

    /// Equal.
    case equal // = 5

    /// Has ancestor.
    case hasAncestor // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .lessThan
      case 2: self = .lessThanOrEqual
      case 3: self = .greaterThan
      case 4: self = .greaterThanOrEqual
      case 5: self = .equal
      case 11: self = .hasAncestor
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .lessThan: return 1
      case .lessThanOrEqual: return 2
      case .greaterThan: return 3
      case .greaterThanOrEqual: return 4
      case .equal: return 5
      case .hasAncestor: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _property: Google_Datastore_V1_PropertyReference? = nil
  fileprivate var _value: Google_Datastore_V1_Value? = nil
}

#if swift(>=4.2)

extension Google_Datastore_V1_PropertyFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Datastore_V1_PropertyFilter.Operator] = [
    .unspecified,
    .lessThan,
    .lessThanOrEqual,
    .greaterThan,
    .greaterThanOrEqual,
    .equal,
    .hasAncestor,
  ]
}

#endif  // swift(>=4.2)

/// A [GQL
/// query](https://cloud.google.com/datastore/docs/apis/gql/gql_reference).
struct Google_Datastore_V1_GqlQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string of the format described
  /// [here](https://cloud.google.com/datastore/docs/apis/gql/gql_reference).
  var queryString: String = String()

  /// When false, the query string must not contain any literals and instead must
  /// bind all values. For example,
  /// `SELECT * FROM Kind WHERE a = 'string literal'` is not allowed, while
  /// `SELECT * FROM Kind WHERE a = @value` is.
  var allowLiterals: Bool = false

  /// For each non-reserved named binding site in the query string, there must be
  /// a named parameter with that name, but not necessarily the inverse.
  ///
  /// Key must match regex `[A-Za-z_$][A-Za-z_$0-9]*`, must not match regex
  /// `__.*__`, and must not be `""`.
  var namedBindings: Dictionary<String,Google_Datastore_V1_GqlQueryParameter> = [:]

  /// Numbered binding site @1 references the first numbered parameter,
  /// effectively using 1-based indexing, rather than the usual 0.
  ///
  /// For each binding site numbered i in `query_string`, there must be an i-th
  /// numbered parameter. The inverse must also be true.
  var positionalBindings: [Google_Datastore_V1_GqlQueryParameter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A binding parameter for a GQL query.
struct Google_Datastore_V1_GqlQueryParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of parameter.
  var parameterType: Google_Datastore_V1_GqlQueryParameter.OneOf_ParameterType? = nil

  /// A value parameter.
  var value: Google_Datastore_V1_Value {
    get {
      if case .value(let v)? = parameterType {return v}
      return Google_Datastore_V1_Value()
    }
    set {parameterType = .value(newValue)}
  }

  /// A query cursor. Query cursors are returned in query
  /// result batches.
  var cursor: Data {
    get {
      if case .cursor(let v)? = parameterType {return v}
      return Data()
    }
    set {parameterType = .cursor(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of parameter.
  enum OneOf_ParameterType: Equatable {
    /// A value parameter.
    case value(Google_Datastore_V1_Value)
    /// A query cursor. Query cursors are returned in query
    /// result batches.
    case cursor(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Datastore_V1_GqlQueryParameter.OneOf_ParameterType, rhs: Google_Datastore_V1_GqlQueryParameter.OneOf_ParameterType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cursor, .cursor): return {
        guard case .cursor(let l) = lhs, case .cursor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A batch of results produced by a query.
struct Google_Datastore_V1_QueryResultBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of results skipped, typically because of an offset.
  var skippedResults: Int32 = 0

  /// A cursor that points to the position after the last skipped result.
  /// Will be set when `skipped_results` != 0.
  var skippedCursor: Data = Data()

  /// The result type for every entity in `entity_results`.
  var entityResultType: Google_Datastore_V1_EntityResult.ResultType = .unspecified

  /// The results for this batch.
  var entityResults: [Google_Datastore_V1_EntityResult] = []

  /// A cursor that points to the position after the last result in the batch.
  var endCursor: Data = Data()

  /// The state of the query after the current batch.
  var moreResults: Google_Datastore_V1_QueryResultBatch.MoreResultsType = .unspecified

  /// The version number of the snapshot this batch was returned from.
  /// This applies to the range of results from the query's `start_cursor` (or
  /// the beginning of the query if no cursor was given) to this batch's
  /// `end_cursor` (not the query's `end_cursor`).
  ///
  /// In a single transaction, subsequent query result batches for the same query
  /// can have a greater snapshot version number. Each batch's snapshot version
  /// is valid for all preceding batches.
  /// The value will be zero for eventually consistent queries.
  var snapshotVersion: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The possible values for the `more_results` field.
  enum MoreResultsType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unspecified. This value is never used.
    case unspecified // = 0

    /// There may be additional batches to fetch from this query.
    case notFinished // = 1

    /// The query is finished, but there may be more results after the limit.
    case moreResultsAfterLimit // = 2

    /// The query is finished, but there may be more results after the end
    /// cursor.
    case moreResultsAfterCursor // = 4

    /// The query is finished, and there are no more results.
    case noMoreResults // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .notFinished
      case 2: self = .moreResultsAfterLimit
      case 3: self = .noMoreResults
      case 4: self = .moreResultsAfterCursor
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .notFinished: return 1
      case .moreResultsAfterLimit: return 2
      case .noMoreResults: return 3
      case .moreResultsAfterCursor: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Google_Datastore_V1_QueryResultBatch.MoreResultsType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Datastore_V1_QueryResultBatch.MoreResultsType] = [
    .unspecified,
    .notFinished,
    .moreResultsAfterLimit,
    .moreResultsAfterCursor,
    .noMoreResults,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.datastore.v1"

extension Google_Datastore_V1_EntityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    4: .same(proto: "version"),
    3: .same(proto: "cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entity) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.cursor) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.cursor, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_EntityResult, rhs: Google_Datastore_V1_EntityResult) -> Bool {
    if lhs._entity != rhs._entity {return false}
    if lhs.version != rhs.version {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_EntityResult.ResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_TYPE_UNSPECIFIED"),
    1: .same(proto: "FULL"),
    2: .same(proto: "PROJECTION"),
    3: .same(proto: "KEY_ONLY"),
  ]
}

extension Google_Datastore_V1_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Query"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "projection"),
    3: .same(proto: "kind"),
    4: .same(proto: "filter"),
    5: .same(proto: "order"),
    6: .standard(proto: "distinct_on"),
    7: .standard(proto: "start_cursor"),
    8: .standard(proto: "end_cursor"),
    10: .same(proto: "offset"),
    12: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.projection) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.kind) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.order) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.distinctOn) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.startCursor) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.endCursor) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.projection.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.projection, fieldNumber: 2)
    }
    if !self.kind.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kind, fieldNumber: 3)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.order.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.order, fieldNumber: 5)
    }
    if !self.distinctOn.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.distinctOn, fieldNumber: 6)
    }
    if !self.startCursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.startCursor, fieldNumber: 7)
    }
    if !self.endCursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.endCursor, fieldNumber: 8)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 10)
    }
    try { if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_Query, rhs: Google_Datastore_V1_Query) -> Bool {
    if lhs.projection != rhs.projection {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.order != rhs.order {return false}
    if lhs.distinctOn != rhs.distinctOn {return false}
    if lhs.startCursor != rhs.startCursor {return false}
    if lhs.endCursor != rhs.endCursor {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_KindExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KindExpression"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_KindExpression, rhs: Google_Datastore_V1_KindExpression) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_PropertyReference, rhs: Google_Datastore_V1_PropertyReference) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_Projection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Projection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_Projection, rhs: Google_Datastore_V1_Projection) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_PropertyOrder, rhs: Google_Datastore_V1_PropertyOrder) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyOrder.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ASCENDING"),
    2: .same(proto: "DESCENDING"),
  ]
}

extension Google_Datastore_V1_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Filter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "composite_filter"),
    2: .standard(proto: "property_filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Datastore_V1_CompositeFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .compositeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .compositeFilter(v)
        }
      }()
      case 2: try {
        var v: Google_Datastore_V1_PropertyFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .propertyFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .propertyFilter(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.filterType {
    case .compositeFilter?: try {
      guard case .compositeFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .propertyFilter?: try {
      guard case .propertyFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_Filter, rhs: Google_Datastore_V1_Filter) -> Bool {
    if lhs.filterType != rhs.filterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CompositeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompositeFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "filters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_CompositeFilter, rhs: Google_Datastore_V1_CompositeFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_CompositeFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "AND"),
  ]
}

extension Google_Datastore_V1_PropertyFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropertyFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "op"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._property) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._property {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 2)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_PropertyFilter, rhs: Google_Datastore_V1_PropertyFilter) -> Bool {
    if lhs._property != rhs._property {return false}
    if lhs.op != rhs.op {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_PropertyFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "LESS_THAN"),
    2: .same(proto: "LESS_THAN_OR_EQUAL"),
    3: .same(proto: "GREATER_THAN"),
    4: .same(proto: "GREATER_THAN_OR_EQUAL"),
    5: .same(proto: "EQUAL"),
    11: .same(proto: "HAS_ANCESTOR"),
  ]
}

extension Google_Datastore_V1_GqlQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GqlQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_string"),
    2: .standard(proto: "allow_literals"),
    5: .standard(proto: "named_bindings"),
    4: .standard(proto: "positional_bindings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.queryString) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowLiterals) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.positionalBindings) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Datastore_V1_GqlQueryParameter>.self, value: &self.namedBindings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queryString.isEmpty {
      try visitor.visitSingularStringField(value: self.queryString, fieldNumber: 1)
    }
    if self.allowLiterals != false {
      try visitor.visitSingularBoolField(value: self.allowLiterals, fieldNumber: 2)
    }
    if !self.positionalBindings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positionalBindings, fieldNumber: 4)
    }
    if !self.namedBindings.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Datastore_V1_GqlQueryParameter>.self, value: self.namedBindings, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_GqlQuery, rhs: Google_Datastore_V1_GqlQuery) -> Bool {
    if lhs.queryString != rhs.queryString {return false}
    if lhs.allowLiterals != rhs.allowLiterals {return false}
    if lhs.namedBindings != rhs.namedBindings {return false}
    if lhs.positionalBindings != rhs.positionalBindings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_GqlQueryParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GqlQueryParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "value"),
    3: .same(proto: "cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Datastore_V1_Value?
        var hadOneofValue = false
        if let current = self.parameterType {
          hadOneofValue = true
          if case .value(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameterType = .value(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.parameterType != nil {try decoder.handleConflictingOneOf()}
          self.parameterType = .cursor(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.parameterType {
    case .value?: try {
      guard case .value(let v)? = self.parameterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cursor?: try {
      guard case .cursor(let v)? = self.parameterType else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_GqlQueryParameter, rhs: Google_Datastore_V1_GqlQueryParameter) -> Bool {
    if lhs.parameterType != rhs.parameterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_QueryResultBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResultBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "skipped_results"),
    3: .standard(proto: "skipped_cursor"),
    1: .standard(proto: "entity_result_type"),
    2: .standard(proto: "entity_results"),
    4: .standard(proto: "end_cursor"),
    5: .standard(proto: "more_results"),
    7: .standard(proto: "snapshot_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.entityResultType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entityResults) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.skippedCursor) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.endCursor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.moreResults) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.skippedResults) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.snapshotVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.entityResultType != .unspecified {
      try visitor.visitSingularEnumField(value: self.entityResultType, fieldNumber: 1)
    }
    if !self.entityResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entityResults, fieldNumber: 2)
    }
    if !self.skippedCursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.skippedCursor, fieldNumber: 3)
    }
    if !self.endCursor.isEmpty {
      try visitor.visitSingularBytesField(value: self.endCursor, fieldNumber: 4)
    }
    if self.moreResults != .unspecified {
      try visitor.visitSingularEnumField(value: self.moreResults, fieldNumber: 5)
    }
    if self.skippedResults != 0 {
      try visitor.visitSingularInt32Field(value: self.skippedResults, fieldNumber: 6)
    }
    if self.snapshotVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.snapshotVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Datastore_V1_QueryResultBatch, rhs: Google_Datastore_V1_QueryResultBatch) -> Bool {
    if lhs.skippedResults != rhs.skippedResults {return false}
    if lhs.skippedCursor != rhs.skippedCursor {return false}
    if lhs.entityResultType != rhs.entityResultType {return false}
    if lhs.entityResults != rhs.entityResults {return false}
    if lhs.endCursor != rhs.endCursor {return false}
    if lhs.moreResults != rhs.moreResults {return false}
    if lhs.snapshotVersion != rhs.snapshotVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Datastore_V1_QueryResultBatch.MoreResultsType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MORE_RESULTS_TYPE_UNSPECIFIED"),
    1: .same(proto: "NOT_FINISHED"),
    2: .same(proto: "MORE_RESULTS_AFTER_LIMIT"),
    3: .same(proto: "NO_MORE_RESULTS"),
    4: .same(proto: "MORE_RESULTS_AFTER_CURSOR"),
  ]
}
